import{arrow as e,computePosition as r}from"@floating-ui/dom";export*from"@floating-ui/dom";import*as t from"react";import{useLayoutEffect as n,useEffect as u}from"react";import*as o from"react-dom";const c=r=>{const{element:t,padding:n}=r;return{name:"arrow",options:r,fn(r){return u=t,Object.prototype.hasOwnProperty.call(u,"current")?null!=t.current?e({element:t.current,padding:n}).fn(r):{}:t?e({element:t,padding:n}).fn(r):{};var u}}};var i="undefined"!=typeof document?n:u;function f(e,r){if(e===r)return!0;if(typeof e!=typeof r)return!1;if("function"==typeof e&&e.toString()===r.toString())return!0;let t,n,u;if(e&&r&&"object"==typeof e){if(Array.isArray(e)){if(t=e.length,t!=r.length)return!1;for(n=t;0!=n--;)if(!f(e[n],r[n]))return!1;return!0}if(u=Object.keys(e),t=u.length,t!==Object.keys(r).length)return!1;for(n=t;0!=n--;)if(!Object.prototype.hasOwnProperty.call(r,u[n]))return!1;for(n=t;0!=n--;){const t=u[n];if(("_owner"!==t||!e.$$typeof)&&!f(e[t],r[t]))return!1}return!0}return e!=e&&r!=r}function l(e){let{middleware:n=[],placement:u="bottom",strategy:c="absolute",whileElementsMounted:l,open:s}=void 0===e?{}:e;const[a,p]=t.useState({x:null,y:null,strategy:c,placement:u,middlewareData:{},isPositioned:!1}),[m,d]=t.useState(n);f(m,n)||d(n);const y=t.useRef(null),g=t.useRef(null),b=t.useRef(null),h=t.useRef(a),w=function(e){const r=t.useRef(e);return i((()=>{r.current=e})),r}(l),k=t.useCallback((()=>{y.current&&g.current&&r(y.current,g.current,{middleware:m,placement:u,strategy:c}).then((e=>{const r={...e,isPositioned:!0};O.current&&!f(h.current,r)&&(h.current=r,o.flushSync((()=>{p(r)})))}))}),[m,u,c]);i((()=>{!1===s&&h.current.isPositioned&&p((e=>({...e,isPositioned:!1})))}),[s]);const O=t.useRef(!1);i((()=>(O.current=!0,()=>{O.current=!1})),[]);const P=t.useCallback((()=>{if("function"==typeof b.current&&(b.current(),b.current=null),y.current&&g.current)if(w.current){const e=w.current(y.current,g.current,k);b.current=e}else k()}),[k,w]),R=t.useCallback((e=>{y.current!==e&&(y.current=e,P())}),[P]),j=t.useCallback((e=>{g.current!==e&&(g.current=e,P())}),[P]),S=t.useMemo((()=>({reference:y,floating:g})),[]);return t.useMemo((()=>({...a,update:k,refs:S,reference:R,floating:j})),[a,k,S,R,j])}export{c as arrow,l as useFloating};
