import {Observable} from 'rxjs'
import {RuleClass} from '@sanity/types'
import {SanityDocument} from '@sanity/types'
import {Schema} from '@sanity/types'
import {SchemaType} from '@sanity/types'
import {ValidationContext} from '@sanity/types'
import {ValidationMarker} from '@sanity/types'

/**
 * this is used make optional properties required by replacing optionals with
 * `T[P] | undefined`. this is used to prevent errors in `validateItem` where
 * an option from a previous invocation would be incorrectly passed down.
 *
 * https://medium.com/terria/typescript-transforming-optional-properties-to-required-properties-that-may-be-undefined-7482cb4e1585
 */
declare type ExplicitUndefined<T> = {
  [P in keyof Required<T>]: Pick<T, P> extends Required<Pick<T, P>> ? T[P] : T[P] | undefined
}

export declare function inferFromSchema(schema: Schema): Schema

export declare function inferFromSchemaType(
  typeDef: SchemaType,
  _schema: Schema,
  _visited?: Set<SchemaType>
): SchemaType

export declare function inferFromSchemaType(typeDef: SchemaType): SchemaType

export declare const Rule: RuleClass

export declare function validateDocument(
  getClient: ValidateItemOptions['getClient'],
  doc: SanityDocument,
  schema: Schema,
  context?: Pick<ValidationContext, 'getDocumentExists'>
): Promise<ValidationMarker[]>

export declare function validateDocumentObservable(
  getClient: ValidateItemOptions['getClient'],
  doc: SanityDocument,
  schema: Schema,
  context?: Pick<ValidationContext, 'getDocumentExists'>
): Observable<ValidationMarker[]>

declare type ValidateItemOptions = {
  value: unknown
} & ExplicitUndefined<ValidationContext>

export {}
