'use strict';

var _templateObject, _templateObject2, _templateObject3, _templateObject4;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var rxjs = require('rxjs');
var schema = require('@sanity/schema');
var debug$l = require('debug');
var content = require('@sanity/util/content');
var slateReact = require('@sanity/slate-react');
var slate = require('slate');
var noop = require('lodash/noop.js');
var omitBy = require('lodash/omitBy.js');
var isUndefined = require('lodash/isUndefined.js');
var get = require('lodash/get.js');
var flatten$1 = require('lodash/flatten.js');
var isEqual = require('lodash/isEqual.js');
var types = require('@sanity/types');
var isObject = require('lodash/isObject.js');
var isString = require('lodash/isString.js');
var findIndex = require('lodash/findIndex.js');
var omit = require('lodash/omit.js');
var clone = require('lodash/clone.js');
var uniq = require('lodash/uniq.js');
var isHotkey = require('is-hotkey');
var blockTools = require('@sanity/block-tools');
var debounce = require('lodash/debounce.js');
var styled = require('styled-components');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var React__default = /*#__PURE__*/_interopDefaultCompat(React);
var debug__default = /*#__PURE__*/_interopDefaultCompat(debug$l);
var noop__default = /*#__PURE__*/_interopDefaultCompat(noop);
var omitBy__default = /*#__PURE__*/_interopDefaultCompat(omitBy);
var isUndefined__default = /*#__PURE__*/_interopDefaultCompat(isUndefined);
var get__default = /*#__PURE__*/_interopDefaultCompat(get);
var flatten__default = /*#__PURE__*/_interopDefaultCompat(flatten$1);
var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual);
var isObject__default = /*#__PURE__*/_interopDefaultCompat(isObject);
var isString__default = /*#__PURE__*/_interopDefaultCompat(isString);
var findIndex__default = /*#__PURE__*/_interopDefaultCompat(findIndex);
var omit__default = /*#__PURE__*/_interopDefaultCompat(omit);
var clone__default = /*#__PURE__*/_interopDefaultCompat(clone);
var uniq__default = /*#__PURE__*/_interopDefaultCompat(uniq);
var isHotkey__default = /*#__PURE__*/_interopDefaultCompat(isHotkey);
var debounce__default = /*#__PURE__*/_interopDefaultCompat(debounce);
var styled__default = /*#__PURE__*/_interopDefaultCompat(styled);
function compileType(rawType) {
  return schema.Schema.compile({
    name: "blockTypeSchema",
    types: [rawType]
  }).get(rawType.name);
}
function getPortableTextMemberSchemaTypes(portableTextType) {
  var _a, _b, _c;
  if (!portableTextType) {
    throw new Error("Parameter 'portabletextType' missing (required)");
  }
  const blockType = (_a = portableTextType.of) == null ? void 0 : _a.find(findBlockType);
  if (!blockType) {
    throw new Error("Block type is not defined in this schema (required)");
  }
  const childrenField = (_b = blockType.fields) == null ? void 0 : _b.find(field => field.name === "children");
  if (!childrenField) {
    throw new Error("Children field for block type found in schema (required)");
  }
  const ofType = childrenField.type.of;
  if (!ofType) {
    throw new Error("Valid types for block children not found in schema (required)");
  }
  const spanType = ofType.find(memberType => memberType.name === "span");
  if (!spanType) {
    throw new Error("Span type not found in schema (required)");
  }
  const inlineObjectTypes = ofType.filter(memberType => memberType.name !== "span") || [];
  const blockObjectTypes = ((_c = portableTextType.of) == null ? void 0 : _c.filter(field => field.name !== blockType.name)) || [];
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    lists: resolveEnabledListItems(blockType),
    block: blockType,
    span: spanType,
    portableText: portableTextType,
    inlineObjects: inlineObjectTypes,
    blockObjects: blockObjectTypes,
    annotations: spanType.annotations
  };
}
function resolveEnabledStyles(blockType) {
  var _a, _b, _c;
  const styleField = (_a = blockType.fields) == null ? void 0 : _a.find(btField => btField.name === "style");
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }
  const textStyles = ((_b = styleField.type.options) == null ? void 0 : _b.list) && ((_c = styleField.type.options.list) == null ? void 0 : _c.filter(style => style.value));
  if (!textStyles || textStyles.length === 0) {
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  }
  return textStyles;
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  var _a, _b;
  const listField = (_a = blockType.fields) == null ? void 0 : _a.find(btField => btField.name === "list");
  if (!listField) {
    throw new Error("A field with name 'list' is not defined in the block type (required).");
  }
  const listItems = ((_b = listField.type.options) == null ? void 0 : _b.list) && listField.type.options.list.filter(list => list.value);
  if (!listItems) {
    throw new Error("The list field need at least to be an empty array");
  }
  return listItems;
}
function findBlockType(type) {
  if (type.type) {
    return findBlockType(type.type);
  }
  if (type.name === "block") {
    return type;
  }
  return null;
}
const rootName = "sanity-pte:";
debug__default.default(rootName);
function debugWithName(name) {
  const namespace = "".concat(rootName).concat(name);
  if (debug__default.default && debug__default.default.enabled(namespace)) {
    return debug__default.default(namespace);
  }
  return debug__default.default(rootName);
}
const defaultKeyGenerator = () => content.randomKey(12);
const PortableTextEditorKeyGeneratorContext = React.createContext(defaultKeyGenerator);
const usePortableTextEditorKeyGenerator = () => {
  const keyGenerator = React.useContext(PortableTextEditorKeyGeneratorContext);
  if (keyGenerator === void 0) {
    throw new Error("The `usePortableTextEditorKeyGenerator` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return keyGenerator;
};
const IS_DRAGGING = /* @__PURE__ */new WeakMap();
const IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */new WeakMap();
const IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */new WeakMap();
const IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */new WeakMap();
const KEY_TO_SLATE_ELEMENT = /* @__PURE__ */new WeakMap();
const KEY_TO_VALUE_ELEMENT = /* @__PURE__ */new WeakMap();
const SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */new WeakMap();
var diffMatchPatch$1 = {
  exports: {}
};

/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function (module) {
  /**
   * @fileoverview Computes the difference between two texts to create a patch.
   * Applies the patch onto another text, allowing for errors.
   * @author fraser@google.com (Neil Fraser)
   */

  /**
   * Class containing the diff, match and patch methods.
   * @constructor
   */
  var diff_match_patch = function () {
    // Defaults.
    // Redefine these in your program to override the defaults.

    // Number of seconds to map a diff before giving up (0 for infinity).
    this.Diff_Timeout = 1.0;
    // Cost of an empty edit operation in terms of edit characters.
    this.Diff_EditCost = 4;
    // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
    this.Match_Threshold = 0.5;
    // How far to search for a match (0 = exact location, 1000+ = broad match).
    // A match this many characters away from the expected location will add
    // 1.0 to the score (0.0 is a perfect match).
    this.Match_Distance = 1000;
    // When deleting a large block of text (over ~64 characters), how close do
    // the contents have to be to match the expected contents. (0.0 = perfection,
    // 1.0 = very loose).  Note that Match_Threshold controls how closely the
    // end points of a delete need to match.
    this.Patch_DeleteThreshold = 0.5;
    // Chunk size for context length.
    this.Patch_Margin = 4;

    // The number of bits in an int.
    this.Match_MaxBits = 32;
  };

  //  DIFF FUNCTIONS

  /**
   * The data structure representing a diff is an array of tuples:
   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
   */
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;

  /**
   * Class representing one diff tuple.
   * ~Attempts to look like a two-element array (which is what this used to be).~
   * Constructor returns an actual two-element array, to allow destructing @JackuB
   * See https://github.com/JackuB/diff-match-patch/issues/14 for details
   * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
   * @param {string} text Text to be deleted, inserted, or retained.
   * @constructor
   */
  diff_match_patch.Diff = function (op, text) {
    return [op, text];
  };

  /**
   * Find the differences between two texts.  Simplifies the problem by stripping
   * any common prefix or suffix off the texts before diffing.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
   *     then don't run a line-level diff first to identify the changed areas.
   *     Defaults to true, which does a faster, slightly less optimal diff.
   * @param {number=} opt_deadline Optional time when the diff should be complete
   *     by.  Used internally for recursive calls.  Users should set DiffTimeout
   *     instead.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   */
  diff_match_patch.prototype.diff_main = function (text1, text2, opt_checklines, opt_deadline) {
    // Set a deadline by which time the diff must be complete.
    if (typeof opt_deadline == 'undefined') {
      if (this.Diff_Timeout <= 0) {
        opt_deadline = Number.MAX_VALUE;
      } else {
        opt_deadline = new Date().getTime() + this.Diff_Timeout * 1000;
      }
    }
    var deadline = opt_deadline;

    // Check for null inputs.
    if (text1 == null || text2 == null) {
      throw new Error('Null input. (diff_main)');
    }

    // Check for equality (speedup).
    if (text1 == text2) {
      if (text1) {
        return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
      }
      return [];
    }
    if (typeof opt_checklines == 'undefined') {
      opt_checklines = true;
    }
    var checklines = opt_checklines;

    // Trim off common prefix (speedup).
    var commonlength = this.diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    // Trim off common suffix (speedup).
    commonlength = this.diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    // Compute the diff on the middle block.
    var diffs = this.diff_compute_(text1, text2, checklines, deadline);

    // Restore the prefix and suffix.
    if (commonprefix) {
      diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
    }
    if (commonsuffix) {
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
    }
    this.diff_cleanupMerge(diffs);
    return diffs;
  };

  /**
   * Find the differences between two texts.  Assumes that the texts do not
   * have any common prefix or suffix.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {boolean} checklines Speedup flag.  If false, then don't run a
   *     line-level diff first to identify the changed areas.
   *     If true, then run a faster, slightly less optimal diff.
   * @param {number} deadline Time when the diff should be complete by.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @private
   */
  diff_match_patch.prototype.diff_compute_ = function (text1, text2, checklines, deadline) {
    var diffs;
    if (!text1) {
      // Just add some text (speedup).
      return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
    }
    if (!text2) {
      // Just delete some text (speedup).
      return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i = longtext.indexOf(shorttext);
    if (i != -1) {
      // Shorter text is inside the longer text (speedup).
      diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)), new diff_match_patch.Diff(DIFF_EQUAL, shorttext), new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(i + shorttext.length))];
      // Swap insertions for deletions if diff is reversed.
      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = DIFF_DELETE;
      }
      return diffs;
    }
    if (shorttext.length == 1) {
      // Single character string.
      // After the previous speedup, the character can't be an equality.
      return [new diff_match_patch.Diff(DIFF_DELETE, text1), new diff_match_patch.Diff(DIFF_INSERT, text2)];
    }

    // Check to see if the problem can be split in two.
    var hm = this.diff_halfMatch_(text1, text2);
    if (hm) {
      // A half-match was found, sort out the return data.
      var text1_a = hm[0];
      var text1_b = hm[1];
      var text2_a = hm[2];
      var text2_b = hm[3];
      var mid_common = hm[4];
      // Send both pairs off for separate processing.
      var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
      var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
      // Merge the results.
      return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)], diffs_b);
    }
    if (checklines && text1.length > 100 && text2.length > 100) {
      return this.diff_lineMode_(text1, text2, deadline);
    }
    return this.diff_bisect_(text1, text2, deadline);
  };

  /**
   * Do a quick line-level diff on both strings, then rediff the parts for
   * greater accuracy.
   * This speedup can produce non-minimal diffs.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {number} deadline Time when the diff should be complete by.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @private
   */
  diff_match_patch.prototype.diff_lineMode_ = function (text1, text2, deadline) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars_(text1, text2);
    text1 = a.chars1;
    text2 = a.chars2;
    var linearray = a.lineArray;
    var diffs = this.diff_main(text1, text2, false, deadline);

    // Convert the diff back to original text.
    this.diff_charsToLines_(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
            for (var j = subDiff.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, subDiff[j]);
            }
            pointer = pointer + subDiff.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
      pointer++;
    }
    diffs.pop(); // Remove the dummy entry at the end.

    return diffs;
  };

  /**
   * Find the 'middle snake' of a diff, split the problem in two
   * and return the recursively constructed diff.
   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {number} deadline Time at which to bail if not yet complete.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @private
   */
  diff_match_patch.prototype.diff_bisect_ = function (text1, text2, deadline) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v1 = new Array(v_length);
    var v2 = new Array(v_length);
    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
    // integers and undefined.
    for (var x = 0; x < v_length; x++) {
      v1[x] = -1;
      v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    // If the total number of characters is odd, then the front path will collide
    // with the reverse path.
    var front = delta % 2 != 0;
    // Offsets for start and end of k loop.
    // Prevents mapping of space beyond the grid.
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d = 0; d < max_d; d++) {
      // Bail out if deadline is reached.
      if (new Date().getTime() > deadline) {
        break;
      }

      // Walk the front path one step.
      for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
        var k1_offset = v_offset + k1;
        var x1;
        if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        var y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          // Ran off the right of the graph.
          k1end += 2;
        } else if (y1 > text2_length) {
          // Ran off the bottom of the graph.
          k1start += 2;
        } else if (front) {
          var k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
            // Mirror x2 onto top-left coordinate system.
            var x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              // Overlap detected.
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }

      // Walk the reverse path one step.
      for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
        var k2_offset = v_offset + k2;
        var x2;
        if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        var y2 = x2 - k2;
        while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          // Ran off the left of the graph.
          k2end += 2;
        } else if (y2 > text2_length) {
          // Ran off the top of the graph.
          k2start += 2;
        } else if (!front) {
          var k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
            var x1 = v1[k1_offset];
            var y1 = v_offset + x1 - k1_offset;
            // Mirror x2 onto top-left coordinate system.
            x2 = text1_length - x2;
            if (x1 >= x2) {
              // Overlap detected.
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
    }
    // Diff took too long and hit the deadline or
    // number of diffs equals number of characters, no commonality at all.
    return [new diff_match_patch.Diff(DIFF_DELETE, text1), new diff_match_patch.Diff(DIFF_INSERT, text2)];
  };

  /**
   * Given the location of the 'middle snake', split the diff in two parts
   * and recurse.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {number} x Index of split point in text1.
   * @param {number} y Index of split point in text2.
   * @param {number} deadline Time at which to bail if not yet complete.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @private
   */
  diff_match_patch.prototype.diff_bisectSplit_ = function (text1, text2, x, y, deadline) {
    var text1a = text1.substring(0, x);
    var text2a = text2.substring(0, y);
    var text1b = text1.substring(x);
    var text2b = text2.substring(y);

    // Compute both diffs serially.
    var diffs = this.diff_main(text1a, text2a, false, deadline);
    var diffsb = this.diff_main(text1b, text2b, false, deadline);
    return diffs.concat(diffsb);
  };

  /**
   * Split two texts into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
   *     An object containing the encoded text1, the encoded text2 and
   *     the array of unique strings.
   *     The zeroth element of the array of unique strings is intentionally blank.
   * @private
   */
  diff_match_patch.prototype.diff_linesToChars_ = function (text1, text2) {
    var lineArray = []; // e.g. lineArray[4] == 'Hello\n'
    var lineHash = {}; // e.g. lineHash['Hello\n'] == 4

    // '\x00' is a valid character, but various debuggers don't like it.
    // So we'll insert a junk entry to avoid generating a null character.
    lineArray[0] = '';

    /**
     * Split a text into an array of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * Modifies linearray and linehash through being a closure.
     * @param {string} text String to encode.
     * @return {string} Encoded string.
     * @private
     */
    function diff_linesToCharsMunge_(text) {
      var chars = '';
      // Walk the text, pulling out a substring for each line.
      // text.split('\n') would would temporarily double our memory footprint.
      // Modifying text would create many large strings to garbage collect.
      var lineStart = 0;
      var lineEnd = -1;
      // Keeping our own length variable is faster than looking it up.
      var lineArrayLength = lineArray.length;
      while (lineEnd < text.length - 1) {
        lineEnd = text.indexOf('\n', lineStart);
        if (lineEnd == -1) {
          lineEnd = text.length - 1;
        }
        var line = text.substring(lineStart, lineEnd + 1);
        if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {
          chars += String.fromCharCode(lineHash[line]);
        } else {
          if (lineArrayLength == maxLines) {
            // Bail out at 65535 because
            // String.fromCharCode(65536) == String.fromCharCode(0)
            line = text.substring(lineStart);
            lineEnd = text.length;
          }
          chars += String.fromCharCode(lineArrayLength);
          lineHash[line] = lineArrayLength;
          lineArray[lineArrayLength++] = line;
        }
        lineStart = lineEnd + 1;
      }
      return chars;
    }
    // Allocate 2/3rds of the space for text1, the rest for text2.
    var maxLines = 40000;
    var chars1 = diff_linesToCharsMunge_(text1);
    maxLines = 65535;
    var chars2 = diff_linesToCharsMunge_(text2);
    return {
      chars1: chars1,
      chars2: chars2,
      lineArray: lineArray
    };
  };

  /**
   * Rehydrate the text in a diff from a string of line hashes to real lines of
   * text.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @param {!Array.<string>} lineArray Array of unique strings.
   * @private
   */
  diff_match_patch.prototype.diff_charsToLines_ = function (diffs, lineArray) {
    for (var i = 0; i < diffs.length; i++) {
      var chars = diffs[i][1];
      var text = [];
      for (var j = 0; j < chars.length; j++) {
        text[j] = lineArray[chars.charCodeAt(j)];
      }
      diffs[i][1] = text.join('');
    }
  };

  /**
   * Determine the common prefix of two strings.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {number} The number of characters common to the start of each
   *     string.
   */
  diff_match_patch.prototype.diff_commonPrefix = function (text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
      return 0;
    }
    // Binary search.
    // Performance analysis: https://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };

  /**
   * Determine the common suffix of two strings.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {number} The number of characters common to the end of each string.
   */
  diff_match_patch.prototype.diff_commonSuffix = function (text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
      return 0;
    }
    // Binary search.
    // Performance analysis: https://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };

  /**
   * Determine if the suffix of one string is the prefix of another.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {number} The number of characters common to the end of the first
   *     string and the start of the second string.
   * @private
   */
  diff_match_patch.prototype.diff_commonOverlap_ = function (text1, text2) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    // Eliminate the null case.
    if (text1_length == 0 || text2_length == 0) {
      return 0;
    }
    // Truncate the longer string.
    if (text1_length > text2_length) {
      text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
      text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    // Quick check for the worst case.
    if (text1 == text2) {
      return text_length;
    }

    // Start by looking for a single character match
    // and increase length until no match is found.
    // Performance analysis: https://neil.fraser.name/news/2010/11/04/
    var best = 0;
    var length = 1;
    while (true) {
      var pattern = text1.substring(text_length - length);
      var found = text2.indexOf(pattern);
      if (found == -1) {
        return best;
      }
      length += found;
      if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
        best = length;
        length++;
      }
    }
  };

  /**
   * Do the two texts share a substring which is at least half the length of the
   * longer text?
   * This speedup can produce non-minimal diffs.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     text1, the suffix of text1, the prefix of text2, the suffix of
   *     text2 and the common middle.  Or null if there was no match.
   * @private
   */
  diff_match_patch.prototype.diff_halfMatch_ = function (text1, text2) {
    if (this.Diff_Timeout <= 0) {
      // Don't risk returning a non-optimal diff if we have unlimited time.
      return null;
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return null; // Pointless.
    }

    var dmp = this; // 'this' becomes 'window' in a closure.

    /**
     * Does a substring of shorttext exist within longtext such that the substring
     * is at least half the length of longtext?
     * Closure, but does not reference any external variables.
     * @param {string} longtext Longer string.
     * @param {string} shorttext Shorter string.
     * @param {number} i Start index of quarter length substring within longtext.
     * @return {Array.<string>} Five element Array, containing the prefix of
     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
     *     of shorttext and the common middle.  Or null if there was no match.
     * @private
     */
    function diff_halfMatchI_(longtext, shorttext, i) {
      // Start with a 1/4 length substring at position i as a seed.
      var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
      var j = -1;
      var best_common = '';
      var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
      while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
        var prefixLength = dmp.diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
        var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
        if (best_common.length < suffixLength + prefixLength) {
          best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
          best_longtext_a = longtext.substring(0, i - suffixLength);
          best_longtext_b = longtext.substring(i + prefixLength);
          best_shorttext_a = shorttext.substring(0, j - suffixLength);
          best_shorttext_b = shorttext.substring(j + prefixLength);
        }
      }
      if (best_common.length * 2 >= longtext.length) {
        return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
      } else {
        return null;
      }
    }

    // First check if the second quarter is the seed for a half-match.
    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
    // Check again based on the third quarter.
    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
    var hm;
    if (!hm1 && !hm2) {
      return null;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      // Both matched.  Select the longest.
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    // A half-match was found, sort out the return data.
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  };

  /**
   * Reduce the number of edits by eliminating semantically trivial equalities.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   */
  diff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {
    var changes = false;
    var equalities = []; // Stack of indices where equalities are found.
    var equalitiesLength = 0; // Keeping our own length var is faster in JS.
    /** @type {?string} */
    var lastEquality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0; // Index of current position.
    // Number of characters that changed prior to the equality.
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    // Number of characters that changed after the equality.
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        // Equality found.
        equalities[equalitiesLength++] = pointer;
        length_insertions1 = length_insertions2;
        length_deletions1 = length_deletions2;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = diffs[pointer][1];
      } else {
        // An insertion or deletion.
        if (diffs[pointer][0] == DIFF_INSERT) {
          length_insertions2 += diffs[pointer][1].length;
        } else {
          length_deletions2 += diffs[pointer][1].length;
        }
        // Eliminate an equality that is smaller or equal to the edits on both
        // sides of it.
        if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
          // Duplicate record.
          diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
          // Change second copy to insert.
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          // Throw away the equality we just deleted.
          equalitiesLength--;
          // Throw away the previous equality (it needs to be reevaluated).
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          length_insertions1 = 0; // Reset the counters.
          length_deletions1 = 0;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = null;
          changes = true;
        }
      }
      pointer++;
    }

    // Normalize the diff.
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
    this.diff_cleanupSemanticLossless(diffs);

    // Find any overlaps between deletions and insertions.
    // e.g: <del>abcxxx</del><ins>xxxdef</ins>
    //   -> <del>abc</del>xxx<ins>def</ins>
    // e.g: <del>xxxabc</del><ins>defxxx</ins>
    //   -> <ins>def</ins>xxx<del>abc</del>
    // Only extract an overlap if it is as big as the edit ahead or behind it.
    pointer = 1;
    while (pointer < diffs.length) {
      if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
        var deletion = diffs[pointer - 1][1];
        var insertion = diffs[pointer][1];
        var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
        var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
        if (overlap_length1 >= overlap_length2) {
          if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
            // Overlap found.  Insert an equality and trim the surrounding edits.
            diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
            diffs[pointer + 1][1] = insertion.substring(overlap_length1);
            pointer++;
          }
        } else {
          if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
            // Reverse overlap found.
            // Insert an equality and swap and trim the surrounding edits.
            diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
            diffs[pointer - 1][0] = DIFF_INSERT;
            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
            diffs[pointer + 1][0] = DIFF_DELETE;
            diffs[pointer + 1][1] = deletion.substring(overlap_length2);
            pointer++;
          }
        }
        pointer++;
      }
      pointer++;
    }
  };

  /**
   * Look for single edits surrounded on both sides by equalities
   * which can be shifted sideways to align the edit to a word boundary.
   * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   */
  diff_match_patch.prototype.diff_cleanupSemanticLossless = function (diffs) {
    /**
     * Given two strings, compute a score representing whether the internal
     * boundary falls on logical boundaries.
     * Scores range from 6 (best) to 0 (worst).
     * Closure, but does not reference any external variables.
     * @param {string} one First string.
     * @param {string} two Second string.
     * @return {number} The score.
     * @private
     */
    function diff_cleanupSemanticScore_(one, two) {
      if (!one || !two) {
        // Edges are the best.
        return 6;
      }

      // Each port of this function behaves slightly differently due to
      // subtle differences in each language's definition of things like
      // 'whitespace'.  Since this function's purpose is largely cosmetic,
      // the choice has been made to use each language's native features
      // rather than force total conformity.
      var char1 = one.charAt(one.length - 1);
      var char2 = two.charAt(0);
      var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
      var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
      var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
      var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
      var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
      var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
      var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
      var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
      if (blankLine1 || blankLine2) {
        // Five points for blank lines.
        return 5;
      } else if (lineBreak1 || lineBreak2) {
        // Four points for line breaks.
        return 4;
      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
        // Three points for end of sentences.
        return 3;
      } else if (whitespace1 || whitespace2) {
        // Two points for whitespace.
        return 2;
      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
        // One point for non-alphanumeric.
        return 1;
      }
      return 0;
    }
    var pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        // This is a single edit surrounded by equalities.
        var equality1 = diffs[pointer - 1][1];
        var edit = diffs[pointer][1];
        var equality2 = diffs[pointer + 1][1];

        // First, shift the edit as far left as possible.
        var commonOffset = this.diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          var commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset);
          edit = commonString + edit.substring(0, edit.length - commonOffset);
          equality2 = commonString + equality2;
        }

        // Second, step character by character right, looking for the best fit.
        var bestEquality1 = equality1;
        var bestEdit = edit;
        var bestEquality2 = equality2;
        var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        while (edit.charAt(0) === equality2.charAt(0)) {
          equality1 += edit.charAt(0);
          edit = edit.substring(1) + equality2.charAt(0);
          equality2 = equality2.substring(1);
          var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          // The >= encourages trailing rather than leading whitespace on edits.
          if (score >= bestScore) {
            bestScore = score;
            bestEquality1 = equality1;
            bestEdit = edit;
            bestEquality2 = equality2;
          }
        }
        if (diffs[pointer - 1][1] != bestEquality1) {
          // We have an improvement, save it back to the diff.
          if (bestEquality1) {
            diffs[pointer - 1][1] = bestEquality1;
          } else {
            diffs.splice(pointer - 1, 1);
            pointer--;
          }
          diffs[pointer][1] = bestEdit;
          if (bestEquality2) {
            diffs[pointer + 1][1] = bestEquality2;
          } else {
            diffs.splice(pointer + 1, 1);
            pointer--;
          }
        }
      }
      pointer++;
    }
  };

  // Define some regex patterns for matching boundaries.
  diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
  diff_match_patch.whitespaceRegex_ = /\s/;
  diff_match_patch.linebreakRegex_ = /[\r\n]/;
  diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
  diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

  /**
   * Reduce the number of edits by eliminating operationally trivial equalities.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   */
  diff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {
    var changes = false;
    var equalities = []; // Stack of indices where equalities are found.
    var equalitiesLength = 0; // Keeping our own length var is faster in JS.
    /** @type {?string} */
    var lastEquality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0; // Index of current position.
    // Is there an insertion operation before the last equality.
    var pre_ins = false;
    // Is there a deletion operation before the last equality.
    var pre_del = false;
    // Is there an insertion operation after the last equality.
    var post_ins = false;
    // Is there a deletion operation after the last equality.
    var post_del = false;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        // Equality found.
        if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
          // Candidate found.
          equalities[equalitiesLength++] = pointer;
          pre_ins = post_ins;
          pre_del = post_del;
          lastEquality = diffs[pointer][1];
        } else {
          // Not a candidate, and can never become one.
          equalitiesLength = 0;
          lastEquality = null;
        }
        post_ins = post_del = false;
      } else {
        // An insertion or deletion.
        if (diffs[pointer][0] == DIFF_DELETE) {
          post_del = true;
        } else {
          post_ins = true;
        }
        /*
         * Five types to be split:
         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
         * <ins>A</ins>X<ins>C</ins><del>D</del>
         * <ins>A</ins><del>B</del>X<ins>C</ins>
         * <ins>A</del>X<ins>C</ins><del>D</del>
         * <ins>A</ins><del>B</del>X<del>C</del>
         */
        if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
          // Duplicate record.
          diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
          // Change second copy to insert.
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--; // Throw away the equality we just deleted;
          lastEquality = null;
          if (pre_ins && pre_del) {
            // No changes made which could affect previous entry, keep going.
            post_ins = post_del = true;
            equalitiesLength = 0;
          } else {
            equalitiesLength--; // Throw away the previous equality.
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            post_ins = post_del = false;
          }
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };

  /**
   * Reorder and merge like edit sections.  Merge equalities.
   * Any edit section can move as long as it doesn't cross an equality.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   */
  diff_match_patch.prototype.diff_cleanupMerge = function (diffs) {
    // Add a dummy entry at the end.
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    var commonlength;
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete + count_insert > 1) {
            if (count_delete !== 0 && count_insert !== 0) {
              // Factor out any common prefixies.
              commonlength = this.diff_commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                  diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                } else {
                  diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }
              // Factor out any common suffixies.
              commonlength = this.diff_commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                text_insert = text_insert.substring(0, text_insert.length - commonlength);
                text_delete = text_delete.substring(0, text_delete.length - commonlength);
              }
            }
            // Delete the offending records and add the merged ones.
            pointer -= count_delete + count_insert;
            diffs.splice(pointer, count_delete + count_insert);
            if (text_delete.length) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_DELETE, text_delete));
              pointer++;
            }
            if (text_insert.length) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_INSERT, text_insert));
              pointer++;
            }
            pointer++;
          } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
            // Merge this equality with the previous one.
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
    }
    if (diffs[diffs.length - 1][1] === '') {
      diffs.pop(); // Remove the dummy entry at the end.
    }

    // Second pass: look for single edits surrounded on both sides by equalities
    // which can be shifted sideways to eliminate an equality.
    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
    var changes = false;
    pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        // This is a single edit surrounded by equalities.
        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
          // Shift the edit over the previous equality.
          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
          // Shift the edit over the next equality.
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };

  /**
   * loc is a location in text1, compute and return the equivalent location in
   * text2.
   * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @param {number} loc Location within text1.
   * @return {number} Location within text2.
   */
  diff_match_patch.prototype.diff_xIndex = function (diffs, loc) {
    var chars1 = 0;
    var chars2 = 0;
    var last_chars1 = 0;
    var last_chars2 = 0;
    var x;
    for (x = 0; x < diffs.length; x++) {
      if (diffs[x][0] !== DIFF_INSERT) {
        // Equality or deletion.
        chars1 += diffs[x][1].length;
      }
      if (diffs[x][0] !== DIFF_DELETE) {
        // Equality or insertion.
        chars2 += diffs[x][1].length;
      }
      if (chars1 > loc) {
        // Overshot the location.
        break;
      }
      last_chars1 = chars1;
      last_chars2 = chars2;
    }
    // Was the location was deleted?
    if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
      return last_chars2;
    }
    // Add the remaining character length.
    return last_chars2 + (loc - last_chars1);
  };

  /**
   * Convert a diff array into a pretty HTML report.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @return {string} HTML representation.
   */
  diff_match_patch.prototype.diff_prettyHtml = function (diffs) {
    var html = [];
    var pattern_amp = /&/g;
    var pattern_lt = /</g;
    var pattern_gt = />/g;
    var pattern_para = /\n/g;
    for (var x = 0; x < diffs.length; x++) {
      var op = diffs[x][0]; // Operation (insert, delete, equal)
      var data = diffs[x][1]; // Text of change.
      var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;').replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
      switch (op) {
        case DIFF_INSERT:
          html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
          break;
        case DIFF_DELETE:
          html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
          break;
        case DIFF_EQUAL:
          html[x] = '<span>' + text + '</span>';
          break;
      }
    }
    return html.join('');
  };

  /**
   * Compute and return the source text (all equalities and deletions).
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @return {string} Source text.
   */
  diff_match_patch.prototype.diff_text1 = function (diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
      if (diffs[x][0] !== DIFF_INSERT) {
        text[x] = diffs[x][1];
      }
    }
    return text.join('');
  };

  /**
   * Compute and return the destination text (all equalities and insertions).
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @return {string} Destination text.
   */
  diff_match_patch.prototype.diff_text2 = function (diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
      if (diffs[x][0] !== DIFF_DELETE) {
        text[x] = diffs[x][1];
      }
    }
    return text.join('');
  };

  /**
   * Compute the Levenshtein distance; the number of inserted, deleted or
   * substituted characters.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @return {number} Number of changes.
   */
  diff_match_patch.prototype.diff_levenshtein = function (diffs) {
    var levenshtein = 0;
    var insertions = 0;
    var deletions = 0;
    for (var x = 0; x < diffs.length; x++) {
      var op = diffs[x][0];
      var data = diffs[x][1];
      switch (op) {
        case DIFF_INSERT:
          insertions += data.length;
          break;
        case DIFF_DELETE:
          deletions += data.length;
          break;
        case DIFF_EQUAL:
          // A deletion and an insertion is one substitution.
          levenshtein += Math.max(insertions, deletions);
          insertions = 0;
          deletions = 0;
          break;
      }
    }
    levenshtein += Math.max(insertions, deletions);
    return levenshtein;
  };

  /**
   * Crush the diff into an encoded string which describes the operations
   * required to transform text1 into text2.
   * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
   * Operations are tab-separated.  Inserted text is escaped using %xx notation.
   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
   * @return {string} Delta text.
   */
  diff_match_patch.prototype.diff_toDelta = function (diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
      switch (diffs[x][0]) {
        case DIFF_INSERT:
          text[x] = '+' + encodeURI(diffs[x][1]);
          break;
        case DIFF_DELETE:
          text[x] = '-' + diffs[x][1].length;
          break;
        case DIFF_EQUAL:
          text[x] = '=' + diffs[x][1].length;
          break;
      }
    }
    return text.join('\t').replace(/%20/g, ' ');
  };

  /**
   * Given the original text1, and an encoded string which describes the
   * operations required to transform text1 into text2, compute the full diff.
   * @param {string} text1 Source string for the diff.
   * @param {string} delta Delta text.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @throws {!Error} If invalid input.
   */
  diff_match_patch.prototype.diff_fromDelta = function (text1, delta) {
    var diffs = [];
    var diffsLength = 0; // Keeping our own length var is faster in JS.
    var pointer = 0; // Cursor in text1
    var tokens = delta.split(/\t/g);
    for (var x = 0; x < tokens.length; x++) {
      // Each token begins with a one character parameter which specifies the
      // operation of this token (delete, insert, equality).
      var param = tokens[x].substring(1);
      switch (tokens[x].charAt(0)) {
        case '+':
          try {
            diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
          } catch (ex) {
            // Malformed URI sequence.
            throw new Error('Illegal escape in diff_fromDelta: ' + param);
          }
          break;
        case '-':
        // Fall through.
        case '=':
          var n = parseInt(param, 10);
          if (isNaN(n) || n < 0) {
            throw new Error('Invalid number in diff_fromDelta: ' + param);
          }
          var text = text1.substring(pointer, pointer += n);
          if (tokens[x].charAt(0) == '=') {
            diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
          } else {
            diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
          }
          break;
        default:
          // Blank tokens are ok (from a trailing \t).
          // Anything else is an error.
          if (tokens[x]) {
            throw new Error('Invalid diff operation in diff_fromDelta: ' + tokens[x]);
          }
      }
    }
    if (pointer != text1.length) {
      throw new Error('Delta length (' + pointer + ') does not equal source text length (' + text1.length + ').');
    }
    return diffs;
  };

  //  MATCH FUNCTIONS

  /**
   * Locate the best instance of 'pattern' in 'text' near 'loc'.
   * @param {string} text The text to search.
   * @param {string} pattern The pattern to search for.
   * @param {number} loc The location to search around.
   * @return {number} Best match index or -1.
   */
  diff_match_patch.prototype.match_main = function (text, pattern, loc) {
    // Check for null inputs.
    if (text == null || pattern == null || loc == null) {
      throw new Error('Null input. (match_main)');
    }
    loc = Math.max(0, Math.min(loc, text.length));
    if (text == pattern) {
      // Shortcut (potentially not guaranteed by the algorithm)
      return 0;
    } else if (!text.length) {
      // Nothing to match.
      return -1;
    } else if (text.substring(loc, loc + pattern.length) == pattern) {
      // Perfect match at the perfect spot!  (Includes case of null pattern)
      return loc;
    } else {
      // Do a fuzzy compare.
      return this.match_bitap_(text, pattern, loc);
    }
  };

  /**
   * Locate the best instance of 'pattern' in 'text' near 'loc' using the
   * Bitap algorithm.
   * @param {string} text The text to search.
   * @param {string} pattern The pattern to search for.
   * @param {number} loc The location to search around.
   * @return {number} Best match index or -1.
   * @private
   */
  diff_match_patch.prototype.match_bitap_ = function (text, pattern, loc) {
    if (pattern.length > this.Match_MaxBits) {
      throw new Error('Pattern too long for this browser.');
    }

    // Initialise the alphabet.
    var s = this.match_alphabet_(pattern);
    var dmp = this; // 'this' becomes 'window' in a closure.

    /**
     * Compute and return the score for a match with e errors and x location.
     * Accesses loc and pattern through being a closure.
     * @param {number} e Number of errors in match.
     * @param {number} x Location of match.
     * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
     * @private
     */
    function match_bitapScore_(e, x) {
      var accuracy = e / pattern.length;
      var proximity = Math.abs(loc - x);
      if (!dmp.Match_Distance) {
        // Dodge divide by zero error.
        return proximity ? 1.0 : accuracy;
      }
      return accuracy + proximity / dmp.Match_Distance;
    }

    // Highest score beyond which we give up.
    var score_threshold = this.Match_Threshold;
    // Is there a nearby exact match? (speedup)
    var best_loc = text.indexOf(pattern, loc);
    if (best_loc != -1) {
      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      // What about in the other direction? (speedup)
      best_loc = text.lastIndexOf(pattern, loc + pattern.length);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      }
    }

    // Initialise the bit arrays.
    var matchmask = 1 << pattern.length - 1;
    best_loc = -1;
    var bin_min, bin_mid;
    var bin_max = pattern.length + text.length;
    var last_rd;
    for (var d = 0; d < pattern.length; d++) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from 'loc' we can stray at this
      // error level.
      bin_min = 0;
      bin_mid = bin_max;
      while (bin_min < bin_mid) {
        if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
          bin_min = bin_mid;
        } else {
          bin_max = bin_mid;
        }
        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
      }
      // Use the result from this iteration as the maximum for the next.
      bin_max = bin_mid;
      var start = Math.max(1, loc - bin_mid + 1);
      var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
      var rd = Array(finish + 2);
      rd[finish + 1] = (1 << d) - 1;
      for (var j = finish; j >= start; j--) {
        // The alphabet (s) is a sparse hash, so the following line generates
        // warnings.
        var charMatch = s[text.charAt(j - 1)];
        if (d === 0) {
          // First pass: exact match.
          rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
        } else {
          // Subsequent passes: fuzzy match.
          rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
        }
        if (rd[j] & matchmask) {
          var score = match_bitapScore_(d, j - 1);
          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (score <= score_threshold) {
            // Told you so.
            score_threshold = score;
            best_loc = j - 1;
            if (best_loc > loc) {
              // When passing loc, don't exceed our current distance from loc.
              start = Math.max(1, 2 * loc - best_loc);
            } else {
              // Already passed loc, downhill from here on in.
              break;
            }
          }
        }
      }
      // No hope for a (better) match at greater error levels.
      if (match_bitapScore_(d + 1, loc) > score_threshold) {
        break;
      }
      last_rd = rd;
    }
    return best_loc;
  };

  /**
   * Initialise the alphabet for the Bitap algorithm.
   * @param {string} pattern The text to encode.
   * @return {!Object} Hash of character locations.
   * @private
   */
  diff_match_patch.prototype.match_alphabet_ = function (pattern) {
    var s = {};
    for (var i = 0; i < pattern.length; i++) {
      s[pattern.charAt(i)] = 0;
    }
    for (var i = 0; i < pattern.length; i++) {
      s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    }
    return s;
  };

  //  PATCH FUNCTIONS

  /**
   * Increase the context until it is unique,
   * but don't let the pattern expand beyond Match_MaxBits.
   * @param {!diff_match_patch.patch_obj} patch The patch to grow.
   * @param {string} text Source text.
   * @private
   */
  diff_match_patch.prototype.patch_addContext_ = function (patch, text) {
    if (text.length == 0) {
      return;
    }
    if (patch.start2 === null) {
      throw Error('patch not initialized');
    }
    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
    var padding = 0;

    // Look for the first and last matches of pattern in text.  If two different
    // matches are found, increase the pattern length.
    while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
      padding += this.Patch_Margin;
      pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
    }
    // Add one chunk for good luck.
    padding += this.Patch_Margin;

    // Add the prefix.
    var prefix = text.substring(patch.start2 - padding, patch.start2);
    if (prefix) {
      patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
    }
    // Add the suffix.
    var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
    if (suffix) {
      patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
    }

    // Roll back the start points.
    patch.start1 -= prefix.length;
    patch.start2 -= prefix.length;
    // Extend the lengths.
    patch.length1 += prefix.length + suffix.length;
    patch.length2 += prefix.length + suffix.length;
  };

  /**
   * Compute a list of patches to turn text1 into text2.
   * Use diffs if provided, otherwise compute it ourselves.
   * There are four ways to call this function, depending on what data is
   * available to the caller:
   * Method 1:
   * a = text1, b = text2
   * Method 2:
   * a = diffs
   * Method 3 (optimal):
   * a = text1, b = diffs
   * Method 4 (deprecated, use method 3):
   * a = text1, b = text2, c = diffs
   *
   * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
   * Array of diff tuples for text1 to text2 (method 2).
   * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
   * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
   * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
   * for text1 to text2 (method 4) or undefined (methods 1,2,3).
   * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
   */
  diff_match_patch.prototype.patch_make = function (a, opt_b, opt_c) {
    var text1, diffs;
    if (typeof a == 'string' && typeof opt_b == 'string' && typeof opt_c == 'undefined') {
      // Method 1: text1, text2
      // Compute diffs from text1 and text2.
      text1 = /** @type {string} */a;
      diffs = this.diff_main(text1, /** @type {string} */opt_b, true);
      if (diffs.length > 2) {
        this.diff_cleanupSemantic(diffs);
        this.diff_cleanupEfficiency(diffs);
      }
    } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' && typeof opt_c == 'undefined') {
      // Method 2: diffs
      // Compute text1 from diffs.
      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */a;
      text1 = this.diff_text1(diffs);
    } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' && typeof opt_c == 'undefined') {
      // Method 3: text1, diffs
      text1 = /** @type {string} */a;
      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */opt_b;
    } else if (typeof a == 'string' && typeof opt_b == 'string' && opt_c && typeof opt_c == 'object') {
      // Method 4: text1, text2, diffs
      // text2 is not used.
      text1 = /** @type {string} */a;
      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */opt_c;
    } else {
      throw new Error('Unknown call format to patch_make.');
    }
    if (diffs.length === 0) {
      return []; // Get rid of the null case.
    }

    var patches = [];
    var patch = new diff_match_patch.patch_obj();
    var patchDiffLength = 0; // Keeping our own length var is faster in JS.
    var char_count1 = 0; // Number of characters into the text1 string.
    var char_count2 = 0; // Number of characters into the text2 string.
    // Start with text1 (prepatch_text) and apply the diffs until we arrive at
    // text2 (postpatch_text).  We recreate the patches one by one to determine
    // context info.
    var prepatch_text = text1;
    var postpatch_text = text1;
    for (var x = 0; x < diffs.length; x++) {
      var diff_type = diffs[x][0];
      var diff_text = diffs[x][1];
      if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
        // A new patch starts here.
        patch.start1 = char_count1;
        patch.start2 = char_count2;
      }
      switch (diff_type) {
        case DIFF_INSERT:
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length2 += diff_text.length;
          postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
          break;
        case DIFF_DELETE:
          patch.length1 += diff_text.length;
          patch.diffs[patchDiffLength++] = diffs[x];
          postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
          break;
        case DIFF_EQUAL:
          if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
            // Small equality inside a patch.
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length1 += diff_text.length;
            patch.length2 += diff_text.length;
          } else if (diff_text.length >= 2 * this.Patch_Margin) {
            // Time for a new patch.
            if (patchDiffLength) {
              this.patch_addContext_(patch, prepatch_text);
              patches.push(patch);
              patch = new diff_match_patch.patch_obj();
              patchDiffLength = 0;
              // Unlike Unidiff, our patch lists have a rolling context.
              // https://github.com/google/diff-match-patch/wiki/Unidiff
              // Update prepatch text & pos to reflect the application of the
              // just completed patch.
              prepatch_text = postpatch_text;
              char_count1 = char_count2;
            }
          }
          break;
      }

      // Update the current character count.
      if (diff_type !== DIFF_INSERT) {
        char_count1 += diff_text.length;
      }
      if (diff_type !== DIFF_DELETE) {
        char_count2 += diff_text.length;
      }
    }
    // Pick up the leftover patch if not empty.
    if (patchDiffLength) {
      this.patch_addContext_(patch, prepatch_text);
      patches.push(patch);
    }
    return patches;
  };

  /**
   * Given an array of patches, return another array that is identical.
   * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
   * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
   */
  diff_match_patch.prototype.patch_deepCopy = function (patches) {
    // Making deep copies is hard in JavaScript.
    var patchesCopy = [];
    for (var x = 0; x < patches.length; x++) {
      var patch = patches[x];
      var patchCopy = new diff_match_patch.patch_obj();
      patchCopy.diffs = [];
      for (var y = 0; y < patch.diffs.length; y++) {
        patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
      }
      patchCopy.start1 = patch.start1;
      patchCopy.start2 = patch.start2;
      patchCopy.length1 = patch.length1;
      patchCopy.length2 = patch.length2;
      patchesCopy[x] = patchCopy;
    }
    return patchesCopy;
  };

  /**
   * Merge a set of patches onto the text.  Return a patched text, as well
   * as a list of true/false values indicating which patches were applied.
   * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
   * @param {string} text Old text.
   * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
   *      new text and an array of boolean values.
   */
  diff_match_patch.prototype.patch_apply = function (patches, text) {
    if (patches.length == 0) {
      return [text, []];
    }

    // Deep copy the patches so that no changes are made to originals.
    patches = this.patch_deepCopy(patches);
    var nullPadding = this.patch_addPadding(patches);
    text = nullPadding + text + nullPadding;
    this.patch_splitMax(patches);
    // delta keeps track of the offset between the expected and actual location
    // of the previous patch.  If there are patches expected at positions 10 and
    // 20, but the first patch was found at 12, delta is 2 and the second patch
    // has an effective expected position of 22.
    var delta = 0;
    var results = [];
    for (var x = 0; x < patches.length; x++) {
      var expected_loc = patches[x].start2 + delta;
      var text1 = this.diff_text1(patches[x].diffs);
      var start_loc;
      var end_loc = -1;
      if (text1.length > this.Match_MaxBits) {
        // patch_splitMax will only provide an oversized pattern in the case of
        // a monster delete.
        start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);
        if (start_loc != -1) {
          end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
          if (end_loc == -1 || start_loc >= end_loc) {
            // Can't find valid trailing context.  Drop this patch.
            start_loc = -1;
          }
        }
      } else {
        start_loc = this.match_main(text, text1, expected_loc);
      }
      if (start_loc == -1) {
        // No match found.  :(
        results[x] = false;
        // Subtract the delta for this failed patch from subsequent patches.
        delta -= patches[x].length2 - patches[x].length1;
      } else {
        // Found a match.  :)
        results[x] = true;
        delta = start_loc - expected_loc;
        var text2;
        if (end_loc == -1) {
          text2 = text.substring(start_loc, start_loc + text1.length);
        } else {
          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
        }
        if (text1 == text2) {
          // Perfect match, just shove the replacement text in.
          text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);
        } else {
          // Imperfect match.  Run a diff to get a framework of equivalent
          // indices.
          var diffs = this.diff_main(text1, text2, false);
          if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
            // The end points match, but the content is unacceptably bad.
            results[x] = false;
          } else {
            this.diff_cleanupSemanticLossless(diffs);
            var index1 = 0;
            var index2;
            for (var y = 0; y < patches[x].diffs.length; y++) {
              var mod = patches[x].diffs[y];
              if (mod[0] !== DIFF_EQUAL) {
                index2 = this.diff_xIndex(diffs, index1);
              }
              if (mod[0] === DIFF_INSERT) {
                // Insertion
                text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
              } else if (mod[0] === DIFF_DELETE) {
                // Deletion
                text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));
              }
              if (mod[0] !== DIFF_DELETE) {
                index1 += mod[1].length;
              }
            }
          }
        }
      }
    }
    // Strip the padding off.
    text = text.substring(nullPadding.length, text.length - nullPadding.length);
    return [text, results];
  };

  /**
   * Add some padding on text start and end so that edges can match something.
   * Intended to be called only from within patch_apply.
   * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
   * @return {string} The padding string added to each side.
   */
  diff_match_patch.prototype.patch_addPadding = function (patches) {
    var paddingLength = this.Patch_Margin;
    var nullPadding = '';
    for (var x = 1; x <= paddingLength; x++) {
      nullPadding += String.fromCharCode(x);
    }

    // Bump all the patches forward.
    for (var x = 0; x < patches.length; x++) {
      patches[x].start1 += paddingLength;
      patches[x].start2 += paddingLength;
    }

    // Add some padding on start of first diff.
    var patch = patches[0];
    var diffs = patch.diffs;
    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
      // Add nullPadding equality.
      diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
      patch.start1 -= paddingLength; // Should be 0.
      patch.start2 -= paddingLength; // Should be 0.
      patch.length1 += paddingLength;
      patch.length2 += paddingLength;
    } else if (paddingLength > diffs[0][1].length) {
      // Grow first equality.
      var extraLength = paddingLength - diffs[0][1].length;
      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
      patch.start1 -= extraLength;
      patch.start2 -= extraLength;
      patch.length1 += extraLength;
      patch.length2 += extraLength;
    }

    // Add some padding on end of last diff.
    patch = patches[patches.length - 1];
    diffs = patch.diffs;
    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
      // Add nullPadding equality.
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
      patch.length1 += paddingLength;
      patch.length2 += paddingLength;
    } else if (paddingLength > diffs[diffs.length - 1][1].length) {
      // Grow last equality.
      var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
      patch.length1 += extraLength;
      patch.length2 += extraLength;
    }
    return nullPadding;
  };

  /**
   * Look through the patches and break up any which are longer than the maximum
   * limit of the match algorithm.
   * Intended to be called only from within patch_apply.
   * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
   */
  diff_match_patch.prototype.patch_splitMax = function (patches) {
    var patch_size = this.Match_MaxBits;
    for (var x = 0; x < patches.length; x++) {
      if (patches[x].length1 <= patch_size) {
        continue;
      }
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x--, 1);
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new diff_match_patch.patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
        }
        while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
            // This is a large deletion.  Let it pass in one chunk.
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
            bigpatch.diffs.shift();
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext = precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
          }
        }
        if (!empty) {
          patches.splice(++x, 0, patch);
        }
      }
    }
  };

  /**
   * Take a list of patches and return a textual representation.
   * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
   * @return {string} Text representation of patches.
   */
  diff_match_patch.prototype.patch_toText = function (patches) {
    var text = [];
    for (var x = 0; x < patches.length; x++) {
      text[x] = patches[x];
    }
    return text.join('');
  };

  /**
   * Parse a textual representation of patches and return a list of Patch objects.
   * @param {string} textline Text representation of patches.
   * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
   * @throws {!Error} If invalid input.
   */
  diff_match_patch.prototype.patch_fromText = function (textline) {
    var patches = [];
    if (!textline) {
      return patches;
    }
    var text = textline.split('\n');
    var textPointer = 0;
    var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
    while (textPointer < text.length) {
      var m = text[textPointer].match(patchHeader);
      if (!m) {
        throw new Error('Invalid patch string: ' + text[textPointer]);
      }
      var patch = new diff_match_patch.patch_obj();
      patches.push(patch);
      patch.start1 = parseInt(m[1], 10);
      if (m[2] === '') {
        patch.start1--;
        patch.length1 = 1;
      } else if (m[2] == '0') {
        patch.length1 = 0;
      } else {
        patch.start1--;
        patch.length1 = parseInt(m[2], 10);
      }
      patch.start2 = parseInt(m[3], 10);
      if (m[4] === '') {
        patch.start2--;
        patch.length2 = 1;
      } else if (m[4] == '0') {
        patch.length2 = 0;
      } else {
        patch.start2--;
        patch.length2 = parseInt(m[4], 10);
      }
      textPointer++;
      while (textPointer < text.length) {
        var sign = text[textPointer].charAt(0);
        try {
          var line = decodeURI(text[textPointer].substring(1));
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in patch_fromText: ' + line);
        }
        if (sign == '-') {
          // Deletion.
          patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
        } else if (sign == '+') {
          // Insertion.
          patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
        } else if (sign == ' ') {
          // Minor equality.
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
        } else if (sign == '@') {
          // Start of next patch.
          break;
        } else if (sign === '') ;else {
          // WTF?
          throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
        }
        textPointer++;
      }
    }
    return patches;
  };

  /**
   * Class representing one patch operation.
   * @constructor
   */
  diff_match_patch.patch_obj = function () {
    /** @type {!Array.<!diff_match_patch.Diff>} */
    this.diffs = [];
    /** @type {?number} */
    this.start1 = null;
    /** @type {?number} */
    this.start2 = null;
    /** @type {number} */
    this.length1 = 0;
    /** @type {number} */
    this.length2 = 0;
  };

  /**
   * Emulate GNU diff's format.
   * Header: @@ -382,8 +481,9 @@
   * Indices are printed as 1-based, not 0-based.
   * @return {string} The GNU diff string.
   */
  diff_match_patch.patch_obj.prototype.toString = function () {
    var coords1, coords2;
    if (this.length1 === 0) {
      coords1 = this.start1 + ',0';
    } else if (this.length1 == 1) {
      coords1 = this.start1 + 1;
    } else {
      coords1 = this.start1 + 1 + ',' + this.length1;
    }
    if (this.length2 === 0) {
      coords2 = this.start2 + ',0';
    } else if (this.length2 == 1) {
      coords2 = this.start2 + 1;
    } else {
      coords2 = this.start2 + 1 + ',' + this.length2;
    }
    var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
    var op;
    // Escape the body of the patch with %xx notation.
    for (var x = 0; x < this.diffs.length; x++) {
      switch (this.diffs[x][0]) {
        case DIFF_INSERT:
          op = '+';
          break;
        case DIFF_DELETE:
          op = '-';
          break;
        case DIFF_EQUAL:
          op = ' ';
          break;
      }
      text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
    }
    return text.join('').replace(/%20/g, ' ');
  };

  // The following export code was added by @ForbesLindesay
  module.exports = diff_match_patch;
  module.exports['diff_match_patch'] = diff_match_patch;
  module.exports['DIFF_DELETE'] = DIFF_DELETE;
  module.exports['DIFF_INSERT'] = DIFF_INSERT;
  module.exports['DIFF_EQUAL'] = DIFF_EQUAL;
})(diffMatchPatch$1);
var diffMatchPatchExports = diffMatchPatch$1.exports;
function setIfMissing(value) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    type: "setIfMissing",
    path,
    value
  };
}
const dmp$3 = new diffMatchPatchExports.diff_match_patch();
function diffMatchPatch(currentValue, nextValue) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const patch = dmp$3.patch_make(currentValue, nextValue).map(_patch => _patch.toString()).join("");
  return {
    type: "diffMatchPatch",
    path,
    value: patch
  };
}
function insert$1(items, position) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return {
    type: "insert",
    path,
    position,
    items
  };
}
function set(value) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    type: "set",
    path,
    value
  };
}
function unset() {
  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    type: "unset",
    path
  };
}
const EMPTY_MARKDEFS = [];
function keepObjectEquality(object, keyMap) {
  const value = keyMap[object._key];
  if (value && isEqual__default.default(object, value)) {
    return value;
  }
  keyMap[object._key] = object;
  return object;
}
function toSlateValue(value, _ref) {
  let {
    schemaTypes
  } = _ref;
  let keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (value && Array.isArray(value)) {
    return value.map(block => {
      const {
        _type,
        _key,
        ...rest
      } = block;
      const voidChildren = [{
        _key: "".concat(_key, "-void-child"),
        _type: "span",
        text: "",
        marks: []
      }];
      const isPortableText = block && block._type === schemaTypes.block.name;
      if (isPortableText) {
        const textBlock = block;
        let hasInlines = false;
        const hasMissingStyle = typeof textBlock.style === "undefined";
        const hasMissingMarkDefs = typeof textBlock.markDefs === "undefined";
        const children = textBlock.children.map(child => {
          const {
            _type: cType,
            _key: cKey,
            ...cRest
          } = child;
          if (cType !== "span") {
            hasInlines = true;
            return keepObjectEquality({
              _type: cType,
              _key: cKey,
              children: voidChildren,
              value: cRest,
              __inline: true
            }, keyMap);
          }
          return child;
        });
        if (!hasMissingStyle && !hasMissingMarkDefs && !hasInlines && slate.Element.isElement(block)) {
          return block;
        }
        if (hasMissingStyle) {
          rest.style = schemaTypes.styles[0].value;
        }
        if (hasMissingMarkDefs) {
          rest.markDefs = EMPTY_MARKDEFS;
        }
        return keepObjectEquality({
          _type,
          _key,
          ...rest,
          children
        }, keyMap);
      }
      return keepObjectEquality({
        _type,
        _key,
        children: voidChildren,
        value: rest
      }, keyMap);
    });
  }
  return [];
}
function fromSlateValue(value, textBlockType) {
  let keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return value.map(block => {
    const {
      _key,
      _type
    } = block;
    if (!_key || !_type) {
      throw new Error("Not a valid block");
    }
    if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
      let hasInlines = false;
      const children = block.children.map(child => {
        const {
          _type: _cType
        } = child;
        if ("value" in child && _cType !== "span") {
          hasInlines = true;
          const {
            value: v,
            _key: k,
            _type: t,
            __inline: _i,
            children: _c,
            ...rest
          } = child;
          return keepObjectEquality({
            ...rest,
            ...v,
            _key: k,
            _type: t
          }, keyMap);
        }
        return child;
      });
      if (!hasInlines) {
        return block;
      }
      return keepObjectEquality({
        ...block,
        children,
        _key,
        _type
      }, keyMap);
    }
    const blockValue = "value" in block && block.value;
    return keepObjectEquality({
      _key,
      _type,
      ...(typeof blockValue === "object" ? blockValue : {})
    }, keyMap);
  });
}
function isEqualToEmptyEditor(children, schemaTypes) {
  var _a;
  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && "style" in children[0] && children[0].style === schemaTypes.styles[0].value && !("listItem" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate.Text.isText(children[0].children[0]) && children[0].children[0]._type === "span" && !((_a = children[0].children[0].marks) == null ? void 0 : _a.join("")) && children[0].children[0].text === "";
}
const debug$k = debugWithName("operationToPatches");
function createOperationToPatches(types) {
  const textBlockName = types.block.name;
  function insertTextPatch(editor, operation, beforeValue) {
    debug$k("Operation", JSON.stringify(operation, null, 2));
    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
    if (!block) {
      throw new Error("Could not find block");
    }
    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];
    if (!textChild) {
      throw new Error("Could not find child");
    }
    const path = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"];
    const prevBlock = beforeValue[operation.path[0]];
    const prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]];
    const prevText = editor.isTextSpan(prevChild) ? prevChild.text : "";
    const patch = diffMatchPatch(prevText, textChild.text, path);
    return patch.value.length ? [patch] : [];
  }
  function removeTextPatch(editor, operation, beforeValue) {
    const block = editor && editor.children[operation.path[0]];
    if (!block) {
      throw new Error("Could not find block");
    }
    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0;
    const textChild = editor.isTextSpan(child) ? child : void 0;
    if (child && !textChild) {
      throw new Error("Expected span");
    }
    if (!textChild) {
      throw new Error("Could not find child");
    }
    const path = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"];
    const beforeBlock = beforeValue[operation.path[0]];
    const prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]];
    const prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text;
    const patch = diffMatchPatch(prevText || "", textChild.text, path);
    return patch.value ? [patch] : [];
  }
  function setNodePatch(editor, operation) {
    if (operation.path.length === 1) {
      const block = editor.children[operation.path[0]];
      if (typeof block._key !== "string") {
        throw new Error("Expected block to have a _key");
      }
      const setNode = omitBy__default.default({
        ...editor.children[operation.path[0]],
        ...operation.newProperties
      }, isUndefined__default.default);
      return [set(fromSlateValue([setNode], textBlockName)[0], [{
        _key: block._key
      }])];
    } else if (operation.path.length === 2) {
      const block = editor.children[operation.path[0]];
      if (editor.isTextBlock(block)) {
        const child = block.children[operation.path[1]];
        if (child) {
          const blockKey = block._key;
          const childKey = child._key;
          const patches = [];
          Object.keys(operation.newProperties).forEach(keyName => {
            const val = get__default.default(operation.newProperties, keyName);
            patches.push(set(val, [{
              _key: blockKey
            }, "children", {
              _key: childKey
            }, keyName]));
          });
          return patches;
        }
        throw new Error("Could not find a valid child");
      }
      throw new Error("Could not find a valid block");
    } else {
      throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
    }
  }
  function insertNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    const isTextBlock = editor.isTextBlock(block);
    if (operation.path.length === 1) {
      const position = operation.path[0] === 0 ? "before" : "after";
      const beforeBlock = beforeValue[operation.path[0] - 1];
      const targetKey = operation.path[0] === 0 ? block == null ? void 0 : block._key : beforeBlock == null ? void 0 : beforeBlock._key;
      if (targetKey) {
        return [insert$1([fromSlateValue([operation.node], textBlockName)[0]], position, [{
          _key: targetKey
        }])];
      }
      return [setIfMissing(beforeValue, []), insert$1([fromSlateValue([operation.node], textBlockName)[0]], "before", [operation.path[0]])];
    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {
      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after";
      const blk = fromSlateValue([{
        _key: "bogus",
        _type: textBlockName,
        children: [operation.node]
      }], textBlockName)[0];
      const child = blk.children[0];
      return [insert$1([child], position, [{
        _key: block._key
      }, "children", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {
        _key: block.children[operation.path[1] - 1]._key
      }])];
    }
    debug$k("Something was inserted into a void block. Not producing editor patches.");
    return [];
  }
  function splitNodePatch(editor, operation, beforeValue) {
    const patches = [];
    const splitBlock = editor.children[operation.path[0]];
    if (!editor.isTextBlock(splitBlock)) {
      throw new Error("Block with path ".concat(JSON.stringify(operation.path[0]), " is not a text block and can't be split"));
    }
    if (operation.path.length === 1) {
      const oldBlock = beforeValue[operation.path[0]];
      if (editor.isTextBlock(oldBlock)) {
        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];
        if (targetValue) {
          patches.push(insert$1([targetValue], "after", [{
            _key: splitBlock._key
          }]));
          const spansToUnset = oldBlock.children.slice(operation.position);
          spansToUnset.forEach(span => {
            const path = [{
              _key: oldBlock._key
            }, "children", {
              _key: span._key
            }];
            patches.push(unset(path));
          });
        }
      }
      return patches;
    }
    if (operation.path.length === 2) {
      const splitSpan = splitBlock.children[operation.path[1]];
      if (editor.isTextSpan(splitSpan)) {
        const targetSpans = fromSlateValue([{
          ...splitBlock,
          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
        }], textBlockName)[0].children;
        patches.push(insert$1(targetSpans, "after", [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }]));
        patches.push(set(splitSpan.text, [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }, "text"]));
      }
      return patches;
    }
    return patches;
  }
  function removeNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
      if (block && block._key) {
        return [unset([{
          _key: block._key
        }])];
      }
      throw new Error("Block not found");
    } else if (editor.isTextBlock(block) && operation.path.length === 2) {
      const spanToRemove = editor.isTextBlock(block) && block.children && block.children[operation.path[1]];
      if (spanToRemove) {
        return [unset([{
          _key: block._key
        }, "children", {
          _key: spanToRemove._key
        }])];
      }
      debug$k("Span not found in editor trying to remove node");
      return [];
    } else {
      debug$k("Not creating patch inside object block");
      return [];
    }
  }
  function mergeNodePatch(editor, operation, beforeValue) {
    const patches = [];
    const block = beforeValue[operation.path[0]];
    const targetBlock = editor.children[operation.path[0]];
    if (operation.path.length === 1) {
      if (block == null ? void 0 : block._key) {
        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
        patches.push(set(newBlock, [{
          _key: newBlock._key
        }]));
        patches.push(unset([{
          _key: block._key
        }]));
      } else {
        throw new Error("Target key not found!");
      }
    } else if (operation.path.length === 2 && editor.isTextBlock(targetBlock)) {
      const mergedSpan = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0;
      const targetSpan = targetBlock.children[operation.path[1] - 1];
      if (editor.isTextSpan(targetSpan)) {
        patches.push(set(targetSpan.text, [{
          _key: block._key
        }, "children", {
          _key: targetSpan._key
        }, "text"]));
        if (mergedSpan) {
          patches.push(unset([{
            _key: block._key
          }, "children", {
            _key: mergedSpan._key
          }]));
        }
      }
    } else {
      debug$k("Void nodes can't be merged, not creating any patches");
    }
    return patches;
  }
  function moveNodePatch(editor, operation, beforeValue) {
    const patches = [];
    const block = beforeValue[operation.path[0]];
    const targetBlock = beforeValue[operation.newPath[0]];
    if (operation.path.length === 1) {
      const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
      patches.push(unset([{
        _key: block._key
      }]));
      patches.push(insert$1([fromSlateValue([block], textBlockName)[0]], position, [{
        _key: targetBlock._key
      }]));
    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {
      const child = block.children[operation.path[1]];
      const targetChild = targetBlock.children[operation.newPath[1]];
      const position = operation.newPath[1] === targetBlock.children.length ? "after" : "before";
      const childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
      patches.push(unset([{
        _key: block._key
      }, "children", {
        _key: child._key
      }]));
      patches.push(insert$1([childToInsert], position, [{
        _key: targetBlock._key
      }, "children", {
        _key: targetChild._key
      }]));
    }
    return patches;
  }
  return {
    insertNodePatch,
    insertTextPatch,
    mergeNodePatch,
    moveNodePatch,
    removeNodePatch,
    removeTextPatch,
    setNodePatch,
    splitNodePatch
  };
}
function createKeyedPath(point, value, types) {
  const blockPath = [point.path[0]];
  if (!value) {
    return null;
  }
  const block = value[blockPath[0]];
  if (!block) {
    return null;
  }
  const keyedBlockPath = [{
    _key: block._key
  }];
  if (block._type !== types.block.name) {
    return keyedBlockPath;
  }
  let keyedChildPath;
  const childPath = point.path.slice(0, 2);
  const child = Array.isArray(block.children) && block.children[childPath[1]];
  if (child) {
    keyedChildPath = ["children", {
      _key: child._key
    }];
  }
  return keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;
}
function createArrayedPath(point, editor) {
  if (!editor) {
    return [];
  }
  const [block, blockPath] = Array.from(slate.Editor.nodes(editor, {
    at: [],
    match: n => types.isKeySegment(point.path[0]) && n._key === point.path[0]._key
  }))[0] || [void 0, void 0];
  if (!block || !slate.Element.isElement(block)) {
    return [];
  }
  if (editor.isVoid(block)) {
    return blockPath;
  }
  const childPath = [point.path[2]];
  const childIndex = block.children.findIndex(child => isEqual__default.default([{
    _key: child._key
  }], childPath));
  if (childIndex >= 0 && block.children[childIndex]) {
    const child = block.children[childIndex];
    if (slate.Element.isElement(child) && editor.isVoid(child)) {
      return blockPath.concat(childIndex).concat(0);
    }
    return blockPath.concat(childIndex);
  }
  return blockPath;
}
function toPortableTextRange(value, range, types) {
  if (!range) {
    return null;
  }
  let anchor = null;
  let focus = null;
  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);
  if (anchorPath && range.anchor) {
    anchor = {
      path: anchorPath,
      offset: range.anchor.offset
    };
  }
  const focusPath = range.focus && createKeyedPath(range.focus, value, types);
  if (focusPath && range.focus) {
    focus = {
      path: focusPath,
      offset: range.focus.offset
    };
  }
  return anchor && focus ? {
    anchor,
    focus
  } : null;
}
function toSlateRange(selection, editor) {
  if (!selection || !editor) {
    return null;
  }
  const anchor = {
    path: createArrayedPath(selection.anchor, editor),
    offset: selection.anchor.offset
  };
  const focus = {
    path: createArrayedPath(selection.focus, editor),
    offset: selection.focus.offset
  };
  const range = anchor && focus ? {
    anchor,
    focus
  } : null;
  return range;
}
const debug$j = debugWithName("API:editable");
function createWithEditableAPI(portableTextEditor, types, keyGenerator) {
  return function withEditableAPI(editor) {
    portableTextEditor.setEditable({
      focus: () => {
        if (!editor.selection) {
          const point = {
            path: [0, 0],
            offset: 0
          };
          slate.Transforms.select(editor, {
            focus: point,
            anchor: point
          });
          editor.onChange();
        }
        slateReact.ReactEditor.focus(editor);
      },
      blur: () => {
        slateReact.ReactEditor.blur(editor);
      },
      toggleMark: mark => {
        editor.pteToggleMark(mark);
      },
      toggleList: listStyle => {
        editor.pteToggleListItem(listStyle);
      },
      toggleBlockStyle: blockStyle => {
        editor.pteToggleBlockStyle(blockStyle);
      },
      isMarkActive: mark => {
        try {
          return editor.pteIsMarkActive(mark);
        } catch (err) {
          console.warn(err);
          return false;
        }
      },
      marks: () => {
        return {
          ...(slate.Editor.marks(editor) || {})
        }.marks || [];
      },
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      select: selection => {
        const slateSelection = toSlateRange(selection, editor);
        if (slateSelection) {
          slate.Transforms.select(editor, slateSelection);
        } else {
          slate.Transforms.deselect(editor);
        }
        editor.onChange();
      },
      focusBlock: () => {
        if (editor.selection) {
          try {
            const [block] = Array.from(slate.Editor.nodes(editor, {
              at: editor.selection.focus,
              match: n => slate.Editor.isBlock(editor, n)
            }))[0] || [void 0];
            if (block) {
              return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
            }
          } catch (err) {
            return void 0;
          }
        }
        return void 0;
      },
      focusChild: () => {
        if (editor.selection) {
          try {
            const [node] = Array.from(slate.Editor.nodes(editor, {
              mode: "lowest",
              at: editor.selection.focus,
              match: n => n._type !== void 0,
              voids: true
            }))[0] || [void 0];
            if (node && !slate.Editor.isBlock(editor, node)) {
              const pseudoBlock = {
                _key: "pseudo",
                _type: types.block.name,
                children: [node]
              };
              const blocks = fromSlateValue([pseudoBlock], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
              if (editor.isTextBlock(blocks[0])) {
                return blocks[0].children[0];
              }
            }
          } catch (err) {
            return void 0;
          }
        }
        return void 0;
      },
      insertChild: (type, value) => {
        var _a;
        if (!editor.selection) {
          throw new Error("The editor has no selection");
        }
        const [focusBlock] = Array.from(slate.Editor.nodes(editor, {
          at: editor.selection.focus,
          match: n => slate.Editor.isBlock(editor, n)
        }))[0] || [void 0];
        if (!focusBlock) {
          throw new Error("No focus block");
        }
        if (focusBlock && slate.Editor.isVoid(editor, focusBlock)) {
          throw new Error("Can't insert childs into block objects");
        }
        const block = toSlateValue([{
          _key: keyGenerator(),
          _type: types.block.name,
          children: [{
            _key: keyGenerator(),
            _type: type.name,
            ...(value ? value : {})
          }]
        }], portableTextEditor)[0];
        const child = block.children[0];
        slate.Editor.insertNode(editor, child);
        editor.onChange();
        return ((_a = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)) == null ? void 0 : _a.focus.path) || [];
      },
      insertBlock: (type, value) => {
        var _a;
        if (!editor.selection) {
          throw new Error("The editor has no selection");
        }
        const block = toSlateValue([{
          _key: keyGenerator(),
          _type: type.name,
          ...(value ? value : {})
        }], portableTextEditor)[0];
        slate.Editor.insertNode(editor, block);
        editor.onChange();
        return ((_a = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)) == null ? void 0 : _a.focus.path) || [];
      },
      hasBlockStyle: style => {
        try {
          return editor.pteHasBlockStyle(style);
        } catch (err) {
          return false;
        }
      },
      hasListStyle: listStyle => {
        try {
          return editor.pteHasListStyle(listStyle);
        } catch (err) {
          return false;
        }
      },
      isVoid: element => {
        return ![types.block.name, types.span.name].includes(element._type);
      },
      findByPath: path => {
        const slatePath = toSlateRange({
          focus: {
            path,
            offset: 0
          },
          anchor: {
            path,
            offset: 0
          }
        }, editor);
        if (slatePath) {
          const [block, blockPath] = slate.Editor.node(editor, slatePath.focus.path.slice(0, 1));
          if (block && blockPath && typeof block._key === "string") {
            if (path.length === 1 && slatePath.focus.path.length === 1) {
              return [fromSlateValue([block], types.block.name)[0], [{
                _key: block._key
              }]];
            }
            const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
            if (editor.isTextBlock(ptBlock)) {
              const ptChild = ptBlock.children[slatePath.focus.path[1]];
              if (ptChild) {
                return [ptChild, [{
                  _key: block._key
                }, "children", {
                  _key: ptChild._key
                }]];
              }
            }
          }
        }
        return [void 0, void 0];
      },
      findDOMNode: element => {
        let node;
        try {
          const [item] = Array.from(slate.Editor.nodes(editor, {
            at: [],
            match: n => n._key === element._key
          }) || [])[0] || [void 0];
          node = slateReact.ReactEditor.toDOMNode(editor, item);
        } catch (err) {}
        return node;
      },
      activeAnnotations: () => {
        var _a;
        if (!editor.selection || editor.selection.focus.path.length < 2) {
          return [];
        }
        try {
          const activeAnnotations = [];
          const spans = slate.Editor.nodes(editor, {
            at: editor.selection,
            match: node => slate.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
          });
          for (const [span, path] of spans) {
            const [block] = slate.Editor.node(editor, path, {
              depth: 1
            });
            if (editor.isTextBlock(block)) {
              (_a = block.markDefs) == null ? void 0 : _a.forEach(def => {
                if (slate.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                  activeAnnotations.push(def);
                }
              });
            }
          }
          return activeAnnotations;
        } catch (err) {
          return [];
        }
      },
      addAnnotation: (type, value) => {
        const {
          selection
        } = editor;
        if (selection) {
          const [block] = slate.Editor.node(editor, selection.focus, {
            depth: 1
          });
          if (slate.Element.isElement(block) && block._type === types.block.name) {
            const annotationKey = keyGenerator();
            if (editor.isTextBlock(block)) {
              slate.Transforms.setNodes(editor, {
                markDefs: [...(block.markDefs || []), {
                  _type: type.name,
                  _key: annotationKey,
                  ...value
                }]
              }, {
                at: selection.focus
              });
              editor.onChange();
              if (slate.Range.isCollapsed(selection)) {
                editor.pteExpandToWord();
                editor.onChange();
              }
              const [textNode] = slate.Editor.node(editor, selection.focus, {
                depth: 2
              });
              if (editor.selection) {
                slate.Editor.withoutNormalizing(editor, () => {
                  slate.Transforms.setNodes(editor, {}, {
                    match: slate.Text.isText,
                    split: true
                  });
                  if (editor.selection && slate.Text.isText(textNode)) {
                    slate.Transforms.setNodes(editor, {
                      marks: [...(textNode.marks || []), annotationKey]
                    }, {
                      at: editor.selection,
                      match: n => n._type === types.span.name
                    });
                    editor.onChange();
                  }
                });
                slate.Editor.normalize(editor);
                editor.onChange();
                const newSelection = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types);
                if (newSelection && typeof block._key === "string") {
                  slate.Editor.withoutNormalizing(editor, () => {
                    if (editor.selection) {
                      slate.Transforms.insertNodes(editor, [{
                        _type: "span",
                        text: "",
                        marks: [],
                        _key: keyGenerator()
                      }], {
                        at: slate.Range.end(editor.selection)
                      });
                      editor.onChange();
                    }
                  });
                  return {
                    spanPath: newSelection.focus.path,
                    markDefPath: [{
                      _key: block._key
                    }, "markDefs", {
                      _key: annotationKey
                    }]
                  };
                }
              }
            }
          }
        }
        return void 0;
      },
      delete: (selection, options) => {
        if (selection) {
          const range = toSlateRange(selection, editor);
          if (range) {
            if (!(options == null ? void 0 : options.mode) || (options == null ? void 0 : options.mode) === "selected") {
              debug$j("Deleting content in selection");
              slate.Transforms.delete(editor, {
                at: range,
                hanging: true,
                voids: true
              });
              editor.onChange();
              return;
            }
            if ((options == null ? void 0 : options.mode) === "blocks") {
              debug$j("Deleting blocks touched by selection");
            } else {
              debug$j("Deleting children touched by selection");
            }
            const nodes = slate.Editor.nodes(editor, {
              at: range,
              match: node => {
                if ((options == null ? void 0 : options.mode) === "blocks") {
                  return editor.isTextBlock(node) || !editor.isTextBlock(node) && slate.Element.isElement(node);
                }
                return node._type === types.span.name ||
                // Text children
                !editor.isTextBlock(node) && slate.Element.isElement(node);
              }
            });
            const nodeAndPaths = [...nodes];
            nodeAndPaths.forEach(_ref2 => {
              let [, p] = _ref2;
              slate.Transforms.removeNodes(editor, {
                at: p,
                voids: true,
                hanging: true
              });
            });
            editor.onChange();
          }
        }
      },
      removeAnnotation: type => {
        let {
          selection
        } = editor;
        debug$j("Removing annotation", type);
        if (selection) {
          if (slate.Range.isCollapsed(selection)) {
            const [node, nodePath] = slate.Editor.node(editor, selection, {
              depth: 2
            });
            if (slate.Text.isText(node) && node.marks && typeof node.text === "string") {
              slate.Transforms.select(editor, nodePath);
              selection = editor.selection;
            }
          }
          slate.Editor.withoutNormalizing(editor, () => {
            if (selection && slate.Range.isExpanded(selection)) {
              selection = editor.selection;
              if (!selection) {
                return;
              }
              slate.Transforms.setNodes(editor, {}, {
                match: slate.Text.isText,
                split: true
              });
              editor.onChange();
              const spans = [...slate.Editor.nodes(editor, {
                at: selection,
                match: node => slate.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
              })];
              spans.forEach(_ref3 => {
                let [span, path] = _ref3;
                var _a;
                const [block] = slate.Editor.node(editor, path, {
                  depth: 1
                });
                if (editor.isTextBlock(block)) {
                  (_a = block.markDefs) == null ? void 0 : _a.filter(def => def._type === type.name).forEach(def => {
                    if (slate.Text.isText(span) && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                      const newMarks = [...(span.marks || []).filter(mark => mark !== def._key)];
                      slate.Transforms.setNodes(editor, {
                        marks: newMarks
                      }, {
                        at: path,
                        voids: false,
                        split: false
                      });
                    }
                  });
                }
              });
            }
          });
          slate.Editor.normalize(editor);
          editor.onChange();
        }
      },
      getSelection: () => {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          if (existing) {
            return existing;
          }
          ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types);
          SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
        }
        return ptRange;
      },
      getValue: () => {
        return fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
      },
      isCollapsedSelection: () => {
        return !!editor.selection && slate.Range.isCollapsed(editor.selection);
      },
      isExpandedSelection: () => {
        return !!editor.selection && slate.Range.isExpanded(editor.selection);
      },
      insertBreak: () => {
        editor.insertBreak();
        editor.onChange();
      }
    });
    return editor;
  };
}
function createWithMaxBlocks(maxBlocks) {
  return function withMaxBlocks(editor) {
    const {
      apply
    } = editor;
    editor.apply = operation => {
      const rows = maxBlocks;
      if (rows > 0 && editor.children.length >= rows) {
        if ((operation.type === "insert_node" || operation.type === "split_node") && operation.path.length === 1) {
          return;
        }
      }
      apply(operation);
    };
    return editor;
  };
}
const PRESERVE_KEYS = /* @__PURE__ */new WeakMap();
function withPreserveKeys(editor, fn) {
  PRESERVE_KEYS.set(editor, true);
  fn();
  PRESERVE_KEYS.set(editor, false);
}
function isPreservingKeys(editor) {
  return PRESERVE_KEYS.get(editor);
}
function createWithObjectKeys(schemaTypes, keyGenerator) {
  return function withKeys(editor) {
    PRESERVE_KEYS.set(editor, false);
    const {
      apply,
      normalizeNode
    } = editor;
    editor.apply = operation => {
      if (operation.type === "split_node") {
        operation.properties = {
          ...operation.properties,
          _key: keyGenerator()
        };
      }
      if (operation.type === "insert_node") {
        const withNewKey = !isPreservingKeys(editor) || !("_key" in operation.node);
        if (!slate.Editor.isEditor(operation.node)) {
          operation.node = {
            ...operation.node,
            ...(withNewKey ? {
              _key: keyGenerator()
            } : {})
          };
        }
      }
      apply(operation);
    };
    editor.normalizeNode = entry => {
      const [node, path] = entry;
      if (slate.Element.isElement(node) && node._type === schemaTypes.block.name) {
        if (!node._key) {
          slate.Transforms.setNodes(editor, {
            _key: keyGenerator()
          }, {
            at: path
          });
        }
        for (const [child, childPath] of slate.Node.children(editor, path)) {
          if (!child._key) {
            slate.Transforms.setNodes(editor, {
              _key: keyGenerator()
            }, {
              at: childPath
            });
            return;
          }
        }
      }
      normalizeNode(entry);
    };
    return editor;
  };
}
const PATCHING = /* @__PURE__ */new WeakMap();
function withoutPatching(editor, fn) {
  const prev = isPatching(editor);
  PATCHING.set(editor, false);
  fn();
  PATCHING.set(editor, prev);
}
function isPatching(editor) {
  return PATCHING.get(editor);
}
const BEFORE = "before";
const AFTER = "after";
function insert(array, position, index) {
  if (position !== BEFORE && position !== AFTER) {
    throw new Error("Invalid position \"".concat(position, "\", must be either ").concat(BEFORE, " or ").concat(AFTER));
  }
  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key2 = 3; _key2 < _len; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }
  const items = flatten(...args);
  if (array.length === 0) {
    return items;
  }
  const len = array.length;
  const idx = Math.abs((len + index) % len) % len;
  const normalizedIdx = position === "after" ? idx + 1 : idx;
  const copy = array.slice();
  copy.splice(normalizedIdx, 0, ...flatten(items));
  return copy;
}
function flatten() {
  for (var _len2 = arguments.length, values = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
    values[_key3] = arguments[_key3];
  }
  return values.reduce((prev, item) => prev.concat(item), []);
}
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function move(arr, from, to) {
  const nextValue = arr.slice();
  const val = nextValue[from];
  nextValue.splice(from, 1);
  nextValue.splice(to, 0, val);
  return nextValue;
}
function findTargetIndex(array, pathSegment) {
  if (typeof pathSegment === "number") {
    return pathSegment;
  }
  const index = findIndex__default.default(array, pathSegment);
  return index === -1 ? false : index;
}
function apply$3(value, patch) {
  const nextValue = value.slice();
  if (patch.path.length === 0) {
    if (patch.type === "setIfMissing") {
      if (!Array.isArray(patch.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return value === void 0 ? patch.value : value;
    } else if (patch.type === "set") {
      if (!Array.isArray(patch.value)) {
        throw new Error("Cannot set value of an array to a non-array");
      }
      return patch.value;
    } else if (patch.type === "unset") {
      return void 0;
    } else if (patch.type === "move") {
      if (!patch.value || !hasOwn(patch.value, "from") || !hasOwn(patch.value, "to")) {
        throw new Error("Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ".concat(JSON.stringify(patch.value)));
      }
      return move(nextValue, patch.value.from, patch.value.to);
    }
    throw new Error("Invalid array operation: ".concat(patch.type));
  }
  const [head, ...tail] = patch.path;
  const index = findTargetIndex(value, head);
  if (index === false) {
    return nextValue;
  }
  if (tail.length === 0) {
    if (patch.type === "insert") {
      const {
        position,
        items
      } = patch;
      return insert(value, position, index, items);
    } else if (patch.type === "unset") {
      if (typeof index !== "number") {
        throw new Error("Expected array index to be a number, instead got \"".concat(index, "\""));
      }
      nextValue.splice(index, 1);
      return nextValue;
    }
  }
  nextValue[index] = _apply(nextValue[index], {
    ...patch,
    path: tail
  });
  return nextValue;
}
function apply$2(value, patch) {
  const nextValue = clone__default.default(value);
  if (patch.path.length === 0) {
    if (patch.type === "set") {
      if (!isObject__default.default(patch.value)) {
        throw new Error("Cannot set value of an object to a non-object");
      }
      return patch.value;
    } else if (patch.type === "unset") {
      return void 0;
    } else if (patch.type === "setIfMissing") {
      return value === void 0 ? patch.value : value;
    }
    throw new Error("Invalid object operation: ".concat(patch.type));
  }
  const [head, ...tail] = patch.path;
  if (typeof head !== "string") {
    throw new Error("Expected field name to be a string, instad got: ".concat(head));
  }
  if (tail.length === 0 && patch.type === "unset") {
    return omit__default.default(nextValue, head);
  }
  nextValue[head] = _apply(nextValue[head], {
    ...patch,
    path: tail
  });
  return nextValue;
}
const OPERATIONS$1 = {
  replace(_currentValue, nextValue) {
    return nextValue;
  },
  set(_currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(_currentValue, _nextValue) {
    return void 0;
  },
  inc(currentValue, nextValue) {
    return currentValue + nextValue;
  },
  dec(currentValue, nextValue) {
    return currentValue - nextValue;
  }
};
const SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function apply$1(value, patch) {
  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type)) {
    throw new Error("Received patch of unsupported type: \"".concat(JSON.stringify(patch.type), "\" for primitives. This is most likely a bug."));
  }
  if (patch.path.length > 0) {
    throw new Error("Cannot apply deep operations on primitive values. Received patch with type \"".concat(patch.type, "\" and path \"").concat(patch.path.map(path => JSON.stringify(path)).join("."), " that targeted the value \"").concat(JSON.stringify(value), "\""));
  }
  return OPERATIONS$1[patch.type](value, patch.value);
}
const dmp$2 = new diffMatchPatchExports.diff_match_patch();
const OPERATIONS = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
    return void 0;
  },
  diffMatchPatch(currentValue, nextValue) {
    return dmp$2.patch_apply(dmp$2.patch_fromText(nextValue), currentValue)[0];
  }
};
const SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function apply(value, patch) {
  if (!SUPPORTED_PATCH_TYPES.includes(patch.type)) {
    throw new Error("Received patch of unsupported type: \"".concat(JSON.stringify(patch.type), "\" for string. This is most likely a bug."));
  }
  if (patch.path.length > 0) {
    throw new Error("Cannot apply deep operations on string values. Received patch with type \"".concat(patch.type, "\" and path \"").concat(patch.path.join("."), " that targeted the value \"").concat(JSON.stringify(value), "\""));
  }
  const func = OPERATIONS[patch.type];
  if (func) {
    return func(value, patch.value);
  }
  throw new Error("Unknown patch type");
}
function applyAll(value, patches) {
  return patches.reduce(_apply, value);
}
function applyPatch(value, patch) {
  if (Array.isArray(value)) {
    return apply$3(value, patch);
  }
  if (isString__default.default(value)) {
    return apply(value, patch);
  }
  if (isObject__default.default(value)) {
    return apply$2(value, patch);
  }
  return apply$1(value, patch);
}
function _apply(value, patch) {
  const res = applyPatch(value, patch);
  return res;
}
const debug$i = debugWithName("patchToOperations");
const dmp$1 = new diffMatchPatchExports.diff_match_patch();
function createPatchToOperations(schemaTypes) {
  function diffMatchPatch(editor, patch) {
    const blockKey = findLastKey([patch.path[0]]);
    const blockIndex = editor.children.findIndex((node, indx) => {
      return blockKey ? node._key === blockKey : indx === patch.path[0];
    });
    const block = editor.children[blockIndex];
    const parsed = dmp$1.patch_fromText(patch.value)[0];
    const isSpanTextDiffMatchPatch = editor.isTextBlock(block) && patch.path[1] === "children" && patch.path.length === 4 && patch.path[3] === "text";
    if (parsed && isSpanTextDiffMatchPatch) {
      const distance = parsed.length2 - parsed.length1;
      let text;
      if (parsed.diffs[1]) {
        text = parsed.diffs[1][1];
      } else {
        text = parsed.diffs[0][1];
      }
      if (patch.path[1] === "children") {
        const childKey = findLastKey([patch.path[2]]);
        const childIndex = block.children.findIndex((node, indx) => {
          return childKey ? node._key === childKey : indx === patch.path[0];
        });
        const slatePath = [blockIndex];
        if (childIndex > -1) {
          slatePath.push(childIndex);
        }
        const point = {
          path: slatePath,
          offset: distance >= 0 ? (parsed.start1 || 0) + parsed.diffs[0][1].length : (parsed.start2 || 0) + parsed.length2 - distance
        };
        debugState(editor, "before");
        if (distance >= 0) {
          editor.apply({
            type: "insert_text",
            path: point.path,
            offset: point.offset,
            text
          });
        } else {
          editor.apply({
            type: "remove_text",
            path: point.path,
            offset: point.offset - text.length,
            text
          });
        }
      }
      debugState(editor, "after");
      return true;
    }
    return false;
  }
  function insertPatch(editor, patch) {
    if (patch.path.length === 1) {
      const {
        items: items2,
        position: position2
      } = patch;
      const blocksToInsert = toSlateValue(items2, {
        schemaTypes
      }, KEY_TO_SLATE_ELEMENT.get(editor));
      const posKey2 = findLastKey(patch.path);
      const index = Math.max(0, editor.children.findIndex((node, indx) => {
        return posKey2 ? node._key === posKey2 : indx === patch.path[0];
      }));
      const normalizedIdx2 = position2 === "after" ? index + 1 : index;
      debug$i("Inserting blocks at path [".concat(normalizedIdx2, "]"));
      debugState(editor, "before");
      slate.Transforms.insertNodes(editor, blocksToInsert, {
        at: [normalizedIdx2]
      });
      debugState(editor, "after");
      return true;
    }
    const {
      items,
      position
    } = patch;
    const posKey = findLastKey(patch.path);
    const blockIndex = editor.children.findIndex((node, indx) => {
      return posKey ? node._key === posKey : indx === patch.path[0];
    });
    const block = editor.children && blockIndex > -1 ? editor.children[blockIndex] : void 0;
    const childIndex = editor.isTextBlock(block) ? block.children.findIndex((node, indx) => {
      return isKeyedSegment(patch.path[2]) ? node._key === patch.path[2]._key : indx === patch.path[2];
    }) : 0;
    const childrenToInsert = block && toSlateValue([{
      ...block,
      children: items
    }], {
      schemaTypes
    }, KEY_TO_SLATE_ELEMENT.get(editor));
    const normalizedIdx = position === "after" ? childIndex + 1 : childIndex;
    const targetPath = [blockIndex, normalizedIdx];
    debug$i("Inserting children at path ".concat(targetPath));
    debugState(editor, "before");
    if (childrenToInsert && slate.Element.isElement(childrenToInsert[0])) {
      slate.Transforms.insertNodes(editor, childrenToInsert[0].children, {
        at: targetPath
      });
    }
    debugState(editor, "after");
    return true;
  }
  function setPatch(editor, patch) {
    const blockIndex = editor.children.findIndex((node, indx) => {
      return isKeyedSegment(patch.path[0]) ? node._key === patch.path[0]._key : indx === patch.path[0];
    });
    debug$i("blockIndex", blockIndex);
    const block = blockIndex > -1 ? editor.children[blockIndex] : void 0;
    const isTextBlock = editor.isTextBlock(block);
    if (isTextBlock && patch.path.length > 2 && patch.path[1] !== "children") {
      debug$i("Ignoring setting void value");
      return false;
    }
    const childIndex = isTextBlock ? block.children.findIndex((node, indx) => {
      return isKeyedSegment(patch.path[2]) ? node._key === patch.path[2]._key : indx === patch.path[2];
    }) : 0;
    let value = patch.value;
    const targetPath = childIndex > -1 ? [blockIndex, childIndex] : [blockIndex];
    if (typeof patch.path[3] === "string") {
      value = {};
      value[patch.path[3]] = patch.value;
    }
    if (isTextBlock) {
      debug$i("Setting nodes at ".concat(JSON.stringify(patch.path), " - ").concat(JSON.stringify(targetPath)));
      debug$i("Value to set", JSON.stringify(value, null, 2));
      debugState(editor, "before");
      if (targetPath.length === 1) {
        debug$i("Setting block property");
        const {
          children,
          ...nextRest
        } = value;
        const {
          children: prevChildren,
          ...prevRest
        } = block || {
          children: void 0
        };
        editor.apply({
          type: "set_node",
          path: targetPath,
          properties: {
            ...prevRest
          },
          newProperties: nextRest
        });
        if (block && slate.Element.isElement(block)) {
          block.children.forEach((c, cIndex) => {
            editor.apply({
              type: "remove_node",
              path: targetPath.concat(cIndex),
              node: c
            });
          });
        }
        if (Array.isArray(children)) {
          children.forEach((c, cIndex) => {
            editor.apply({
              type: "insert_node",
              path: targetPath.concat(cIndex),
              node: c
            });
          });
        }
      } else if (slate.Text.isText(value)) {
        debug$i("Setting text property");
        const prevSel = editor.selection && {
          ...editor.selection
        };
        editor.apply({
          type: "remove_text",
          path: targetPath,
          offset: 0,
          text: block.children[childIndex].text
        });
        editor.apply({
          type: "insert_text",
          path: targetPath,
          offset: 0,
          text: value.text
        });
        const onSamePath = prevSel && isEqual__default.default(prevSel.focus.path, targetPath);
        if (onSamePath) {
          debug$i("On same path, restoring previous selection");
          slate.Transforms.select(editor, prevSel);
        }
      } else {
        debug$i("Setting non-text property");
        editor.apply({
          type: "set_node",
          path: targetPath,
          properties: {},
          newProperties: value
        });
      }
      debugState(editor, "after");
      return true;
    } else if (block && "value" in block) {
      const newVal = applyAll([block.value], [patch])[0];
      slate.Transforms.setNodes(editor, {
        ...block,
        value: newVal
      }, {
        at: [blockIndex]
      });
      return true;
    }
    return false;
  }
  function unsetPatch(editor, patch, previousPatch2) {
    var _a;
    if (patch.path.length === 0) {
      debug$i("Removing everything");
      debugState(editor, "before");
      const previousSelection = editor.selection;
      slate.Transforms.deselect(editor);
      editor.children.forEach((c, i) => {
        slate.Transforms.removeNodes(editor, {
          at: [i]
        });
      });
      slate.Transforms.insertNodes(editor, editor.createPlaceholderBlock());
      if (previousSelection) {
        slate.Transforms.select(editor, {
          anchor: {
            path: [0, 0],
            offset: 0
          },
          focus: {
            path: [0, 0],
            offset: 0
          }
        });
      }
      debugState(editor, "after");
      return true;
    }
    if (patch.path.length === 1) {
      const lastKey = findLastKey(patch.path);
      const index = editor.children.findIndex((node, indx) => lastKey ? node._key === lastKey : indx === patch.path[0]);
      if (index === -1) {
        debug$i("Could not find block to unset at path ".concat(JSON.stringify(patch.path)));
        return false;
      }
      debug$i("Removing block at path [".concat(index, "]"));
      debugState(editor, "before");
      if (editor.selection && editor.selection.focus.path[0] === index && editor.children[index - 1]) {
        const point = {
          path: [Math.max(editor.selection.focus.path[0] - 1, 0)],
          offset: 0
        };
        slate.Transforms.select(editor, {
          focus: point,
          anchor: point
        });
        slate.Transforms.move(editor, {
          unit: "line"
        });
      }
      slate.Transforms.removeNodes(editor, {
        at: [index]
      });
      debugState(editor, "after");
      return true;
    }
    const blockIndex = editor.children.findIndex((node, indx) => {
      return isKeyedSegment(patch.path[0]) ? node._key === patch.path[0]._key : indx === patch.path[0];
    });
    const block = blockIndex > -1 ? editor.children[blockIndex] : void 0;
    if (editor.isTextBlock(block) && patch.path[1] === "children" && patch.path.length === 3) {
      const childIndex = block.children.findIndex((node, indx) => {
        return isKeyedSegment(patch.path[2]) ? node._key === patch.path[2]._key : indx === patch.path[2];
      });
      const targetPath = [blockIndex, childIndex];
      const prevSel = editor.selection && {
        ...editor.selection
      };
      const onSamePath = isEqual__default.default((_a = editor.selection) == null ? void 0 : _a.focus.path, targetPath);
      if (childIndex === -1) {
        debug$i("Could not find child to unset at path ".concat(JSON.stringify(targetPath)));
        return false;
      }
      debug$i("Unsetting child at path ".concat(JSON.stringify(targetPath)));
      debugState(editor, "before");
      if (prevSel && onSamePath && editor.isTextBlock(block)) {
        const needToAdjust = childIndex >= prevSel.focus.path[1];
        if (needToAdjust) {
          const textChild = block.children[childIndex];
          const isMergeUnset = (previousPatch2 == null ? void 0 : previousPatch2.type) === "set" && previousPatch2.path[3] === "text" && typeof previousPatch2.value === "string" && editor.isTextSpan(textChild) && isEqual__default.default(previousPatch2.value.slice(-textChild.text.length), block.children[childIndex].text);
          if (isMergeUnset) {
            const mergedChild = block.children[Math.max(childIndex - 1, 0)];
            debug$i("Adjusting selection for merging of nodes");
            prevSel.focus = {
              ...prevSel.focus
            };
            prevSel.focus.path = [targetPath[0], Math.max(targetPath[1] - 1, 0)];
            prevSel.focus.offset = editor.isTextSpan(mergedChild) ? mergedChild.text.length - textChild.text.length + prevSel.focus.offset : 0;
            prevSel.anchor = prevSel.focus;
            slate.Transforms.select(editor, prevSel);
            slate.Transforms.removeNodes(editor, {
              at: [blockIndex, childIndex]
            });
            debugState(editor, "after");
            return true;
          }
        }
      }
      slate.Transforms.removeNodes(editor, {
        at: [blockIndex, childIndex]
      });
      debugState(editor, "after");
      return true;
    }
    return false;
  }
  let previousPatch;
  return function (editor, patch) {
    let changed = false;
    debug$i("\n\nNEW PATCH =============================================================");
    debug$i(JSON.stringify(patch, null, 2));
    try {
      switch (patch.type) {
        case "insert":
          changed = insertPatch(editor, patch);
          break;
        case "unset":
          changed = unsetPatch(editor, patch, previousPatch);
          break;
        case "set":
          changed = setPatch(editor, patch);
          break;
        case "diffMatchPatch":
          changed = diffMatchPatch(editor, patch);
          break;
        default:
          debug$i("Unhandled patch", patch.type);
      }
    } catch (err) {
      console.error(err);
    }
    previousPatch = patch;
    return changed;
  };
}
function isKeyedSegment(segment) {
  return typeof segment === "object" && "_key" in segment;
}
function findLastKey(path) {
  let key = null;
  path.concat("").reverse().forEach(part => {
    if (isKeyedSegment(part)) {
      key = part._key;
    }
  });
  return key;
}
function debugState(editor, stateName) {
  debug$i("Children ".concat(stateName, ":"), JSON.stringify(editor.children, null, 2));
  debug$i("Selection ".concat(stateName, ": "), JSON.stringify(editor.selection, null, 2));
}
function bufferUntil(emitWhen) {
  return source => rxjs.defer(() => {
    let buffer = [];
    return source.pipe(rxjs.tap(v => buffer.push(v)),
    // add values to buffer
    rxjs.switchMap(() => emitWhen(buffer) ? rxjs.of(buffer) : rxjs.EMPTY),
    // emit the buffer when the condition is met
    rxjs.tap(() => buffer = [])
    // clear the buffer
    );
  });
}

const debug$h = debugWithName("plugin:withUndoRedo");
const dmp = new diffMatchPatchExports.diff_match_patch();
const SAVING = /* @__PURE__ */new WeakMap();
const MERGING = /* @__PURE__ */new WeakMap();
const UNDO_STEP_LIMIT = 300;
const isMerging = editor => {
  return MERGING.get(editor);
};
const isSaving = editor => {
  if (!isPatching(editor)) {
    return false;
  }
  return SAVING.get(editor);
};
function createWithUndoRedo(options) {
  const {
    readOnly,
    patches$
  } = options;
  const remotePatches = [];
  return editor => {
    if (patches$) {
      editor.subscriptions.push(() => {
        debug$h("Subscribing to patches");
        const sub = patches$.subscribe(_ref4 => {
          let {
            patches
          } = _ref4;
          patches.forEach(patch => {
            if (patch.origin !== "local") {
              remotePatches.push({
                patch,
                time: /* @__PURE__ */new Date()
              });
            }
          });
        });
        return () => {
          debug$h("Unsubscribing to patches");
          sub.unsubscribe();
        };
      });
    }
    editor.history = {
      undos: [],
      redos: []
    };
    const {
      apply
    } = editor;
    editor.apply = op => {
      if (readOnly) {
        apply(op);
        return;
      }
      const {
        operations,
        history
      } = editor;
      const {
        undos
      } = history;
      const step = undos[undos.length - 1];
      const lastOp = step && step.operations && step.operations[step.operations.length - 1];
      const overwrite = shouldOverwrite(op, lastOp);
      let save = isSaving(editor);
      let merge = isMerging(editor);
      if (save == null) {
        save = shouldSave(op);
      }
      if (save) {
        if (merge == null) {
          if (step == null) {
            merge = false;
          } else if (operations.length !== 0) {
            merge = true;
          } else {
            merge = shouldMerge(op, lastOp) || overwrite;
          }
        }
        if (step && merge) {
          if (overwrite) {
            step.operations.pop();
          }
          step.operations.push(op);
        } else {
          const stp = {
            operations: [...(editor.selection === null ? [] : [createSelectOperation(editor)]), op],
            timestamp: /* @__PURE__ */new Date()
          };
          undos.push(stp);
          debug$h("Created new undo step", step);
        }
        while (undos.length > UNDO_STEP_LIMIT) {
          undos.shift();
        }
        if (shouldClear(op)) {
          history.redos = [];
        }
      }
      apply(op);
    };
    editor.undo = () => {
      if (readOnly) {
        return;
      }
      const {
        undos
      } = editor.history;
      if (undos.length > 0) {
        const step = undos[undos.length - 1];
        debug$h("Undoing", step);
        if (step.operations.length > 0) {
          const otherPatches = [...remotePatches.filter(item => item.time >= step.timestamp)];
          let transformedOperations = step.operations;
          otherPatches.forEach(item => {
            transformedOperations = flatten__default.default(transformedOperations.map(op => transformOperation(editor, item.patch, op)));
          });
          withoutSaving(editor, () => {
            slate.Editor.withoutNormalizing(editor, () => {
              transformedOperations.map(slate.Operation.inverse).reverse().forEach(op => {
                try {
                  editor.apply(op);
                } catch (err) {
                  debug$h("Could not perform undo step", err);
                  editor.history.redos.push(step);
                  editor.history.undos.pop();
                }
              });
            });
          });
        }
        editor.history.redos.push(step);
        editor.history.undos.pop();
        editor.onChange();
      }
    };
    editor.redo = () => {
      if (readOnly) {
        return;
      }
      const {
        redos
      } = editor.history;
      if (redos.length > 0) {
        const step = redos[redos.length - 1];
        debug$h("Redoing", step);
        if (step.operations.length > 0) {
          const otherPatches = remotePatches.filter(item => item.time > step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach(item => {
            transformedOperations = flatten__default.default(transformedOperations.map(op => transformOperation(editor, item.patch, op)));
          });
          withoutSaving(editor, () => {
            slate.Editor.withoutNormalizing(editor, () => {
              transformedOperations.forEach(op => {
                try {
                  editor.apply(op);
                } catch (err) {
                  debug$h("Could not perform redo step", err);
                  editor.history.undos.push(step);
                  editor.history.redos.pop();
                }
              });
            });
          });
        }
        editor.history.undos.push(step);
        editor.history.redos.pop();
        editor.onChange();
      }
    };
    return editor;
  };
}
function transformOperation(editor, patch, operation) {
  let transformedOperation = {
    ...operation
  };
  if (patch.type === "insert" && patch.path.length === 1) {
    return [adjustBlockPath(editor, patch, operation, patch.items.length)];
  }
  if (patch.type === "unset" && patch.path.length === 1) {
    return [adjustBlockPath(editor, patch, operation, -1)];
  }
  if (patch.type === "unset" && patch.path.length === 0) {
    debug$h("Adjusting selection for unset everything patch and ".concat(operation.type, " operation"));
    return [operation];
  }
  if (patch.type === "diffMatchPatch") {
    const blockIndex = editor.children.findIndex(blk => isEqual__default.default({
      _key: blk._key
    }, patch.path[0]));
    const block = editor.children[blockIndex];
    if (slate.Element.isElement(block) && Array.isArray(block.children)) {
      const childIndex = block.children.findIndex(child => isEqual__default.default({
        _key: child._key
      }, patch.path[2]));
      const parsed = dmp.patch_fromText(patch.value)[0];
      if (!parsed) {
        debug$h("Could not parse diffMatchPatch", patch);
        return [operation];
      }
      const distance = parsed.length2 - parsed.length1;
      const patchIsRemovingText = parsed.diffs.some(diff => diff[0] === -1);
      if (operation.type === "split_node" && operation.path.length > 1) {
        const splitOperation = transformedOperation;
        if (patchIsRemovingText) {
          splitOperation.position -= distance;
        } else {
          splitOperation.position += distance;
        }
        return [splitOperation];
      }
      if ((operation.type === "insert_text" || operation.type === "remove_text") && slate.Path.isPath(operation.path) && operation.path[0] !== void 0 && operation.path[0] === blockIndex && operation.path[1] === childIndex) {
        if (operation.type === "insert_text") {
          let insertOffset = 0;
          for (const diff of parsed.diffs) {
            if (diff[0] === 0) {
              insertOffset = diff[1].length;
            }
            if (diff[0] === 1) {
              break;
            }
          }
          if (parsed.start1 !== null && insertOffset + parsed.start1 <= operation.offset) {
            const insertTextOperation = transformedOperation;
            insertTextOperation.offset += distance;
            transformedOperation = insertTextOperation;
          }
          return [transformedOperation];
        }
        if (operation.type === "remove_text") {
          let insertOffset = 0;
          for (const diff of parsed.diffs) {
            if (diff[0] === 0) {
              insertOffset = diff[1].length;
            }
            if (diff[0] === -1) {
              break;
            }
          }
          if (parsed.start1 !== null && insertOffset + parsed.start1 <= operation.offset) {
            const removeTextOperation = transformedOperation;
            removeTextOperation.offset -= distance;
            transformedOperation = removeTextOperation;
          }
          return [transformedOperation];
        }
      }
    }
  }
  return [operation];
}
function adjustBlockPath(editor, patch, operation, level) {
  const myIndex = editor.children.findIndex(blk => isEqual__default.default({
    _key: blk._key
  }, patch.path[0]));
  if (myIndex >= 0 && operation.type !== "set_selection" && Array.isArray(operation.path) && operation.path[0] !== void 0 && operation.path[0] >= myIndex + level) {
    const transformedOperation = {
      ...operation
    };
    const newPath = [operation.path[0] + level, ...operation.path.slice(1)];
    debug$h("Adjusting ".concat(operation.type, " for block ").concat(patch.type), operation.path, newPath);
    transformedOperation.path = newPath;
    return transformedOperation;
  }
  return operation;
}
const shouldMerge = (op, prev) => {
  if (op.type === "set_selection") {
    return true;
  }
  if (prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && slate.Path.equals(op.path, prev.path) && op.text !== " ") {
    return true;
  }
  if (prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && slate.Path.equals(op.path, prev.path)) {
    return true;
  }
  return false;
};
const shouldSave = (op, prev) => {
  if (op.type === "set_selection" && op.newProperties === null) {
    return false;
  }
  return true;
};
const shouldOverwrite = (op, prev) => {
  if (prev && op.type === "set_selection" && prev.type === "set_selection") {
    return true;
  }
  return false;
};
const shouldClear = op => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};
function withoutSaving(editor, fn) {
  const prev = isSaving(editor);
  SAVING.set(editor, false);
  fn();
  SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
  return {
    type: "set_selection",
    properties: {
      ...editor.selection
    },
    newProperties: {
      ...editor.selection
    }
  };
}
const debug$g = debugWithName("plugin:withPatches");
function createWithPatches(_ref5) {
  let {
    change$,
    isPending,
    patches$,
    patchFunctions,
    readOnly,
    schemaTypes
  } = _ref5;
  let previousChildren;
  const patchToOperations = createPatchToOperations(schemaTypes);
  return function withPatches(editor) {
    PATCHING.set(editor, true);
    previousChildren = [...editor.children];
    const {
      apply
    } = editor;
    if (patches$) {
      editor.subscriptions.push(() => {
        debug$g("Subscribing to patches$");
        const sub = patches$.pipe(rxjs.tap(_ref6 => {
          let {
            patches
          } = _ref6;
          if (patches.every(p => p.origin === "local")) {
            isPending.current = false;
          }
        }), bufferUntil(() => !isPending.current), rxjs.concatMap(incoming => {
          return incoming;
        })).subscribe(_ref7 => {
          let {
            patches,
            snapshot
          } = _ref7;
          const remotePatches = patches.filter(p => p.origin !== "local");
          if (remotePatches.length !== 0) {
            debug$g("Remote patches", patches);
            slate.Editor.withoutNormalizing(editor, () => {
              remotePatches.forEach(patch => {
                debug$g("Handling remote patch ".concat(JSON.stringify(patch)));
                withoutPatching(editor, () => {
                  withoutSaving(editor, () => {
                    withPreserveKeys(editor, () => {
                      try {
                        patchToOperations(editor, patch, patches, snapshot);
                      } catch (err) {
                        debug$g("Got error trying to create operations from patch");
                        console.error(err);
                      }
                    });
                  });
                });
              });
            });
          }
        });
        return () => {
          debug$g("Unsubscribing to patches$");
          sub.unsubscribe();
        };
      });
    }
    editor.apply = operation => {
      if (readOnly) {
        apply(operation);
        return editor;
      }
      let patches = [];
      previousChildren = editor.children;
      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);
      apply(operation);
      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);
      if (!isPatching(editor)) {
        debug$g("Editor is not producing patch for operation ".concat(operation.type), operation);
        return editor;
      }
      if (editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection") {
        patches.push(insert$1(previousChildren, "before", [0]));
      }
      switch (operation.type) {
        case "insert_text":
          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];
          break;
        case "remove_text":
          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];
          break;
        case "remove_node":
          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];
          break;
        case "split_node":
          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];
          break;
        case "insert_node":
          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];
          break;
        case "set_node":
          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];
          break;
        case "merge_node":
          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];
          break;
        case "move_node":
          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];
          break;
      }
      if (!editorWasEmpty && editorIsEmpty && ["merge_node", "set_node", "remove_text", "remove_node"].includes(operation.type)) {
        patches = [...patches, unset([])];
        change$.next({
          type: "unset",
          previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))
        });
      }
      if (editorWasEmpty && patches.length > 0) {
        patches = [setIfMissing([], []), ...patches];
      }
      if (patches.length > 0) {
        patches.forEach(patch => {
          change$.next({
            type: "patch",
            patch: {
              ...patch,
              origin: "local"
            }
          });
        });
      }
      return editor;
    };
    return editor;
  };
}
const debug$f = debugWithName("plugin:withPlaceholderBlock");
function createWithPlaceholderBlock(_ref8) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref8;
  return function withPlaceholderBlock(editor) {
    editor.createPlaceholderBlock = () => {
      debug$f("Creating placeholder block");
      return {
        _type: schemaTypes.block.name,
        _key: keyGenerator(),
        style: schemaTypes.styles[0].value || "normal",
        markDefs: [],
        children: [{
          _type: "span",
          _key: keyGenerator(),
          text: "",
          marks: []
        }]
      };
    };
    return editor;
  };
}
const debug$e = debugWithName("plugin:withPortableTextBlockStyle");
function createWithPortableTextBlockStyle(types, change$) {
  const defaultStyle = types.styles[0].value;
  return function withPortableTextBlockStyle(editor) {
    const {
      normalizeNode
    } = editor;
    editor.normalizeNode = nodeEntry => {
      normalizeNode(nodeEntry);
      const [, path] = nodeEntry;
      for (const op of editor.operations) {
        if (op.type === "split_node" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate.Path.equals(path, op.path)) {
          const [child] = slate.Editor.node(editor, [op.path[0] + 1, 0]);
          if (slate.Text.isText(child) && child.text === "") {
            debug$e("Normalizing split node to ".concat(defaultStyle, " style"), op);
            slate.Transforms.setNodes(editor, {
              style: defaultStyle
            }, {
              at: [op.path[0] + 1],
              voids: false
            });
            break;
          }
        }
      }
    };
    editor.pteHasBlockStyle = style => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isTextBlock(node) && node.style === style
      })];
      if (selectedBlocks.length > 0) {
        return true;
      }
      return false;
    };
    editor.pteToggleBlockStyle = blockStyle => {
      if (!editor.selection) {
        return;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => slate.Element.isElement(node) && node._type === types.block.name
      })];
      selectedBlocks.forEach(_ref9 => {
        let [node, path] = _ref9;
        if (editor.isTextBlock(node) && node.style === blockStyle) {
          debug$e("Unsetting block style '".concat(blockStyle, "'"));
          slate.Transforms.setNodes(editor, {
            ...node,
            style: defaultStyle
          }, {
            at: path
          });
        } else {
          if (blockStyle) {
            debug$e("Setting style '".concat(blockStyle, "'"));
          } else {
            debug$e("Setting default style", defaultStyle);
          }
          slate.Transforms.setNodes(editor, {
            ...node,
            style: blockStyle || defaultStyle
          }, {
            at: path
          });
        }
      });
      editor.onChange();
    };
    return editor;
  };
}
const debug$d = debugWithName("plugin:withPortableTextLists");
const MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(types) {
  return function withPortableTextLists(editor) {
    editor.pteToggleListItem = listItemStyle => {
      const isActive = editor.pteHasListStyle(listItemStyle);
      if (isActive) {
        debug$d("Remove list item '".concat(listItemStyle, "'"));
        editor.pteUnsetListItem(listItemStyle);
      } else {
        debug$d("Add list item '".concat(listItemStyle, "'"));
        editor.pteSetListItem(listItemStyle);
      }
    };
    editor.pteUnsetListItem = listItemStyle => {
      if (!editor.selection) {
        return;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => slate.Element.isElement(node) && node._type === types.block.name
      })];
      selectedBlocks.forEach(_ref10 => {
        let [node, path] = _ref10;
        if (editor.isListBlock(node)) {
          const {
            listItem,
            level,
            ...rest
          } = node;
          const newNode = {
            ...rest,
            listItem: void 0,
            level: void 0
          };
          debug$d("Unsetting list '".concat(listItemStyle, "'"));
          slate.Transforms.setNodes(editor, newNode, {
            at: path
          });
        }
      });
    };
    editor.pteSetListItem = listItemStyle => {
      if (!editor.selection) {
        return;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isTextBlock(node)
      })];
      selectedBlocks.forEach(_ref11 => {
        let [node, path] = _ref11;
        debug$d("Setting list '".concat(listItemStyle, "'"));
        slate.Transforms.setNodes(editor, {
          ...node,
          level: 1,
          listItem: listItemStyle || types.lists[0] && types.lists[0].value
        }, {
          at: path
        });
      });
    };
    editor.pteEndList = () => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => slate.Element.isElement(node) && editor.isListBlock(node) && node.children.length === 1 && slate.Text.isText(node.children[0]) && node.children[0].text === ""
      })];
      if (selectedBlocks.length === 0) {
        return false;
      }
      selectedBlocks.forEach(_ref12 => {
        let [node, path] = _ref12;
        if (slate.Element.isElement(node)) {
          debug$d("Unset list");
          slate.Transforms.setNodes(editor, {
            ...node,
            level: void 0,
            listItem: void 0
          }, {
            at: path
          });
        }
      });
      return true;
    };
    editor.pteIncrementBlockLevels = reverse => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => !!editor.isListBlock(node)
      })];
      if (selectedBlocks.length === 0) {
        return false;
      }
      selectedBlocks.forEach(_ref13 => {
        let [node, path] = _ref13;
        if (editor.isListBlock(node)) {
          let level = node.level || 1;
          if (reverse) {
            level--;
            debug$d("Decrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
          } else {
            level++;
            debug$d("Incrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
          }
          slate.Transforms.setNodes(editor, {
            level: Math.min(MAX_LIST_LEVEL, Math.max(1, level))
          }, {
            at: path
          });
        }
      });
      return true;
    };
    editor.pteHasListStyle = listStyle => {
      if (!editor.selection) {
        return false;
      }
      const selectedBlocks = [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: node => editor.isListBlock(node) && node.listItem === listStyle
      })];
      if (selectedBlocks.length > 0) {
        return true;
      }
      return false;
    };
    return editor;
  };
}
const debug$c = debugWithName("plugin:withPortableTextMarkModel");
function createWithPortableTextMarkModel(types) {
  return function withPortableTextMarkModel(editor) {
    const {
      apply,
      normalizeNode
    } = editor;
    const decorators = types.decorators.map(t => t.value);
    editor.normalizeNode = nodeEntry => {
      normalizeNode(nodeEntry);
      if (editor.operations.some(op => ["insert_node", "insert_text", "merge_node", "remove_node", "remove_text", "set_node"].includes(op.type))) {
        mergeSpans(editor);
      }
      const [node, path] = nodeEntry;
      const isSpan = slate.Text.isText(node) && node._type === types.span.name;
      const isTextBlock = editor.isTextBlock(node);
      if (isSpan || isTextBlock) {
        if (isSpan && !Array.isArray(node.marks)) {
          debug$c("Adding .marks to span node");
          slate.Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path
          });
          editor.onChange();
        }
        for (const op of editor.operations) {
          if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
            const [targetBlock, targetPath] = slate.Editor.node(editor, [op.path[0] - 1]);
            debug$c("Copying markDefs over to merged block", op);
            if (editor.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              const newMarkDefs = uniq__default.default([...oldDefs, ...op.properties.markDefs]);
              const isNormalized = isEqual__default.default(newMarkDefs, targetBlock.markDefs);
              if (!isNormalized) {
                slate.Transforms.setNodes(editor, {
                  markDefs: newMarkDefs
                }, {
                  at: targetPath,
                  voids: false
                });
                editor.onChange();
              }
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && slate.Element.isElementProps(op.properties) && op.properties._type === types.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] + 1 < editor.children.length) {
            const [targetBlock, targetPath] = slate.Editor.node(editor, [op.path[0] + 1]);
            debug$c("Copying markDefs over to split block", op);
            if (editor.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              slate.Transforms.setNodes(editor, {
                markDefs: uniq__default.default([...oldDefs, ...op.properties.markDefs])
              }, {
                at: targetPath,
                voids: false
              });
              editor.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 2 && op.properties._type === types.span.name && "marks" in op.properties && Array.isArray(op.properties.marks) && op.properties.marks.length > 0 && op.path[0] + 1 < editor.children.length) {
            const [child, childPath] = slate.Editor.node(editor, [op.path[0] + 1, 0]);
            if (slate.Text.isText(child) && child.text === "" && Array.isArray(child.marks) && child.marks.length > 0) {
              slate.Transforms.setNodes(editor, {
                marks: []
              }, {
                at: childPath,
                voids: false
              });
              editor.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && op.properties._type === types.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0) {
            const [block, blockPath] = slate.Editor.node(editor, [op.path[0]]);
            if (editor.isTextBlock(block) && block.children.length === 1 && block.markDefs && block.markDefs.length > 0 && slate.Text.isText(block.children[0]) && block.children[0].text === "" && (!block.children[0].marks || block.children[0].marks.length === 0)) {
              slate.Transforms.setNodes(editor, {
                markDefs: []
              }, {
                at: blockPath
              });
              editor.onChange();
            }
          }
        }
        if (isSpan && Array.isArray(node.marks) && node.marks.length > 0 && node.text === "") {
          slate.Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path,
            voids: false
          });
          editor.onChange();
        }
      }
      if (isTextBlock && editor.operations.some(op => ["split_node", "remove_node", "remove_text", "merge_node"].includes(op.type))) {
        normalizeMarkDefs(editor);
      }
    };
    editor.apply = op => {
      var _a, _b;
      if (op.type === "insert_text") {
        const {
          selection
        } = editor;
        if (selection && slate.Range.isCollapsed(selection) && ((_b = (_a = slate.Editor.marks(editor)) == null ? void 0 : _a.marks) == null ? void 0 : _b.some(mark => !decorators.includes(mark)))) {
          const [node] = Array.from(slate.Editor.nodes(editor, {
            mode: "lowest",
            at: selection.focus,
            match: n => n._type === types.span.name,
            voids: false
          }))[0] || [void 0];
          if (slate.Text.isText(node) && node.text.length === selection.focus.offset && Array.isArray(node.marks) && node.marks.length > 0) {
            apply(op);
            slate.Transforms.splitNodes(editor, {
              match: slate.Text.isText,
              at: {
                ...selection.focus,
                offset: selection.focus.offset
              }
            });
            const marksWithoutAnnotationMarks = ({
              ...(slate.Editor.marks(editor) || {})
            }.marks || []).filter(mark => decorators.includes(mark));
            slate.Transforms.setNodes(editor, {
              marks: marksWithoutAnnotationMarks
            }, {
              at: slate.Path.next(selection.focus.path)
            });
            return;
          }
        }
      }
      apply(op);
    };
    editor.addMark = mark => {
      if (editor.selection) {
        if (slate.Range.isExpanded(editor.selection)) {
          slate.Transforms.setNodes(editor, {}, {
            match: slate.Text.isText,
            split: true
          });
          const splitTextNodes = [...slate.Editor.nodes(editor, {
            at: editor.selection,
            match: slate.Text.isText
          })];
          const shouldRemoveMark = flatten__default.default(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);
          if (shouldRemoveMark) {
            editor.removeMark(mark);
            return;
          }
          slate.Editor.withoutNormalizing(editor, () => {
            splitTextNodes.forEach(_ref14 => {
              let [node, path] = _ref14;
              const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter(eMark => eMark !== mark), mark];
              slate.Transforms.setNodes(editor, {
                marks
              }, {
                at: path,
                match: slate.Text.isText,
                split: true,
                hanging: true
              });
            });
          });
          slate.Editor.normalize(editor);
        } else {
          const existingMarks = {
            ...(slate.Editor.marks(editor) || {})
          }.marks || [];
          const marks = {
            ...(slate.Editor.marks(editor) || {}),
            marks: [...existingMarks, mark]
          };
          editor.marks = marks;
        }
        editor.onChange();
      }
    };
    editor.removeMark = mark => {
      const {
        selection
      } = editor;
      if (selection) {
        if (slate.Range.isExpanded(selection)) {
          slate.Editor.withoutNormalizing(editor, () => {
            slate.Transforms.setNodes(editor, {}, {
              match: slate.Text.isText,
              split: true
            });
            if (editor.selection) {
              const splitTextNodes = [...slate.Editor.nodes(editor, {
                at: editor.selection,
                match: slate.Text.isText
              })];
              splitTextNodes.forEach(_ref15 => {
                let [node, path] = _ref15;
                const block = editor.children[path[0]];
                if (slate.Element.isElement(block) && block.children.includes(node)) {
                  slate.Transforms.setNodes(editor, {
                    marks: (Array.isArray(node.marks) ? node.marks : []).filter(eMark => eMark !== mark)
                  }, {
                    at: path
                  });
                }
              });
            }
          });
          slate.Editor.normalize(editor);
        } else {
          const existingMarks = {
            ...(slate.Editor.marks(editor) || {})
          }.marks || [];
          const marks = {
            ...(slate.Editor.marks(editor) || {}),
            marks: existingMarks.filter(eMark => eMark !== mark)
          };
          editor.marks = marks;
        }
        editor.onChange();
      }
    };
    editor.pteIsMarkActive = mark => {
      if (!editor.selection || editor.selection.focus.path.length < 2) {
        return false;
      }
      let existingMarks = {
        ...(slate.Editor.marks(editor) || {})
      }.marks || [];
      if (slate.Range.isExpanded(editor.selection)) {
        Array.from(slate.Editor.nodes(editor, {
          match: slate.Text.isText,
          at: editor.selection
        })).forEach(n => {
          const [node] = n;
          existingMarks = uniq__default.default([...existingMarks, ...(node.marks || [])]);
        });
      }
      return existingMarks.includes(mark);
    };
    editor.pteToggleMark = mark => {
      const isActive = editor.pteIsMarkActive(mark);
      if (isActive) {
        debug$c("Remove mark '".concat(mark, "'"));
        slate.Editor.removeMark(editor, mark);
      } else {
        debug$c("Add mark '".concat(mark, "'"));
        slate.Editor.addMark(editor, mark, true);
      }
      editor.onChange();
    };
    return editor;
  };
  function mergeSpans(editor) {
    const {
      selection
    } = editor;
    if (selection) {
      for (const [node, path] of Array.from(slate.Editor.nodes(editor, {
        at: slate.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
      })).reverse()) {
        const [parent] = path.length > 1 ? slate.Editor.node(editor, slate.Path.parent(path)) : [void 0];
        const nextPath = [path[0], path[1] + 1];
        if (slate.Editor.isBlock(editor, parent)) {
          const nextNode = parent.children[nextPath[1]];
          if (slate.Text.isText(node) && slate.Text.isText(nextNode) && isEqual__default.default(nextNode.marks, node.marks)) {
            debug$c("Merging spans");
            slate.Transforms.mergeNodes(editor, {
              at: nextPath,
              voids: true
            });
            editor.onChange();
          }
        }
      }
    }
  }
  function normalizeMarkDefs(editor) {
    const {
      selection
    } = editor;
    if (selection) {
      const blocks = slate.Editor.nodes(editor, {
        at: selection,
        match: n => n._type === types.block.name
      });
      for (const [block, path] of blocks) {
        if (editor.isTextBlock(block)) {
          const newMarkDefs = (block.markDefs || []).filter(def => {
            return block.children.find(child => {
              return slate.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key);
            });
          });
          if (!isEqual__default.default(newMarkDefs, block.markDefs)) {
            debug$c("Removing markDef not in use");
            slate.Transforms.setNodes(editor, {
              markDefs: newMarkDefs
            }, {
              at: path
            });
            editor.onChange();
          }
        }
      }
    }
  }
}
const debug$b = debugWithName("plugin:withPortableTextSelections");
function createWithPortableTextSelections(change$, types) {
  let prevSelection = null;
  return function withPortableTextSelections(editor) {
    const emitPortableTextSelection = () => {
      if (prevSelection !== editor.selection) {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          if (existing) {
            ptRange = existing;
          } else {
            const value = editor.children;
            ptRange = toPortableTextRange(value, editor.selection, types);
            SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
          }
        }
        debug$b("Emitting selection ".concat(JSON.stringify(ptRange || null)));
        if (ptRange) {
          change$.next({
            type: "selection",
            selection: ptRange
          });
        } else {
          change$.next({
            type: "selection",
            selection: null
          });
        }
      }
      prevSelection = editor.selection;
    };
    const {
      onChange
    } = editor;
    editor.onChange = () => {
      const hasChanges = editor.operations.length > 0;
      onChange();
      if (hasChanges) {
        emitPortableTextSelection();
      }
    };
    return editor;
  };
}
const debug$a = debugWithName("plugin:withSchemaTypes");
function createWithSchemaTypes(types$1) {
  return function withSchemaTypes(editor) {
    editor.isTextBlock = value => {
      return types.isPortableTextTextBlock(value) && value._type === types$1.block.name;
    };
    editor.isTextSpan = value => {
      return types.isPortableTextSpan(value) && value._type == types$1.span.name;
    };
    editor.isListBlock = value => {
      return types.isPortableTextListBlock(value) && value._type === types$1.block.name;
    };
    editor.isVoid = element => {
      return types$1.block.name !== element._type && (types$1.blockObjects.map(obj => obj.name).includes(element._type) || types$1.inlineObjects.map(obj => obj.name).includes(element._type));
    };
    editor.isInline = element => {
      const inlineSchemaTypes = types$1.inlineObjects.map(obj => obj.name);
      return inlineSchemaTypes.includes(element._type) && "__inline" in element && element.__inline === true;
    };
    const {
      apply
    } = editor;
    editor.apply = op => {
      const isInsertTextWithoutType = op.type === "insert_node" && op.path.length === 2 && slate.Text.isText(op.node) && op.node._type === void 0;
      if (isInsertTextWithoutType) {
        const insertNodeOperation = op;
        const newNode = {
          ...insertNodeOperation.node,
          _type: "span"
        };
        op.node = newNode;
        debug$a("Setting span type to child without a type", op);
      }
      apply(op);
    };
    return editor;
  };
}
const debug$9 = debugWithName("plugin:withUtils");
function createWithUtils(_ref16) {
  let {
    schemaTypes,
    keyGenerator
  } = _ref16;
  return function withUtils(editor) {
    editor.pteExpandToWord = () => {
      const {
        selection
      } = editor;
      if (selection && !slate.Range.isExpanded(selection)) {
        const [textNode] = slate.Editor.node(editor, selection.focus, {
          depth: 2
        });
        if (!textNode || !slate.Text.isText(textNode) || textNode.text.length === 0) {
          debug$9("pteExpandToWord: Can't expand to word here");
          return;
        }
        const {
          focus
        } = selection;
        const focusOffset = focus.offset;
        const charsBefore = textNode.text.slice(0, focusOffset);
        const charsAfter = textNode.text.slice(focusOffset, -1);
        const isEmpty = str => str.match(/\s/g);
        const whiteSpaceBeforeIndex = charsBefore.split("").reverse().findIndex(str => isEmpty(str));
        const newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0;
        const whiteSpaceAfterIndex = charsAfter.split("").findIndex(obj => isEmpty(obj));
        const newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);
        if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {
          debug$9("pteExpandToWord: Expanding to focused word");
          slate.Transforms.setSelection(editor, {
            anchor: {
              ...selection.anchor,
              offset: newStartOffset
            },
            focus: {
              ...selection.focus,
              offset: newEndOffset
            }
          });
          return;
        }
        debug$9("pteExpandToWord: Can't expand to word here");
      }
    };
    return editor;
  };
}
const debug$8 = debugWithName("plugin:withHotKeys");
const DEFAULT_HOTKEYS = {
  marks: {
    "mod+b": "strong",
    "mod+i": "em",
    "mod+u": "underline",
    "mod+'": "code"
  },
  custom: {}
};
function createWithHotkeys(types$1, keyGenerator, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"];
  const activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;
  const createEmptyBlock = () => toSlateValue([{
    _type: types$1.block.name,
    _key: keyGenerator(),
    style: "normal",
    markDefs: [],
    children: [{
      _type: "span",
      _key: keyGenerator(),
      text: "",
      marks: []
    }]
  }], portableTextEditor)[0];
  return function withHotKeys(editor) {
    editor.pteWithHotKeys = event => {
      Object.keys(activeHotkeys).forEach(cat => {
        if (cat === "marks") {
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }
            if (isHotkey__default.default(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$8("HotKey ".concat(hotkey, " to toggle ").concat(mark));
                editor.pteToggleMark(mark);
              }
            }
          }
        }
        if (cat === "custom") {
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }
            if (isHotkey__default.default(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
        }
      });
      const isEnter = isHotkey__default.default("enter", event.nativeEvent);
      const isTab = isHotkey__default.default("tab", event.nativeEvent);
      const isShiftEnter = isHotkey__default.default("shift+enter", event.nativeEvent);
      const isShiftTab = isHotkey__default.default("shift+tab", event.nativeEvent);
      const isBackspace = isHotkey__default.default("backspace", event.nativeEvent);
      const isDelete = isHotkey__default.default("delete", event.nativeEvent);
      if (isBackspace && editor.selection && editor.selection.focus.path[0] > 0 && slate.Range.isCollapsed(editor.selection)) {
        const [prevBlock, prevPath] = slate.Editor.node(editor, slate.Path.previous(editor.selection.focus.path.slice(0, 1)));
        const [focusBlock] = slate.Editor.node(editor, editor.selection.focus, {
          depth: 1
        });
        if (prevBlock && focusBlock && slate.Editor.isVoid(editor, prevBlock) && editor.selection.focus.offset === 0) {
          debug$8("Preventing deleting void block above");
          event.preventDefault();
          event.stopPropagation();
          slate.Transforms.removeNodes(editor, {
            match: n => n === focusBlock
          });
          slate.Transforms.select(editor, prevPath);
          editor.onChange();
          return;
        }
      }
      if (isDelete && editor.selection && editor.selection.focus.offset === 0 && slate.Range.isCollapsed(editor.selection) && editor.children[editor.selection.focus.path[0] + 1]) {
        const [nextBlock] = slate.Editor.node(editor, slate.Path.next(editor.selection.focus.path.slice(0, 1)));
        const [focusBlock, focusBlockPath] = slate.Editor.node(editor, editor.selection.focus, {
          depth: 1
        });
        if (nextBlock && focusBlock && !slate.Editor.isVoid(editor, focusBlock) && slate.Editor.isVoid(editor, nextBlock)) {
          debug$8("Preventing deleting void block below");
          event.preventDefault();
          event.stopPropagation();
          slate.Transforms.removeNodes(editor, {
            match: n => n === focusBlock
          });
          slate.Transforms.select(editor, focusBlockPath);
          editor.onChange();
          return;
        }
      }
      if ((isTab || isShiftTab) && editor.selection) {
        const [focusChild] = slate.Editor.node(editor, editor.selection.focus, {
          depth: 2
        });
        const [focusBlock] = types.isPortableTextSpan(focusChild) ? slate.Editor.node(editor, editor.selection.focus, {
          depth: 1
        }) : [];
        const hasAnnotationFocus = focusChild && types.isPortableTextTextBlock(focusBlock) && types.isPortableTextSpan(focusChild) && (focusChild.marks || []).filter(m => (focusBlock.markDefs || []).map(def => def._key).includes(m)).length > 0;
        const [start] = slate.Range.edges(editor.selection);
        const atStartOfNode = slate.Editor.isStart(editor, start, start.path);
        if (focusChild && types.isPortableTextSpan(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor.pteIncrementBlockLevels(isShiftTab)) {
          event.preventDefault();
        }
      }
      if (isEnter && !isShiftEnter && editor.selection) {
        let focusBlock;
        try {
          ;
          [focusBlock] = slate.Editor.node(editor, editor.selection.focus, {
            depth: 1
          });
        } catch (err) {}
        if (editor.isListBlock(focusBlock)) {
          if (editor.pteEndList()) {
            event.preventDefault();
          }
          return;
        }
        if (editor.isTextBlock(focusBlock) && focusBlock.style && focusBlock.style !== types$1.styles[0].value) {
          const [, end] = slate.Range.edges(editor.selection);
          const endAtEndOfNode = slate.Editor.isEnd(editor, end, end.path);
          if (endAtEndOfNode) {
            slate.Editor.insertNode(editor, createEmptyBlock());
            event.preventDefault();
            return;
          }
        }
        if (focusBlock && slate.Editor.isVoid(editor, focusBlock)) {
          slate.Editor.insertNode(editor, createEmptyBlock());
          event.preventDefault();
          return;
        }
      }
      if (isShiftEnter) {
        event.preventDefault();
        editor.insertText("\n");
        return;
      }
      if (isHotkey__default.default("mod+z", event.nativeEvent)) {
        event.preventDefault();
        editor.undo();
        return;
      }
      if (isHotkey__default.default("mod+y", event.nativeEvent) || isHotkey__default.default("mod+shift+z", event.nativeEvent)) {
        event.preventDefault();
        editor.redo();
      }
    };
    return editor;
  };
}
function validateValue(value, types, keyGenerator) {
  let resolution = null;
  let valid = true;
  const validChildTypes = [types.span.name, ...types.inlineObjects.map(t => t.name)];
  const validBlockTypes = [types.block.name, ...types.blockObjects.map(t => t.name)];
  if (value === void 0) {
    return {
      valid: true,
      resolution: null,
      value
    };
  }
  if (!Array.isArray(value) || value.length === 0) {
    return {
      valid: false,
      resolution: {
        patches: [unset([])],
        description: "Editor value must be an array of Portable Text blocks, or undefined.",
        action: "Unset the value",
        item: value
      },
      value
    };
  }
  if (value.some((blk, index) => {
    if (!isObject__default.default(blk)) {
      resolution = {
        patches: [unset([index])],
        description: "Block must be an object, got ".concat(String(blk)),
        action: "Unset invalid item",
        item: blk
      };
      return true;
    }
    if (!blk._key) {
      resolution = {
        patches: [set({
          ...blk,
          _key: keyGenerator()
        }, [index])],
        description: "Block at index ".concat(index, " is missing required _key."),
        action: "Set the block with a random _key value",
        item: blk
      };
      return true;
    }
    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      if (blk._type === "block") {
        const currentBlockTypeName = types.block.name;
        resolution = {
          patches: [set({
            ...blk,
            _type: currentBlockTypeName
          }, [{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
          action: "Use type '".concat(currentBlockTypeName, "'"),
          item: blk
        };
        return true;
      }
      resolution = {
        patches: [unset([{
          _key: blk._key
        }])],
        description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
        action: "Remove the block",
        item: blk
      };
      return true;
    }
    if (blk._type === types.block.name) {
      const textBlock = blk;
      if (!textBlock.children) {
        resolution = {
          patches: [unset([{
            _key: textBlock._key
          }])],
          description: "Text block with _key '".concat(textBlock._key, "' is missing required key 'children'."),
          action: "Remove the block",
          item: textBlock
        };
        return true;
      }
      if (!blk.markDefs) {
        resolution = {
          patches: [set({
            ...textBlock,
            markDefs: []
          }, [{
            _key: textBlock._key
          }])],
          description: "Block is missing required key 'markDefs'.",
          action: "Add empty markDefs array",
          item: textBlock
        };
        return true;
      }
      const allUsedMarks = uniq__default.default(flatten__default.default(textBlock.children.filter(cld => cld._type === types.span.name).map(cld => cld.marks || [])));
      const annotationMarks = allUsedMarks.filter(mark => !types.decorators.map(dec => dec.value).includes(mark));
      const orphanedMarks = annotationMarks.filter(mark => textBlock.markDefs ? !textBlock.markDefs.find(def => def._key === mark) : false);
      if (orphanedMarks.length > 0) {
        const spanChildren = textBlock.children.filter(cld => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some(mark => orphanedMarks.includes(mark)));
        if (spanChildren) {
          resolution = {
            patches: spanChildren.map(child => {
              return set((child.marks || []).filter(cMrk => !orphanedMarks.includes(cMrk)), [{
                _key: blk._key
              }, "children", {
                _key: child._key
              }, "marks"]);
            }),
            description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphanedMarks.join(", "), ") not supported by the current content model."),
            action: "Remove invalid marks",
            item: blk
          };
          return true;
        }
      }
      if (textBlock.children && textBlock.children.length === 0) {
        const newSpan = {
          _type: types.span.name,
          _key: keyGenerator(),
          text: ""
        };
        resolution = {
          patches: [insert$1([newSpan], "after", [{
            _key: blk._key
          }, "children", 0])],
          description: "Children for text block with _key '".concat(blk._key, "' is empty."),
          action: "Insert an empty text",
          item: blk
        };
        return true;
      }
      if (textBlock.children.some((child, cIndex) => {
        if (!child._key) {
          const newChild = {
            ...child,
            _key: keyGenerator()
          };
          resolution = {
            patches: [set(newChild, [{
              _key: blk._key
            }, "children", cIndex])],
            description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
            action: "Set a new random _key on the object",
            item: blk
          };
          return true;
        }
        if (!child._type || validChildTypes.includes(child._type) === false) {
          resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
            action: "Remove the object",
            item: blk
          };
          return true;
        }
        if (child._type === types.span.name && child.text === void 0) {
          resolution = {
            patches: [set({
              ...child,
              text: ""
            }, [{
              _key: blk._key
            }, "children", {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing text property!"),
            action: "Write an empty .text to the object",
            item: blk
          };
          return true;
        }
        return false;
      })) {
        valid = false;
      }
    }
    return false;
  })) {
    valid = false;
  }
  return {
    valid,
    resolution,
    value
  };
}
const debug$7 = debugWithName("plugin:withInsertData");
function createWithInsertData(change$, schemaTypes, keyGenerator) {
  return function withInsertData(editor) {
    const blockTypeName = schemaTypes.block.name;
    const spanTypeName = schemaTypes.span.name;
    const toPlainText = blocks => {
      return blocks.map(block => {
        var _a;
        if (editor.isTextBlock(block)) {
          return block.children.map(child => {
            var _a2;
            if (child._type === spanTypeName) {
              return child.text;
            }
            return "[".concat(((_a2 = schemaTypes.inlineObjects.find(t => t.name === child._type)) == null ? void 0 : _a2.title) || "Object", "]");
          }).join("");
        }
        return "[".concat(((_a = schemaTypes.blockObjects.find(t => t.name === block._type)) == null ? void 0 : _a.title) || "Object", "]");
      }).join("\n\n");
    };
    editor.setFragmentData = (data, originEvent) => {
      const {
        selection
      } = editor;
      if (!selection) {
        return;
      }
      const [start, end] = slate.Range.edges(selection);
      const startVoid = slate.Editor.void(editor, {
        at: start.path
      });
      const endVoid = slate.Editor.void(editor, {
        at: end.path
      });
      if (slate.Range.isCollapsed(selection) && !startVoid) {
        return;
      }
      const domRange = slateReact.ReactEditor.toDOMRange(editor, selection);
      let contents = domRange.cloneContents();
      if (endVoid) {
        const [voidNode] = endVoid;
        const r = domRange.cloneRange();
        const domNode = slateReact.ReactEditor.toDOMNode(editor, voidNode);
        r.setEndAfter(domNode);
        contents = r.cloneContents();
      }
      Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach(zw => {
        const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
        zw.textContent = isNewline ? "\n" : "";
      });
      Array.from(contents.querySelectorAll("*")).forEach(elm => {
        elm.removeAttribute("contentEditable");
        elm.removeAttribute("data-slate-inline");
        elm.removeAttribute("data-slate-leaf");
        elm.removeAttribute("data-slate-node");
        elm.removeAttribute("data-slate-spacer");
        elm.removeAttribute("data-slate-string");
        elm.removeAttribute("data-slate-zero-width");
        elm.removeAttribute("draggable");
        for (const key in elm.attributes) {
          if (elm.hasAttribute(key)) {
            elm.removeAttribute(key);
          }
        }
      });
      const div = contents.ownerDocument.createElement("div");
      div.appendChild(contents);
      div.setAttribute("hidden", "true");
      contents.ownerDocument.body.appendChild(div);
      const asHTML = div.innerHTML;
      contents.ownerDocument.body.removeChild(div);
      const fragment = editor.getFragment();
      const portableText = fromSlateValue(fragment, blockTypeName);
      const asJSON = JSON.stringify(portableText);
      const asPlainText = toPlainText(portableText);
      data.clearData();
      data.setData("text/plain", asPlainText);
      data.setData("text/html", asHTML);
      data.setData("application/json", asJSON);
      data.setData("application/x-portable-text", asJSON);
      debug$7("text", asPlainText);
      data.setData("application/x-portable-text-event-origin", originEvent || "external");
      debug$7("Set fragment data", asJSON, asHTML);
    };
    editor.insertPortableTextData = data => {
      var _a;
      if (!editor.selection) {
        return false;
      }
      const pText = data.getData("application/x-portable-text");
      const origin = data.getData("application/x-portable-text-event-origin");
      debug$7("Inserting portable text from ".concat(origin, " event"), pText);
      if (pText) {
        const parsed = JSON.parse(pText);
        if (Array.isArray(parsed) && parsed.length > 0) {
          const slateValue = _regenerateKeys(editor, toSlateValue(parsed, {
            schemaTypes
          }), keyGenerator, spanTypeName);
          const validation = validateValue(parsed, schemaTypes, keyGenerator);
          if (!validation.valid) {
            const errorDescription = "".concat((_a = validation.resolution) == null ? void 0 : _a.description);
            change$.next({
              type: "error",
              level: "warning",
              name: "pasteError",
              description: errorDescription,
              data: validation
            });
            debug$7("Invalid insert result", validation);
            return false;
          }
          _insertFragment(editor, slateValue, schemaTypes);
          return true;
        }
      }
      return false;
    };
    editor.insertTextOrHTMLData = data => {
      var _a;
      if (!editor.selection) {
        debug$7("No selection, not inserting");
        return false;
      }
      change$.next({
        type: "loading",
        isLoading: true
      });
      const html = data.getData("text/html");
      const text = data.getData("text/plain");
      if (html || text) {
        debug$7("Inserting data", data);
        let portableText;
        let fragment;
        let insertedType;
        if (html) {
          portableText = blockTools.htmlToBlocks(html, schemaTypes.portableText).map(block => blockTools.normalizeBlock(block, {
            blockTypeName
          }));
          fragment = toSlateValue(portableText, {
            schemaTypes
          });
          insertedType = "HTML";
        } else {
          const blocks = escapeHtml(text).split(/\n{2,}/).map(line => line ? "<p>".concat(line.replace(/(?:\r\n|\r|\n)/g, "<br/>"), "</p>") : "<p></p>").join("");
          const textToHtml = "<html><body>".concat(blocks, "</body></html>");
          portableText = blockTools.htmlToBlocks(textToHtml, schemaTypes.portableText).map(block => blockTools.normalizeBlock(block, {
            blockTypeName
          }));
          fragment = toSlateValue(portableText, {
            schemaTypes
          });
          insertedType = "text";
        }
        const validation = validateValue(portableText, schemaTypes, keyGenerator);
        if (!validation.valid) {
          const errorDescription = "Could not validate the resulting portable text to insert.\n".concat((_a = validation.resolution) == null ? void 0 : _a.description, "\nTry to insert as plain text (shift-paste) instead.");
          change$.next({
            type: "error",
            level: "warning",
            name: "pasteError",
            description: errorDescription,
            data: validation
          });
          debug$7("Invalid insert result", validation);
          return false;
        }
        debug$7("Inserting ".concat(insertedType, " fragment at ").concat(JSON.stringify(editor.selection)));
        _insertFragment(editor, fragment, schemaTypes);
        change$.next({
          type: "loading",
          isLoading: false
        });
        return true;
      }
      change$.next({
        type: "loading",
        isLoading: false
      });
      return false;
    };
    editor.insertData = data => {
      if (!editor.insertPortableTextData(data)) {
        editor.insertTextOrHTMLData(data);
      }
    };
    editor.insertFragmentData = data => {
      const fragment = data.getData("application/x-portable-text");
      if (fragment) {
        const parsed = JSON.parse(fragment);
        editor.insertFragment(parsed);
        return true;
      }
      return false;
    };
    return editor;
  };
}
const entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(str) {
  return String(str).replace(/[&<>"'`=/]/g, s => entityMap[s]);
}
function _regenerateKeys(editor, fragment, keyGenerator, spanTypeName) {
  return fragment.map(node => {
    const newNode = {
      ...node
    };
    if (editor.isTextBlock(newNode)) {
      newNode.markDefs = (newNode.markDefs || []).map(def => {
        const oldKey = def._key;
        const newKey = keyGenerator();
        newNode.children = newNode.children.map(child => child._type === spanTypeName && editor.isTextSpan(child) ? {
          ...child,
          marks: child.marks && child.marks.includes(oldKey) ?
          // eslint-disable-next-line max-nested-callbacks
          [...child.marks].filter(mark => mark !== oldKey).concat(newKey) : child.marks
        } : child);
        return {
          ...def,
          _key: newKey
        };
      });
    }
    const nodeWithNewKeys = {
      ...newNode,
      _key: keyGenerator()
    };
    if (editor.isTextBlock(nodeWithNewKeys)) {
      nodeWithNewKeys.children = nodeWithNewKeys.children.map(child => ({
        ...child,
        _key: keyGenerator()
      }));
    }
    return nodeWithNewKeys;
  });
}
function _insertFragment(editor, fragment, schemaTypes) {
  if (!editor.selection) {
    return;
  }
  const [focusBlock, focusPath] = slate.Editor.node(editor, editor.selection, {
    depth: 1
  });
  if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {
    const {
      markDefs
    } = focusBlock;
    debug$7("Mixing markDefs of focusBlock and fragments[0] block", markDefs, fragment[0].markDefs);
    if (!isEqual__default.default(markDefs, fragment[0].markDefs)) {
      slate.Transforms.setNodes(editor, {
        markDefs: uniq__default.default([...(fragment[0].markDefs || []), ...(markDefs || [])])
      }, {
        at: focusPath,
        mode: "lowest",
        voids: false
      });
    }
  }
  const isPasteToEmptyEditor = isEqualToEmptyEditor(editor.children, schemaTypes);
  if (isPasteToEmptyEditor) {
    slate.Transforms.splitNodes(editor, {
      at: [0, 0]
    });
    editor.insertFragment(fragment);
    slate.Transforms.removeNodes(editor, {
      at: [0]
    });
  } else {
    editor.insertFragment(fragment);
  }
  editor.onChange();
}
const originalFnMap = /* @__PURE__ */new WeakMap();
const withPlugins = (editor, options) => {
  const e = editor;
  const {
    keyGenerator,
    portableTextEditor,
    patches$,
    readOnly,
    maxBlocks,
    isPending
  } = options;
  const {
    schemaTypes,
    change$
  } = portableTextEditor;
  e.subscriptions = [];
  if (e.destroy) {
    e.destroy();
  } else {
    originalFnMap.set(e, {
      apply: e.apply,
      onChange: e.onChange,
      normalizeNode: e.normalizeNode
    });
  }
  const operationToPatches = createOperationToPatches(schemaTypes);
  const withObjectKeys = createWithObjectKeys(schemaTypes, keyGenerator);
  const withSchemaTypes = createWithSchemaTypes(schemaTypes);
  const withEditableAPI = createWithEditableAPI(portableTextEditor, schemaTypes, keyGenerator);
  const withPatches = createWithPatches({
    change$,
    isPending,
    keyGenerator,
    patches$,
    patchFunctions: operationToPatches,
    readOnly,
    schemaTypes
  });
  const withMaxBlocks = createWithMaxBlocks(maxBlocks || -1);
  const withPortableTextLists = createWithPortableTextLists(schemaTypes);
  const withUndoRedo = createWithUndoRedo({
    readOnly,
    patches$
  });
  const withPortableTextMarkModel = createWithPortableTextMarkModel(schemaTypes);
  const withPortableTextBlockStyle = createWithPortableTextBlockStyle(schemaTypes);
  const withPlaceholderBlock = createWithPlaceholderBlock({
    keyGenerator,
    schemaTypes
  });
  const withUtils = createWithUtils({
    keyGenerator,
    schemaTypes
  });
  const withPortableTextSelections = createWithPortableTextSelections(change$, schemaTypes);
  e.destroy = () => {
    const originalFunctions = originalFnMap.get(e);
    if (!originalFunctions) {
      throw new Error("Could not find pristine versions of editor functions");
    }
    e.onChange = originalFunctions.onChange;
    e.apply = originalFunctions.apply;
    e.normalizeNode = originalFunctions.normalizeNode;
  };
  if (readOnly) {
    return {
      editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPlaceholderBlock(withPortableTextLists(withPortableTextSelections(withEditableAPI(e))))))))),
      subscribe: () => noop__default.default
    };
  }
  return {
    editor: withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(withEditableAPI(e)))))))))))),
    subscribe: () => {
      const unsubscribes = [];
      editor.subscriptions.forEach(subscribeFn => {
        unsubscribes.push(subscribeFn());
      });
      return () => {
        unsubscribes.forEach(unsubscribeFn => {
          unsubscribeFn();
        });
      };
    }
  };
};
const debug$6 = debugWithName("component:PortableTextEditor:SlateContainer");
function SlateContainer(props) {
  const {
    patches$,
    portableTextEditor,
    readOnly,
    maxBlocks,
    keyGenerator,
    isPending
  } = props;
  const [slateEditor, subscribe] = React.useMemo(() => {
    debug$6("Creating new Slate editor instance");
    const {
      editor,
      subscribe: _sub
    } = withPlugins(slateReact.withReact(slate.createEditor()), {
      isPending,
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
    KEY_TO_VALUE_ELEMENT.set(editor, {});
    KEY_TO_SLATE_ELEMENT.set(editor, {});
    return [editor, _sub];
  }, []);
  React.useEffect(() => {
    const unsubscribe = subscribe();
    return () => {
      unsubscribe();
    };
  }, [subscribe]);
  React.useEffect(() => {
    debug$6("Re-initializing plugin chain");
    withPlugins(slateEditor, {
      isPending,
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
  }, [keyGenerator, portableTextEditor, maxBlocks, readOnly, patches$, slateEditor, isPending]);
  const initialValue = React.useMemo(() => {
    return [slateEditor.createPlaceholderBlock()];
  }, [slateEditor]);
  React.useEffect(() => {
    return () => {
      debug$6("Destroying Slate editor");
      slateEditor.destroy();
    };
  }, [slateEditor]);
  return /* @__PURE__ */jsxRuntime.jsx(slateReact.Slate, {
    editor: slateEditor,
    value: initialValue,
    children: props.children
  });
}
const FLUSH_PATCHES_DEBOUNCE_MS = process.env.NODE_ENV === "test" ? 100 : 1e3;
const PortableTextEditorSelectionContext = React.createContext(null);
const usePortableTextEditorSelection = () => {
  const selection = React.useContext(PortableTextEditorSelectionContext);
  if (selection === void 0) {
    throw new Error("The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return selection;
};
const PortableTextEditorContext = React.createContext(null);
const usePortableTextEditor = () => {
  const editor = React.useContext(PortableTextEditorContext);
  if (!editor) {
    throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return editor;
};
const PortableTextEditorValueContext = React.createContext(void 0);
const PortableTextEditorReadOnlyContext = React.createContext(false);
const usePortableTextEditorReadOnlyStatus = () => {
  const readOnly = React.useContext(PortableTextEditorReadOnlyContext);
  if (readOnly === void 0) {
    throw new Error("The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context.");
  }
  return readOnly;
};
const debug$5 = debugWithName("hook:useSyncValue");
function useSyncValue(props) {
  const {
    portableTextEditor,
    isPending,
    readOnly,
    keyGenerator
  } = props;
  const {
    change$,
    schemaTypes
  } = portableTextEditor;
  const previousValue = React.useRef();
  const slateEditor = slateReact.useSlate();
  return React.useMemo(() => value => {
    if (isPending.current && !readOnly) {
      debug$5("Has local patches");
      return;
    }
    if (previousValue.current === value) {
      debug$5("Value is the same object");
      change$.next({
        type: "value",
        value
      });
      return;
    }
    if (value && value.length === 0) {
      const validation = validateValue(value, schemaTypes, keyGenerator);
      change$.next({
        type: "invalidValue",
        resolution: validation.resolution,
        value
      });
      return;
    }
    let isChanged = false;
    let isValid = true;
    previousValue.current = value;
    if (!value || value.length === 0) {
      debug$5("Value is empty");
      withoutSaving(slateEditor, () => {
        withoutPatching(slateEditor, () => {
          slate.Editor.withoutNormalizing(slateEditor, () => {
            const hadSelection = !!slateEditor.selection;
            if (hadSelection) {
              slate.Transforms.deselect(slateEditor);
            }
            const childrenLength = slateEditor.children.length;
            slateEditor.children.forEach((_, index) => {
              slate.Transforms.removeNodes(slateEditor, {
                at: [childrenLength - 1 - index]
              });
            });
            slate.Transforms.insertNodes(slateEditor, slateEditor.createPlaceholderBlock(), {
              at: [0]
            });
            if (hadSelection) {
              slate.Transforms.select(slateEditor, [0, 0]);
            }
          });
        });
      });
      isChanged = true;
    }
    if (value && value.length > 0) {
      const slateValueFromProps = toSlateValue(value, {
        schemaTypes
      }, KEY_TO_SLATE_ELEMENT.get(slateEditor));
      withoutSaving(slateEditor, () => {
        withoutPatching(slateEditor, () => {
          slate.Editor.withoutNormalizing(slateEditor, () => {
            const childrenLength = slateEditor.children.length;
            if (slateValueFromProps.length < childrenLength) {
              for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--) {
                slate.Transforms.removeNodes(slateEditor, {
                  at: [i]
                });
              }
              isChanged = true;
            }
            slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {
              const oldBlock = slateEditor.children[currentBlockIndex];
              const hasChanges = oldBlock && !isEqual__default.default(currentBlock, oldBlock);
              if (hasChanges && isValid) {
                const validationValue = [value[currentBlockIndex]];
                const validation = validateValue(validationValue, schemaTypes, keyGenerator);
                if (validation.valid) {
                  if (oldBlock._key === currentBlock._key) {
                    debug$5("Updating block", oldBlock, currentBlock);
                    _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex);
                  } else {
                    debug$5("Replacing block", oldBlock, currentBlock);
                    _replaceBlock(slateEditor, currentBlock, currentBlockIndex);
                  }
                  isChanged = true;
                } else {
                  change$.next({
                    type: "invalidValue",
                    resolution: validation.resolution,
                    value
                  });
                  isValid = false;
                }
              }
              if (!oldBlock && isValid) {
                const validationValue = [value[currentBlockIndex]];
                const validation = validateValue(validationValue, schemaTypes, keyGenerator);
                debug$5("Validating and inserting new block in the end of the value", currentBlock);
                if (validation.valid) {
                  withPreserveKeys(slateEditor, () => {
                    slate.Transforms.insertNodes(slateEditor, currentBlock, {
                      at: [currentBlockIndex]
                    });
                  });
                } else {
                  change$.next({
                    type: "invalidValue",
                    resolution: validation.resolution,
                    value
                  });
                  isValid = false;
                }
              }
            });
          });
        });
      });
    }
    if (!isValid) {
      debug$5("Invalid value, returning");
      return;
    }
    if (isChanged) {
      debug$5("Server value changed, syncing editor");
      slate.Editor.normalize(slateEditor);
      slateEditor.onChange();
      change$.next({
        type: "value",
        value
      });
    } else {
      debug$5("Server value and editor value is the same, no need to sync.");
    }
  }, [change$, isPending, keyGenerator, readOnly, schemaTypes, slateEditor]);
}
function _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {
  const currentSelection = slateEditor.selection;
  const selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;
  if (selectionFocusOnBlock) {
    slate.Transforms.deselect(slateEditor);
  }
  slate.Transforms.removeNodes(slateEditor, {
    at: [currentBlockIndex]
  });
  withPreserveKeys(slateEditor, () => {
    slate.Transforms.insertNodes(slateEditor, currentBlock, {
      at: [currentBlockIndex]
    });
  });
  if (selectionFocusOnBlock) {
    slate.Transforms.select(slateEditor, currentSelection);
  }
}
function _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {
  slate.Transforms.setNodes(slateEditor, currentBlock, {
    at: [currentBlockIndex]
  });
  if (slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {
    const oldBlockChildrenLength = oldBlock.children.length;
    if (currentBlock.children.length < oldBlockChildrenLength) {
      Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {
        const childIndex = oldBlockChildrenLength - 1 - index;
        if (childIndex > 0) {
          debug$5("Removing child");
          slate.Transforms.removeNodes(slateEditor, {
            at: [currentBlockIndex, childIndex]
          });
        }
      });
    }
    currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {
      const oldBlockChild = oldBlock.children[currentBlockChildIndex];
      const isChildChanged = !isEqual__default.default(currentBlockChild, oldBlockChild);
      const isTextChanged = !isEqual__default.default(currentBlockChild.text, oldBlockChild == null ? void 0 : oldBlockChild.text);
      const path = [currentBlockIndex, currentBlockChildIndex];
      if (isChildChanged) {
        if (currentBlockChild._key === (oldBlockChild == null ? void 0 : oldBlockChild._key)) {
          debug$5("Updating changed child", currentBlockChild, oldBlockChild);
          slate.Transforms.setNodes(slateEditor, currentBlockChild, {
            at: path
          });
          const isSpanNode = slate.Text.isText(currentBlockChild) && currentBlockChild._type === "span" && slate.Text.isText(oldBlockChild) && oldBlockChild._type === "span";
          if (isSpanNode && isTextChanged) {
            slate.Transforms.delete(slateEditor, {
              at: {
                focus: {
                  path,
                  offset: 0
                },
                anchor: {
                  path,
                  offset: oldBlockChild.text.length
                }
              }
            });
            slate.Transforms.insertText(slateEditor, currentBlockChild.text, {
              at: path
            });
          } else if (!isSpanNode) {
            debug$5("Updating changed inline object child", currentBlockChild);
            slate.Transforms.setNodes(slateEditor, {
              _key: "".concat(currentBlock._key, "-void-child")
            }, {
              at: [...path, 0],
              voids: true
            });
          }
        } else if (oldBlockChild) {
          debug$5("Replacing child", currentBlockChild);
          slate.Transforms.removeNodes(slateEditor, {
            at: [currentBlockIndex, currentBlockChildIndex]
          });
          withPreserveKeys(slateEditor, () => {
            slate.Transforms.insertNodes(slateEditor, currentBlockChild, {
              at: [currentBlockIndex, currentBlockChildIndex]
            });
          });
        } else if (!oldBlockChild) {
          debug$5("Inserting new child", currentBlockChild);
          withPreserveKeys(slateEditor, () => {
            slate.Transforms.insertNodes(slateEditor, currentBlockChild, {
              at: [currentBlockIndex, currentBlockChildIndex]
            });
          });
        }
      }
    });
  }
}
const debug$4 = debugWithName("component:PortableTextEditor:Synchronizer");
function Synchronizer(props) {
  const {
    change$,
    portableTextEditor,
    isPending,
    onChange,
    keyGenerator,
    readOnly,
    value
  } = props;
  const [selection, setSelection] = React.useState(null);
  const pendingPatches = React.useRef([]);
  const syncValue = useSyncValue({
    isPending,
    keyGenerator,
    onChange,
    portableTextEditor,
    readOnly
  });
  const onFlushPendingPatches = React.useCallback(() => {
    const finalPatches = [...pendingPatches.current];
    debug$4("Flushing pending patches", finalPatches);
    if (finalPatches.length > 0) {
      pendingPatches.current = pendingPatches.current.splice(finalPatches.length, pendingPatches.current.length);
      const editorValue = PortableTextEditor.getValue(portableTextEditor);
      onChange({
        type: "mutation",
        patches: finalPatches,
        snapshot: editorValue
      });
    }
  }, [portableTextEditor, onChange]);
  const onFlushPendingPatchesDebounced = React.useMemo(() => debounce__default.default(onFlushPendingPatches, FLUSH_PATCHES_DEBOUNCE_MS, {
    leading: false,
    trailing: true
  }), [onFlushPendingPatches]);
  React.useEffect(() => {
    return () => {
      onFlushPendingPatches();
    };
  }, [onFlushPendingPatches]);
  React.useEffect(() => {
    debug$4("Subscribing to editor changes$");
    const sub = change$.subscribe(next => {
      switch (next.type) {
        case "patch":
          isPending.current = true;
          pendingPatches.current.push(next.patch);
          onChange(next);
          onFlushPendingPatchesDebounced();
          break;
        case "selection":
          React.startTransition(() => {
            debug$4("Setting selection");
            setSelection(next.selection);
          });
          onChange(next);
          break;
        default:
          onChange(next);
      }
    });
    return () => {
      debug$4("Unsubscribing to changes$");
      sub.unsubscribe();
    };
  }, [change$, onFlushPendingPatchesDebounced, onChange, syncValue, isPending]);
  const isInitialValueFromProps = React.useRef(true);
  React.useEffect(() => {
    debug$4("Value from props changed, syncing new value");
    syncValue(value);
    if (isInitialValueFromProps.current) {
      change$.next({
        type: "loading",
        isLoading: false
      });
      change$.next({
        type: "ready"
      });
      isInitialValueFromProps.current = false;
    }
  }, [change$, syncValue, value]);
  return /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorKeyGeneratorContext.Provider, {
    value: keyGenerator,
    children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorContext.Provider, {
      value: portableTextEditor,
      children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorValueContext.Provider, {
        value,
        children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorReadOnlyContext.Provider, {
          value: readOnly,
          children: /* @__PURE__ */jsxRuntime.jsx(PortableTextEditorSelectionContext.Provider, {
            value: selection,
            children: props.children
          })
        })
      })
    })
  });
}
const debug$3 = debugWithName("component:PortableTextEditor");
class PortableTextEditor extends React__default.default.Component {
  constructor(props) {
    super(props);
    /**
     * An observable of all the editor changes.
     */
    this.change$ = new rxjs.Subject();
    this.setEditable = editable => {
      this.editable = {
        ...this.editable,
        ...editable
      };
    };
    if (!props.schemaType) {
      throw new Error('PortableTextEditor: missing "type" property');
    }
    if (props.incomingPatches$) {
      console.warn("The prop 'incomingPatches$' is deprecated and renamed to 'patches$'");
    }
    this.change$.next({
      type: "loading",
      isLoading: true
    });
    this.isPending = React.createRef();
    this.isPending.current = false;
    this.schemaTypes = getPortableTextMemberSchemaTypes(props.schemaType.hasOwnProperty("jsonType") ? props.schemaType : compileType(props.schemaType));
  }
  componentDidUpdate(prevProps) {
    if (this.props.schemaType !== prevProps.schemaType) {
      this.schemaTypes = getPortableTextMemberSchemaTypes(this.props.schemaType.hasOwnProperty("jsonType") ? this.props.schemaType : compileType(this.props.schemaType));
    }
  }
  render() {
    const {
      onChange,
      value,
      children,
      patches$,
      incomingPatches$
    } = this.props;
    const {
      change$,
      isPending
    } = this;
    const _patches$ = incomingPatches$ || patches$;
    const maxBlocks = typeof this.props.maxBlocks === "undefined" ? void 0 : parseInt(this.props.maxBlocks.toString(), 10) || void 0;
    const readOnly = Boolean(this.props.readOnly);
    const keyGenerator = this.props.keyGenerator || defaultKeyGenerator;
    return /* @__PURE__ */jsxRuntime.jsx(SlateContainer, {
      isPending,
      keyGenerator,
      maxBlocks,
      patches$: _patches$,
      portableTextEditor: this,
      readOnly,
      children: /* @__PURE__ */jsxRuntime.jsx(Synchronizer, {
        change$,
        isPending,
        keyGenerator,
        onChange,
        portableTextEditor: this,
        readOnly,
        value,
        children
      })
    });
  }
}
// Static API methods
PortableTextEditor.activeAnnotations = editor => {
  return editor && editor.editable ? editor.editable.activeAnnotations() : [];
};
PortableTextEditor.addAnnotation = (editor, type, value) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.addAnnotation(type, value);
};
PortableTextEditor.blur = editor => {
  var _a;
  debug$3("Host blurred");
  (_a = editor.editable) == null ? void 0 : _a.blur();
};
PortableTextEditor.delete = (editor, selection, options) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.delete(selection, options);
};
PortableTextEditor.findDOMNode = (editor, element) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.findDOMNode(element);
};
PortableTextEditor.findByPath = (editor, path) => {
  var _a;
  return ((_a = editor.editable) == null ? void 0 : _a.findByPath(path)) || [];
};
PortableTextEditor.focus = editor => {
  var _a;
  debug$3("Host requesting focus");
  (_a = editor.editable) == null ? void 0 : _a.focus();
};
PortableTextEditor.focusBlock = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.focusBlock();
};
PortableTextEditor.focusChild = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.focusChild();
};
PortableTextEditor.getSelection = editor => {
  return editor.editable ? editor.editable.getSelection() : null;
};
PortableTextEditor.getValue = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.getValue();
};
PortableTextEditor.hasBlockStyle = (editor, blockStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.hasBlockStyle(blockStyle);
};
PortableTextEditor.hasListStyle = (editor, listStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.hasListStyle(listStyle);
};
PortableTextEditor.isCollapsedSelection = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isCollapsedSelection();
};
PortableTextEditor.isExpandedSelection = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isExpandedSelection();
};
PortableTextEditor.isMarkActive = (editor, mark) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isMarkActive(mark);
};
PortableTextEditor.insertChild = (editor, type, value) => {
  var _a;
  debug$3("Host inserting child");
  return (_a = editor.editable) == null ? void 0 : _a.insertChild(type, value);
};
PortableTextEditor.insertBlock = (editor, type, value) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.insertBlock(type, value);
};
PortableTextEditor.insertBreak = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.insertBreak();
};
PortableTextEditor.isVoid = (editor, element) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isVoid(element);
};
PortableTextEditor.isObjectPath = (editor, path) => {
  if (!path || !Array.isArray(path)) return false;
  const isChildObjectEditPath = path.length > 3 && path[1] === "children";
  const isBlockObjectEditPath = path.length > 1 && path[1] !== "children";
  return isBlockObjectEditPath || isChildObjectEditPath;
};
PortableTextEditor.marks = editor => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.marks();
};
PortableTextEditor.select = (editor, selection) => {
  var _a;
  debug$3("Host setting selection", selection);
  (_a = editor.editable) == null ? void 0 : _a.select(selection);
};
PortableTextEditor.removeAnnotation = (editor, type) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.removeAnnotation(type);
};
PortableTextEditor.toggleBlockStyle = (editor, blockStyle) => {
  var _a;
  debug$3("Host is toggling block style");
  return (_a = editor.editable) == null ? void 0 : _a.toggleBlockStyle(blockStyle);
};
PortableTextEditor.toggleList = (editor, listStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.toggleList(listStyle);
};
PortableTextEditor.toggleMark = (editor, mark) => {
  var _a;
  debug$3("Host toggling mark", mark);
  (_a = editor.editable) == null ? void 0 : _a.toggleMark(mark);
};
function compactPatches(patches) {
  const lastPatch = patches.slice(-1)[0];
  if (lastPatch && lastPatch.type === "unset" && lastPatch.path.length === 0) {
    return [lastPatch];
  }
  let finalPatches = patches;
  finalPatches = finalPatches.filter((patch, index) => {
    if (!patch) {
      return false;
    }
    const nextPatch = finalPatches[index + 1];
    if (nextPatch && nextPatch.type === "set" && patch.type === "set" && isEqual__default.default(patch.path, nextPatch.path)) {
      return false;
    }
    return true;
  });
  if (finalPatches.length !== patches.length) {
    return finalPatches;
  }
  return patches;
}
function normalizePoint(point, value) {
  if (!point || !value) {
    return null;
  }
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] === "object" && "_key" in point.path[0] && point.path[0]._key;
  const childKey = typeof point.path[2] === "object" && "_key" in point.path[2] && point.path[2]._key;
  const block = value.find(blk => blk._key === blockKey);
  if (block) {
    newPath.push({
      _key: block._key
    });
  } else {
    return null;
  }
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0) {
      return null;
    }
    const child = Array.isArray(block.children) && block.children.find(cld => cld._key === childKey);
    if (child) {
      newPath.push("children");
      newPath.push({
        _key: child._key
      });
      newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    } else {
      return null;
    }
  }
  return {
    path: newPath,
    offset: newOffset
  };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0) {
    return null;
  }
  let newAnchor = null;
  let newFocus = null;
  const {
    anchor,
    focus
  } = selection;
  if (anchor && value.find(blk => isEqual__default.default({
    _key: blk._key
  }, anchor.path[0]))) {
    newAnchor = normalizePoint(anchor, value);
  }
  if (focus && value.find(blk => isEqual__default.default({
    _key: blk._key
  }, focus.path[0]))) {
    newFocus = normalizePoint(focus, value);
  }
  if (newAnchor && newFocus) {
    return {
      anchor: newAnchor,
      focus: newFocus
    };
  }
  return null;
}
function DefaultAnnotation(props) {
  const handleClick = React.useCallback(() => alert(JSON.stringify(props.annotation)), [props.annotation]);
  return /* @__PURE__ */jsxRuntime.jsx("span", {
    style: {
      color: "blue"
    },
    onClick: handleClick,
    children: props.children
  });
}
const debug$2 = debugWithName("components:Leaf");
const EMPTY_MARKS = [];
const Leaf = props => {
  const {
    attributes,
    children,
    leaf,
    schemaTypes,
    renderChild,
    renderDecorator,
    renderAnnotation
  } = props;
  const spanRef = React__default.default.useRef(null);
  const portableTextEditor = usePortableTextEditor();
  const blockSelected = slateReact.useSelected();
  const [focused, setFocused] = React.useState(false);
  const [selected, setSelected] = React.useState(false);
  const block = children.props.parent;
  const path = React.useMemo(() => block ? [{
    _key: block == null ? void 0 : block._key
  }, "children", {
    _key: leaf._key
  }] : [], [block, leaf._key]);
  const decoratorValues = React.useMemo(() => schemaTypes.decorators.map(dec => dec.value), [schemaTypes.decorators]);
  const marks = React.useMemo(() => uniq__default.default((leaf.marks || EMPTY_MARKS).filter(mark => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]);
  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS;
  const annotations = React.useMemo(() => annotationMarks.map(mark => {
    var _a;
    return !decoratorValues.includes(mark) && ((_a = block == null ? void 0 : block.markDefs) == null ? void 0 : _a.find(def => def._key === mark));
  }).filter(Boolean), [annotationMarks, block, decoratorValues]);
  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;
  React.useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      setFocused(false);
      return;
    }
    const sel = PortableTextEditor.getSelection(portableTextEditor);
    if (sel && isEqual__default.default(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
      React.startTransition(() => {
        setFocused(true);
      });
    }
  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);
  const setSelectedFromRange = React.useCallback(() => {
    if (!shouldTrackSelectionAndFocus) {
      return;
    }
    debug$2("Setting selection and focus from range");
    const winSelection = window.getSelection();
    if (!winSelection) {
      setSelected(false);
      return;
    }
    if (winSelection && winSelection.rangeCount > 0) {
      const range = winSelection.getRangeAt(0);
      if (spanRef.current && range.intersectsNode(spanRef.current)) {
        setSelected(true);
      } else {
        setSelected(false);
      }
    } else {
      setSelected(false);
    }
  }, [shouldTrackSelectionAndFocus]);
  React.useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      return void 0;
    }
    const sub = portableTextEditor.change$.subscribe(next => {
      if (next.type === "blur") {
        setFocused(false);
        setSelected(false);
        return;
      }
      if (next.type === "focus") {
        const sel = PortableTextEditor.getSelection(portableTextEditor);
        if (sel && isEqual__default.default(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
          setFocused(true);
        }
        setSelectedFromRange();
        return;
      }
      if (next.type === "selection") {
        if (next.selection && isEqual__default.default(next.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor)) {
          setFocused(true);
        } else {
          setFocused(false);
        }
        setSelectedFromRange();
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]);
  React.useEffect(() => setSelectedFromRange(), [setSelectedFromRange]);
  const content = React.useMemo(() => {
    let returnedChildren = children;
    if (slate.Text.isText(leaf) && leaf._type === schemaTypes.span.name) {
      marks.forEach(mark => {
        const schemaType = schemaTypes.decorators.find(dec => dec.value === mark);
        if (schemaType && renderDecorator) {
          const _props = Object.defineProperty({
            children: returnedChildren,
            editorElementRef: spanRef,
            focused,
            path,
            selected,
            schemaType,
            value: mark
          }, "type", {
            enumerable: false,
            get() {
              console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
              return schemaType;
            }
          });
          returnedChildren = renderDecorator(_props);
        }
      });
      if (block && annotations.length > 0) {
        annotations.forEach(annotation => {
          const schemaType = schemaTypes.annotations.find(t => t.name === annotation._type);
          if (schemaType) {
            if (renderAnnotation) {
              const _props = Object.defineProperty({
                block,
                children: returnedChildren,
                editorElementRef: spanRef,
                focused,
                path,
                selected,
                schemaType,
                value: annotation
              }, "type", {
                enumerable: false,
                get() {
                  console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
                  return schemaType;
                }
              });
              returnedChildren = /* @__PURE__ */jsxRuntime.jsx("span", {
                ref: spanRef,
                children: renderAnnotation(_props)
              });
            } else {
              returnedChildren = /* @__PURE__ */jsxRuntime.jsx(DefaultAnnotation, {
                annotation,
                children: /* @__PURE__ */jsxRuntime.jsx("span", {
                  ref: spanRef,
                  children: returnedChildren
                })
              });
            }
          }
        });
      }
      if (block && renderChild) {
        const child = block.children.find(_child => _child._key === leaf._key);
        if (child) {
          const defaultRendered = /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
            children: returnedChildren
          });
          const _props = Object.defineProperty({
            annotations,
            children: defaultRendered,
            editorElementRef: spanRef,
            focused,
            path,
            schemaType: schemaTypes.span,
            selected,
            value: child
          }, "type", {
            enumerable: false,
            get() {
              console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
              return schemaTypes.span;
            }
          });
          returnedChildren = renderChild(_props);
        }
      }
    }
    return returnedChildren;
  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);
  return React.useMemo(() => /* @__PURE__ */jsxRuntime.jsx("span", {
    ...attributes,
    ref: spanRef,
    children: content
  }, leaf._key), [leaf, attributes, content]);
};
const DefaultObject = props => {
  return /* @__PURE__ */jsxRuntime.jsx("div", {
    children: /* @__PURE__ */jsxRuntime.jsx("pre", {
      children: JSON.stringify(props.value, null, 2)
    })
  });
};
const DefaultBlockObject = styled__default.default.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  user-select: none;\n  border: ", ";\n"])), props => {
  if (props.selected) {
    return "1px solid blue";
  }
  return "1px solid transparent";
});
styled__default.default.span(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  background: #999;\n  border: ", ";\n"])), props => {
  if (props.selected) {
    return "1px solid blue";
  }
  return "1px solid transparent";
});
const DefaultListItem = styled__default.default.div(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ", ";\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '", "';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ", ";\n    counter-reset: ", ";\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ", ";\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n"])), props => getLeftPositionForListLevel(props.listLevel), props => getContentForListLevelAndStyle(props.listLevel, props.listStyle), props => getCounterIncrementForListLevel(props.listLevel), props => getCounterResetForListLevel(props.listLevel), props => getCounterContentForListLevel(props.listLevel));
const DefaultListItemInner = styled__default.default.div(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([""])));
function getLeftPositionForListLevel(level) {
  switch (Number(level)) {
    case 1:
      return "1.5em";
    case 2:
      return "3em";
    case 3:
      return "4.5em";
    case 4:
      return "6em";
    case 5:
      return "7.5em";
    case 6:
      return "9em";
    case 7:
      return "10.5em";
    case 8:
      return "12em";
    case 9:
      return "13.5em";
    case 10:
      return "15em";
    default:
      return "0em";
  }
}
const bullets = ["\u25CF", "\u25CB", "\u25A0"];
function getContentForListLevelAndStyle(level, style) {
  const normalizedLevel = (level - 1) % 3;
  if (style === "bullet") {
    return bullets[normalizedLevel];
  }
  return "*";
}
function getCounterIncrementForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemNumber";
    case 2:
      return "listItemAlpha";
    case 3:
      return "listItemRoman";
    case 4:
      return "listItemNumberNext";
    case 5:
      return "listItemLetterNext";
    case 6:
      return "listItemRomanNext";
    case 7:
      return "listItemNumberNextNext";
    case 8:
      return "listItemAlphaNextNext";
    case 9:
      return "listItemRomanNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterResetForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemAlpha";
    case 2:
      return "listItemRoman";
    case 3:
      return "listItemNumberNext";
    case 4:
      return "listItemLetterNext";
    case 5:
      return "listItemRomanNext";
    case 6:
      return "listItemNumberNextNext";
    case 7:
      return "listItemAlphaNextNext";
    case 8:
      return "listItemRomanNextNext";
    case 9:
      return "listItemNumberNextNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterContentForListLevel(level) {
  switch (level) {
    case 1:
      return "counter(listItemNumber) '. '";
    case 2:
      return "counter(listItemAlpha, lower-alpha) '. '";
    case 3:
      return "counter(listItemRoman, lower-roman) '. '";
    case 4:
      return "counter(listItemNumberNext) '. '";
    case 5:
      return "counter(listItemLetterNext, lower-alpha) '. '";
    case 6:
      return "counter(listItemRomanNext, lower-roman) '. '";
    case 7:
      return "counter(listItemNumberNextNext) '. '";
    case 8:
      return "counter(listItemAlphaNextNext, lower-alpha) '. '";
    case 9:
      return "counter(listItemRomanNextNext, lower-roman) '. '";
    default:
      return "counter(listItemNumberNextNextNext) '. '";
  }
}
const debug$1 = debugWithName("components:DraggableBlock");
const DraggableBlock = _ref17 => {
  let {
    children,
    element,
    readOnly,
    blockRef
  } = _ref17;
  const editor = slateReact.useSlateStatic();
  const dragGhostRef = React.useRef();
  const [isDragOver, setIsDragOver] = React.useState(false);
  const isVoid = React.useMemo(() => slate.Editor.isVoid(editor, element), [editor, element]);
  const isInline = React.useMemo(() => slate.Editor.isInline(editor, element), [editor, element]);
  const [blockElement, setBlockElement] = React.useState(null);
  React.useEffect(() => setBlockElement(blockRef ? blockRef.current : slateReact.ReactEditor.toDOMNode(editor, element)), [editor, element, blockRef]);
  const handleDragOver = React.useCallback(event => {
    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
    if (!isMyDragOver || !blockElement) {
      return;
    }
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
    const elementRect = blockElement.getBoundingClientRect();
    const offset = elementRect.top;
    const height = elementRect.height;
    const Y = event.pageY;
    const loc = Math.abs(offset - Y);
    let position = "bottom";
    if (element === editor.children[0]) {
      position = "top";
    } else if (loc < height / 2) {
      position = "top";
      IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
    } else {
      position = "bottom";
      IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
    }
    if (isMyDragOver === element) {
      event.dataTransfer.dropEffect = "none";
      return;
    }
    setIsDragOver(true);
  }, [blockElement, editor, element]);
  const handleDragLeave = React.useCallback(() => {
    setIsDragOver(false);
  }, []);
  const handleDragEnd = React.useCallback(event => {
    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
    if (targetBlock) {
      IS_DRAGGING.set(editor, false);
      event.preventDefault();
      event.stopPropagation();
      IS_DRAGGING_ELEMENT_TARGET.delete(editor);
      if (dragGhostRef.current) {
        debug$1("Removing drag ghost");
        document.body.removeChild(dragGhostRef.current);
      }
      const dragPosition2 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
      let targetPath = slateReact.ReactEditor.findPath(editor, targetBlock);
      const myPath = slateReact.ReactEditor.findPath(editor, element);
      const isBefore = slate.Path.isBefore(myPath, targetPath);
      if (dragPosition2 === "bottom" && !isBefore) {
        if (targetPath[0] >= editor.children.length - 1) {
          debug$1("target is already at the bottom, not moving");
          return;
        }
        const originalPath = targetPath;
        targetPath = slate.Path.next(targetPath);
        debug$1("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
      }
      if (dragPosition2 === "top" && isBefore && targetPath[0] !== editor.children.length - 1) {
        const originalPath = targetPath;
        targetPath = slate.Path.previous(targetPath);
        debug$1("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
      }
      if (slate.Path.equals(targetPath, myPath)) {
        event.preventDefault();
        debug$1("targetPath and myPath is the same, not moving");
        return;
      }
      debug$1("Moving element ".concat(element._key, " from path ").concat(JSON.stringify(myPath), " to ").concat(JSON.stringify(targetPath), " (").concat(dragPosition2, ")"));
      slate.Transforms.moveNodes(editor, {
        at: myPath,
        to: targetPath
      });
      editor.onChange();
      return;
    }
    debug$1("No target element, not doing anything");
  }, [editor, element]);
  const handleDrop = React.useCallback(event => {
    if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {
      debug$1("On drop (prevented)", element);
      event.preventDefault();
      event.stopPropagation();
      setIsDragOver(false);
    }
  }, [editor, element]);
  const handleDrag = React.useCallback(event => {
    if (!isVoid) {
      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
      return;
    }
    IS_DRAGGING.set(editor, true);
    IS_DRAGGING_BLOCK_ELEMENT.set(editor, element);
    event.stopPropagation();
    const target = event.target;
    if (target instanceof HTMLElement) {
      target.style.opacity = "1";
    }
  }, [editor, element, isVoid]);
  const handleDragStart = React.useCallback(event => {
    if (!isVoid || isInline) {
      debug$1("Not dragging block");
      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
      IS_DRAGGING.set(editor, false);
      return;
    }
    debug$1("Drag start");
    IS_DRAGGING.set(editor, true);
    if (event.dataTransfer) {
      event.dataTransfer.setData("application/portable-text", "something");
      event.dataTransfer.effectAllowed = "move";
    }
    if (blockElement && blockElement instanceof HTMLElement) {
      let dragGhost = blockElement.cloneNode(true);
      const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
      if (customGhost) {
        dragGhost = customGhost;
      }
      dragGhost.setAttribute("data-dragged", "");
      if (document.body) {
        dragGhostRef.current = dragGhost;
        dragGhost.style.position = "absolute";
        dragGhost.style.left = "-99999px";
        dragGhost.style.boxSizing = "border-box";
        document.body.appendChild(dragGhost);
        const rect = blockElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        dragGhost.style.width = "".concat(rect.width, "px");
        dragGhost.style.height = "".concat(rect.height, "px");
        event.dataTransfer.setDragImage(dragGhost, x, y);
      }
    }
    handleDrag(event);
  }, [blockElement, editor, handleDrag, isInline, isVoid]);
  const isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
  const isDraggingOverLastBlock = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
  const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
  const isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "top";
  const isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "bottom";
  const dropIndicator = React.useMemo(() => /* @__PURE__ */jsxRuntime.jsx("div", {
    className: "pt-drop-indicator",
    style: {
      position: "absolute",
      width: "100%",
      height: 1,
      borderBottom: "1px solid currentColor",
      zIndex: 5
    }
  }), []);
  if (readOnly) {
    return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children
    });
  }
  return /* @__PURE__ */jsxRuntime.jsxs("div", {
    draggable: isVoid,
    onDragStart: handleDragStart,
    onDrag: handleDrag,
    onDragOver: handleDragOver,
    onDragLeave: handleDragLeave,
    onDragEnd: handleDragEnd,
    onDrop: handleDrop,
    children: [isDraggingOverTop && dropIndicator, children, isDraggingOverBottom && dropIndicator]
  });
};
debugWithName("components:Element");
const EMPTY_ANNOTATIONS = [];
const inlineBlockStyle = {
  display: "inline-block"
};
const Element = _ref18 => {
  let {
    attributes,
    children,
    element,
    schemaTypes,
    readOnly,
    renderBlock,
    renderChild,
    renderListItem,
    renderStyle,
    spellCheck
  } = _ref18;
  const editor = slateReact.useSlateStatic();
  const selected = slateReact.useSelected();
  const blockRef = React.useRef(null);
  const inlineBlockObjectRef = React.useRef(null);
  const focused = selected && editor.selection && slate.Range.isCollapsed(editor.selection) || false;
  const value = React.useMemo(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);
  let renderedBlock = children;
  let className;
  const blockPath = React.useMemo(() => [{
    _key: element._key
  }], [element]);
  if (typeof element._type !== "string") {
    throw new Error("Expected element to have a _type property");
  }
  if (typeof element._key !== "string") {
    throw new Error("Expected element to have a _key property");
  }
  if (editor.isInline(element)) {
    const path = slateReact.ReactEditor.findPath(editor, element);
    const [block2] = slate.Editor.node(editor, path, {
      depth: 1
    });
    const schemaType2 = schemaTypes.inlineObjects.find(_type => _type.name === element._type);
    if (!schemaType2) {
      throw new Error("Could not find type for inline block element");
    }
    if (slate.Element.isElement(block2)) {
      const elmPath = [{
        _key: block2._key
      }, "children", {
        _key: element._key
      }];
      return /* @__PURE__ */jsxRuntime.jsxs("span", {
        ...attributes,
        children: [children, /* @__PURE__ */jsxRuntime.jsxs("span", {
          draggable: !readOnly,
          className: "pt-inline-object",
          ref: inlineBlockObjectRef,
          style: inlineBlockStyle,
          contentEditable: false,
          children: [renderChild && renderChild({
            annotations: EMPTY_ANNOTATIONS,
            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.
            children: /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
              value
            }),
            editorElementRef: inlineBlockObjectRef,
            focused,
            path: elmPath,
            schemaType: schemaType2,
            selected,
            type: schemaType2,
            value
          }), !renderChild && /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
            value
          })]
        }, element._key)]
      });
    }
    throw new Error("Block not found!");
  }
  if (element._type === schemaTypes.block.name) {
    className = "pt-block pt-text-block";
    const isListItem = ("listItem" in element);
    const style = "style" in element && element.style || "normal";
    className = "pt-block pt-text-block pt-text-block-style-".concat(style);
    const blockStyleType = schemaTypes.styles.find(item => item.value === style);
    if (renderStyle && blockStyleType) {
      renderedBlock = renderStyle({
        block: element,
        children,
        focused,
        selected,
        value: style,
        path: blockPath,
        schemaType: blockStyleType,
        editorElementRef: blockRef
      });
    }
    let level;
    if (isListItem) {
      if (typeof element.level === "number") {
        level = element.level;
      }
      className += " pt-list-item pt-list-item-".concat(element.listItem, " pt-list-item-level-").concat(level || 1);
    }
    if (editor.isListBlock(value) && isListItem && element.listItem) {
      const listType = schemaTypes.lists.find(item => item.value === element.listItem);
      if (renderListItem && listType) {
        renderedBlock = renderListItem({
          block: value,
          children: renderedBlock,
          focused,
          selected,
          value: element.listItem,
          path: blockPath,
          schemaType: listType,
          level: value.level || 1,
          editorElementRef: blockRef
        });
      } else {
        renderedBlock = /* @__PURE__ */jsxRuntime.jsx(DefaultListItem, {
          listStyle: value.listItem || schemaTypes.lists[0].value,
          listLevel: value.level || 1,
          children: /* @__PURE__ */jsxRuntime.jsx(DefaultListItemInner, {
            children: renderedBlock
          })
        });
      }
    }
    const renderProps = Object.defineProperty({
      children: renderedBlock,
      editorElementRef: blockRef,
      focused,
      level,
      listItem: isListItem ? element.listItem : void 0,
      path: blockPath,
      selected,
      style,
      schemaType: schemaTypes.block,
      value
    }, "type", {
      enumerable: false,
      get() {
        console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
        return schemaTypes.block;
      }
    });
    const propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;
    return /* @__PURE__ */jsxRuntime.jsx("div", {
      ...attributes,
      className,
      spellCheck,
      children: /* @__PURE__ */jsxRuntime.jsx(DraggableBlock, {
        element,
        readOnly,
        blockRef,
        children: /* @__PURE__ */jsxRuntime.jsx("div", {
          ref: blockRef,
          children: propsOrDefaultRendered
        })
      })
    }, element._key);
  }
  const schemaType = schemaTypes.blockObjects.find(_type => _type.name === element._type);
  if (!schemaType) {
    throw new Error("Could not find schema type for block element of _type ".concat(element._type));
  }
  className = "pt-block pt-object-block";
  const block = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
  let renderedBlockFromProps;
  if (renderBlock) {
    const _props = Object.defineProperty({
      children: /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
        value
      }),
      editorElementRef: blockRef,
      focused,
      path: blockPath,
      schemaType,
      selected,
      value: block
    }, "type", {
      enumerable: false,
      get() {
        console.warn("Property 'type' is deprecated, use 'schemaType' instead.");
        return schemaType;
      }
    });
    renderedBlockFromProps = renderBlock(_props);
  }
  return /* @__PURE__ */jsxRuntime.jsxs("div", {
    ...attributes,
    className,
    children: [children, /* @__PURE__ */jsxRuntime.jsxs(DraggableBlock, {
      element,
      readOnly,
      blockRef,
      children: [renderedBlockFromProps && /* @__PURE__ */jsxRuntime.jsx("div", {
        ref: blockRef,
        contentEditable: false,
        children: renderedBlockFromProps
      }), !renderedBlockFromProps && /* @__PURE__ */jsxRuntime.jsx(DefaultBlockObject, {
        selected,
        children: /* @__PURE__ */jsxRuntime.jsx(DefaultObject, {
          value
        })
      })]
    })]
  }, element._key);
};
const useIsomorphicEffect = typeof window === "undefined" ? React.useEffect : React.useLayoutEffect;
function useForwardedRef(ref) {
  const innerRef = React.useRef(null);
  useIsomorphicEffect(() => {
    if (!ref) return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
const debug = debugWithName("component:Editable");
const PLACEHOLDER_STYLE = {
  opacity: 0.5,
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none"
};
const EMPTY_DECORATORS = [];
const PortableTextEditable = React.forwardRef(function PortableTextEditable2(props, forwardedRef) {
  const {
    hotkeys,
    onBeforeInput,
    onPaste,
    onCopy,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator,
    renderListItem,
    renderPlaceholder,
    renderStyle,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props;
  const portableTextEditor = usePortableTextEditor();
  const readOnly = usePortableTextEditorReadOnlyStatus();
  const keyGenerator = usePortableTextEditorKeyGenerator();
  const ref = useForwardedRef(forwardedRef);
  const [hasInvalidValue, setHasInvalidValue] = React.useState(false);
  const {
    change$,
    schemaTypes
  } = portableTextEditor;
  const slateEditor = slateReact.useSlate();
  const blockTypeName = schemaTypes.block.name;
  const withInsertData = React.useMemo(() => createWithInsertData(change$, schemaTypes, keyGenerator), [change$, keyGenerator, schemaTypes]);
  const withHotKeys = React.useMemo(() => createWithHotkeys(schemaTypes, keyGenerator, portableTextEditor, hotkeys), [hotkeys, keyGenerator, portableTextEditor, schemaTypes]);
  React.useMemo(() => {
    if (readOnly) {
      debug("Editable is in read only mode");
      return withInsertData(slateEditor);
    }
    debug("Editable is in edit mode");
    return withInsertData(withHotKeys(slateEditor));
  }, [readOnly, slateEditor, withHotKeys, withInsertData]);
  const renderElement = React.useCallback(eProps => /* @__PURE__ */jsxRuntime.jsx(Element, {
    ...eProps,
    readOnly,
    renderBlock,
    renderChild,
    renderListItem,
    renderStyle,
    schemaTypes,
    spellCheck
  }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]);
  const renderLeaf = React.useCallback(lProps => {
    const rendered = /* @__PURE__ */jsxRuntime.jsx(Leaf, {
      ...lProps,
      schemaTypes,
      renderAnnotation,
      renderChild,
      renderDecorator,
      readOnly
    });
    if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === "") {
      return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/* @__PURE__ */jsxRuntime.jsx("div", {
          style: PLACEHOLDER_STYLE,
          contentEditable: false,
          children: renderPlaceholder()
        }), rendered]
      });
    }
    return rendered;
  }, [readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]);
  const restoreSelectionFromProps = React.useCallback(() => {
    if (propsSelection) {
      debug("Selection from props ".concat(JSON.stringify(propsSelection)));
      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));
      if (normalizedSelection !== null) {
        debug("Normalized selection from props ".concat(JSON.stringify(normalizedSelection)));
        const slateRange = toSlateRange(normalizedSelection, slateEditor);
        if (slateRange) {
          slate.Transforms.select(slateEditor, slateRange);
          if (!slateEditor.operations.some(o => o.type === "set_selection")) {
            change$.next({
              type: "selection",
              selection: normalizedSelection
            });
          }
          slateEditor.onChange();
        }
      }
    }
  }, [propsSelection, slateEditor, blockTypeName, change$]);
  React.useEffect(() => {
    debug("Subscribing to editor changes$");
    const sub = change$.subscribe(next => {
      switch (next.type) {
        case "ready":
          restoreSelectionFromProps();
          break;
        case "invalidValue":
          setHasInvalidValue(true);
          break;
        case "value":
          setHasInvalidValue(false);
          break;
      }
    });
    return () => {
      debug("Unsubscribing to changes$");
      sub.unsubscribe();
    };
  }, [change$, restoreSelectionFromProps]);
  React.useEffect(() => {
    if (propsSelection && !hasInvalidValue) {
      restoreSelectionFromProps();
    }
  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);
  const handleCopy = React.useCallback(event => {
    if (onCopy) {
      const result = onCopy(event);
      if (result !== void 0) {
        event.preventDefault();
      }
    }
  }, [onCopy]);
  const handlePaste = React.useCallback(event => {
    event.preventDefault();
    if (!slateEditor.selection) {
      return;
    }
    if (!onPaste) {
      debug("Pasting normally");
      slateEditor.insertData(event.clipboardData);
      return;
    }
    new Promise(resolve => {
      const value = PortableTextEditor.getValue(portableTextEditor);
      const ptRange = toPortableTextRange(value, slateEditor.selection, schemaTypes);
      const path = (ptRange == null ? void 0 : ptRange.focus.path) || [];
      resolve(onPaste({
        event,
        value,
        path,
        schemaTypes
      }));
    }).then(result => {
      debug("Custom paste function from client resolved", result);
      change$.next({
        type: "loading",
        isLoading: true
      });
      if (!result || !result.insert) {
        debug("No result from custom paste handler, pasting normally");
        slateEditor.insertData(event.clipboardData);
        return;
      }
      if (result && result.insert) {
        slateEditor.insertFragment(toSlateValue(result.insert, {
          schemaTypes
        }));
        change$.next({
          type: "loading",
          isLoading: false
        });
        return;
      }
      console.warn("Your onPaste function returned something unexpected:", result);
    }).catch(error => {
      change$.next({
        type: "loading",
        isLoading: false
      });
      console.error(error);
      return error;
    });
  }, [change$, onPaste, portableTextEditor, schemaTypes, slateEditor]);
  const handleOnFocus = React.useCallback(event => {
    const selection = PortableTextEditor.getSelection(portableTextEditor);
    change$.next({
      type: "focus",
      event
    });
    const newSelection = PortableTextEditor.getSelection(portableTextEditor);
    if (selection === newSelection) {
      change$.next({
        type: "selection",
        selection
      });
    }
  }, [change$, portableTextEditor]);
  const handleOnBlur = React.useCallback(event => {
    change$.next({
      type: "blur",
      event
    });
  }, [change$]);
  const handleOnBeforeInput = React.useCallback(event => {
    if (onBeforeInput) {
      onBeforeInput(event);
    }
  }, [onBeforeInput]);
  const handleKeyDown = slateEditor.pteWithHotKeys;
  const scrollSelectionIntoViewToSlate = React.useMemo(() => {
    if (scrollSelectionIntoView === void 0) {
      return void 0;
    }
    if (scrollSelectionIntoView === null) {
      return noop__default.default;
    }
    return (editor, domRange) => {
      scrollSelectionIntoView(portableTextEditor, domRange);
    };
  }, [portableTextEditor, scrollSelectionIntoView]);
  const decorate = React.useCallback(() => {
    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {
      return [{
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        },
        placeholder: true
      }];
    }
    return EMPTY_DECORATORS;
  }, [schemaTypes, slateEditor]);
  const slateEditable = React.useMemo(() => /* @__PURE__ */jsxRuntime.jsx(slateReact.Editable, {
    autoFocus: false,
    className: "pt-editable",
    decorate,
    onBlur: handleOnBlur,
    onCopy: handleCopy,
    onDOMBeforeInput: handleOnBeforeInput,
    onFocus: handleOnFocus,
    onKeyDown: handleKeyDown,
    onPaste: handlePaste,
    readOnly,
    renderElement,
    renderLeaf,
    scrollSelectionIntoView: scrollSelectionIntoViewToSlate
  }), [decorate, handleCopy, handleKeyDown, handleOnBeforeInput, handleOnBlur, handleOnFocus, handlePaste, readOnly, renderElement, renderLeaf, scrollSelectionIntoViewToSlate]);
  if (!portableTextEditor) {
    return null;
  }
  return /* @__PURE__ */jsxRuntime.jsx("div", {
    ref,
    ...restProps,
    children: hasInvalidValue ? null : slateEditable
  });
});
exports.PortableTextEditable = PortableTextEditable;
exports.PortableTextEditor = PortableTextEditor;
exports.compactPatches = compactPatches;
exports.keyGenerator = defaultKeyGenerator;
exports.usePortableTextEditor = usePortableTextEditor;
exports.usePortableTextEditorSelection = usePortableTextEditorSelection;
//# sourceMappingURL=index.js.map
