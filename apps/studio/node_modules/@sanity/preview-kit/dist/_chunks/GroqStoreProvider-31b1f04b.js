import { jsx } from 'react/jsx-runtime';
import DefaultEventSource from '@sanity/eventsource';
import { groqStore } from '@sanity/groq-store';
import { memo, useState, useMemo, useEffect } from 'react';
import { useLoadingListenersContext, DEFAULT_MAX_DOCUMENTS, getQueryCacheKey, defineListenerContext, LoadedListenersContext } from './context-13c019e1.js';
const GroqStoreProvider = memo(function GroqStoreProvider2(props) {
  const {
    children,
    logger,
    // The rest is the store config
    ...config
  } = props;
  const [ready] = useState(() => /* @__PURE__ */new Set());
  const [loadedListenersContext, updateLoadedListeners] = useLoadingListenersContext(ready);
  const [snapshots] = useState(() => /* @__PURE__ */new Map());
  const [store] = useState(() => groqStore({
    // Override some of the store defaults
    EventSource: props.token ? DefaultEventSource : void 0,
    listen: true,
    overlayDrafts: true,
    documentLimit: DEFAULT_MAX_DOCUMENTS,
    // Spread in the rest
    ...config
  }));
  const report = useMemo(() => {
    if (config.listen) {
      return "Updates are applied in real-time. The cache is set to max ".concat(config.documentLimit, " documents.");
    }
    return "Updates require a manual refresh. The cache is set to max ".concat(config.documentLimit, " documents.");
  }, [config.documentLimit, config.listen]);
  useEffect(() => {
    if (logger) {
      logger.log("[@sanity/preview-kit]: With the current configuration you can expect that: ".concat(report));
    }
  }, [logger, report]);
  const [error, setError] = useState(null);
  if (error) throw error;
  const [listenerContext] = useState(() => {
    return function defineListener(initialSnapshot, query, params) {
      const key = getQueryCacheKey(query, params);
      if (!snapshots.has(key)) {
        snapshots.set(key, initialSnapshot);
      }
      const subscribe = onStoreChange => {
        if (!ready.has(key)) {
          store.query(query, params).then(result => {
            if (!ready.has(key)) {
              snapshots.set(key, result);
              ready.add(key);
              updateLoadedListeners();
              onStoreChange();
            }
          }, setError);
        }
        const subscription = store.subscribe(query, params, (err, result) => {
          if (err) {
            setError(err);
          } else if (ready.has(key)) {
            snapshots.set(key, result);
            onStoreChange();
          }
        });
        return () => subscription.unsubscribe();
      };
      const getSnapshot = () => snapshots.get(key);
      return {
        subscribe,
        getSnapshot
      };
    };
  });
  return /* @__PURE__ */jsx(defineListenerContext.Provider, {
    value: listenerContext,
    children: /* @__PURE__ */jsx(LoadedListenersContext.Provider, {
      value: loadedListenersContext,
      children
    })
  });
});
export { GroqStoreProvider };
//# sourceMappingURL=GroqStoreProvider-31b1f04b.js.map
