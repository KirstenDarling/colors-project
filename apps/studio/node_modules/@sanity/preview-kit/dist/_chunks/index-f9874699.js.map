{"version":3,"file":"index-f9874699.js","sources":["../../src/live-store/LiveStoreProvider.tsx"],"sourcesContent":["import type {\n  ClientConfig,\n  ContentSourceMap,\n  QueryParams,\n  SanityClient,\n  SanityDocument,\n} from '@sanity/client'\nimport { vercelStegaSplit } from '@vercel/stega'\nimport get from 'lodash.get'\nimport { LRUCache } from 'lru-cache'\nimport { applyPatch } from 'mendoza'\nimport {\n  memo,\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n  useSyncExternalStore,\n} from 'react'\n\nimport { parseNormalisedJsonPath } from '../client/jsonpath'\nimport { resolveMapping, walkMap } from '../client/sourcemap'\nimport { defineListenerContext as Context } from '../context'\nimport type {\n  DefineListenerContext,\n  ListenerGetSnapshot,\n  ListenerSubscribe,\n  Logger,\n} from '../types'\nimport { getQueryCacheKey, type QueryCacheKey } from '../utils'\n\n// Documents share the same cache even if there are nested providers, with a Least Recently Used (LRU) cache\nconst documentsCache = new LRUCache({\n  // Max 500 documents in memory, no big deal if a document is evicted it just means the eventual consistency might take longer\n  max: 500,\n})\n\n/**\n * @internal\n */\nexport interface LiveStoreProviderProps {\n  children: React.ReactNode\n  /**\n   * The Sanity client to use for fetching data and listening to mutations.\n   */\n  client: SanityClient\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   * @defaultValue 10000\n   */\n  refreshInterval?: number\n  /**\n   * Listen to mutations on the documents used by your queries, and apply patches directly to the result.\n   * Requires Content Source Maps to work.\n   * @defaultValue true\n   */\n  turboSourceMap?: boolean\n  logger?: Logger\n}\n/**\n * @internal\n */\nexport const LiveStoreProvider = memo(function LiveStoreProvider(\n  props: LiveStoreProviderProps\n) {\n  const {\n    children,\n    client,\n    refreshInterval = 10000,\n    turboSourceMap = true,\n    logger,\n  } = props\n\n  // Check if the client is configured to use Content Source Maps if turbo is enabled\n  // It's wrapped inside `useMemo` so it doesn't call `client.config` more than it needs to, but unlike `useEffect` sooner rather than later\n  useMemo(() => {\n    if (turboSourceMap && !client.config().resultSourceMap) {\n      logger?.error(\n        'The client needs to be configured with `resultSourceMap: true` to enable turbo mode.`'\n      )\n    }\n  }, [client, turboSourceMap, logger])\n\n  const report = useMemo(() => {\n    if (turboSourceMap && client.config().resultSourceMap) {\n      return `Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ${refreshInterval}ms.`\n    }\n    return `Updates will be applied every ${refreshInterval}ms.`\n  }, [client, refreshInterval, turboSourceMap])\n  useEffect(() => {\n    if (logger) {\n      logger.log(\n        `[@sanity/preview-kit]: With the current configuration you can expect that: ${report}`\n      )\n    }\n  }, [logger, report])\n\n  const [subscriptions, setSubscriptions] = useState<QueryCacheKey[]>([])\n  const [snapshots] = useState<QuerySnapshotsCache>(() => new Map())\n  const hooks = useHooks(setSubscriptions)\n  const [context] = useState<DefineListenerContext>(() => {\n    return function defineListener<QueryResult>(\n      initialSnapshot: QueryResult,\n      query: string,\n      params: QueryParams\n    ) {\n      const key = getQueryCacheKey(query, params)\n\n      // Warm up the cache by setting the initial snapshot, showing stale-while-revalidate\n      if (!snapshots.has(key)) {\n        snapshots.set(key, {\n          result: initialSnapshot,\n          resultSourceMap: {} as ContentSourceMap,\n        })\n      }\n\n      const subscribe: ListenerSubscribe = (onStoreChange) => {\n        const unsubscribe = hooks.subscribe(key, query, params, onStoreChange)\n\n        return () => unsubscribe()\n      }\n      const getSnapshot: ListenerGetSnapshot<QueryResult> = () =>\n        snapshots.get(key)?.result as unknown as QueryResult\n\n      return { subscribe, getSnapshot }\n    } satisfies DefineListenerContext\n  })\n  const [turboIds, setTurboIds] = useState<string[]>([])\n  const turboIdsFromSourceMap = useCallback(\n    (contentSourceMap: ContentSourceMap) => {\n      if (!turboSourceMap) return\n      // This handler only adds ids, on each query fetch. But that's ok since <Turbo /> purges ids that are unused\n      const nextTurboIds = new Set<string>()\n      if (contentSourceMap.documents?.length) {\n        for (const { _id } of contentSourceMap.documents) {\n          nextTurboIds.add(_id)\n        }\n      }\n      startTransition(() =>\n        setTurboIds((prevTurboIds) => {\n          const mergedTurboIds = Array.from(\n            new Set([...prevTurboIds, ...nextTurboIds])\n          )\n          if (\n            JSON.stringify(mergedTurboIds.sort()) ===\n            JSON.stringify(prevTurboIds.sort())\n          ) {\n            return prevTurboIds\n          }\n          return mergedTurboIds\n        })\n      )\n    },\n    [turboSourceMap]\n  )\n\n  return (\n    <Context.Provider value={context}>\n      {children}\n      {turboSourceMap && (\n        <Turbo\n          cache={hooks.cache}\n          client={client}\n          setTurboIds={setTurboIds}\n          snapshots={snapshots}\n          turboIds={turboIds}\n        />\n      )}\n      {subscriptions.map((key) => {\n        if (!hooks.cache.has(key)) return null\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const { query, params, listeners } = hooks.cache.get(key)!\n        return (\n          <QuerySubscription\n            key={key}\n            client={client}\n            listeners={listeners}\n            params={params}\n            query={query}\n            refreshInterval={refreshInterval}\n            snapshots={snapshots}\n            turboIdsFromSourceMap={turboIdsFromSourceMap}\n          />\n        )\n      })}\n    </Context.Provider>\n  )\n})\n\ninterface QuerySubscriptionProps\n  extends Required<Pick<LiveStoreProviderProps, 'client' | 'refreshInterval'>> {\n  query: string\n  params: QueryParams\n  listeners: Set<() => void>\n  turboIdsFromSourceMap: (contentSourceMap: ContentSourceMap) => void\n  snapshots: QuerySnapshotsCache\n}\nconst QuerySubscription = memo(function QuerySubscription(\n  props: QuerySubscriptionProps\n) {\n  const {\n    client,\n    refreshInterval,\n    query,\n    params,\n    listeners,\n    snapshots,\n    turboIdsFromSourceMap,\n  } = props\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({ refreshInterval })\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const { signal } = controller\n      const { result, resultSourceMap } = await client.fetch(query, params, {\n        signal,\n        filterResponse: false,\n      })\n\n      if (!signal.aborted) {\n        snapshots.set(getQueryCacheKey(query, params), {\n          result: turboChargeResultIfSourceMap(\n            projectId,\n            dataset,\n            result,\n            resultSourceMap\n          ),\n          resultSourceMap: resultSourceMap ?? ({} as ContentSourceMap),\n        })\n\n        if (resultSourceMap) {\n          turboIdsFromSourceMap(resultSourceMap)\n        }\n\n        // Notify listeners that snapshots are updated\n        for (const listener of listeners.values()) {\n          listener()\n        }\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    listeners,\n    params,\n    projectId,\n    query,\n    shouldRefetch,\n    snapshots,\n    startRefresh,\n    turboIdsFromSourceMap,\n  ])\n\n  return null\n})\n\ntype QuerySnapshotsCache = Map<\n  QueryCacheKey,\n  { result: unknown; resultSourceMap: ContentSourceMap }\n>\n\nfunction getTurboCacheKey(\n  projectId: string,\n  dataset: string,\n  _id: string\n): `${string}-${string}-${string}` {\n  return `${projectId}-${dataset}-${_id}`\n}\n\nfunction onVisibilityChange(onStoreChange: () => void): () => void {\n  document.addEventListener('visibilitychange', onStoreChange)\n  return () => document.removeEventListener('visibilitychange', onStoreChange)\n}\n\n/**\n * Keeps track of when revalidation and activities should be paused\n */\nfunction useShouldPause(): boolean {\n  const [online, setOnline] = useState(false)\n  useEffect(() => {\n    setOnline(navigator.onLine)\n    const online = () => startTransition(() => setOnline(true))\n    const offline = () => startTransition(() => setOnline(false))\n    window.addEventListener('online', online)\n    window.addEventListener('offline', offline)\n    return () => {\n      window.removeEventListener('online', online)\n      window.removeEventListener('offline', offline)\n    }\n  }, [])\n  const visibilityState = useSyncExternalStore(\n    onVisibilityChange,\n    () => document.visibilityState,\n    () => 'hidden' satisfies DocumentVisibilityState\n  )\n\n  // Should pause activity when offline\n  if (!online) {\n    return true\n  }\n\n  // Should pause when the document isn't visible, as it's likely the user isn't looking at the page\n  if (visibilityState === 'hidden') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * 'hit' - the cache is fresh and valid\n * 'stale' - the cache should revalidate, but can't/shouldn't yet (offline, visibility = hidden)\n * 'refresh' - stale cache, and now is a great time to start refreshing\n * 'inflight' - refreshing cache, revalidate events should be ignored\n */\ntype RevalidateState = 'hit' | 'stale' | 'refresh' | 'inflight'\n/**\n * Keeps track of when queries should revalidate\n */\nfunction useRevalidate(\n  props: Pick<LiveStoreProviderProps, 'refreshInterval'>\n): [RevalidateState, () => () => void] {\n  const { refreshInterval } = props\n\n  const shouldPause = useShouldPause()\n  const [state, setState] = useState<RevalidateState>('hit')\n\n  // Keep track of indicators for when revalidation should be 'paused'\n  // Like if we're currently offline, or the document isn't visible\n  // Basically if 'stale' and all good we return 'refresh'\n\n  // Next keep track of staleness itself. If we come back online, on a windows focus event\n  // or on a refreshInterval timeout\n  // Basically it controls if cache should be 'hit' or 'stale'\n\n  // How to handle refresh to inflight?\n\n  const startRefresh = useCallback(() => {\n    startTransition(() => setState('inflight'))\n    return () => startTransition(() => setState('hit'))\n  }, [])\n\n  // Revalidate on refreshInterval\n  useEffect(() => {\n    // If refreshInterval is nullish then we don't want to refresh.\n    // Inflight means it's already refreshing and we pause the countdown.\n    // It's only necessary to start the countdown if the cache isn't already stale\n    if (!refreshInterval || state !== 'hit') {\n      return\n    }\n    const timeout = setTimeout(\n      () => startTransition(() => setState('stale')),\n      refreshInterval\n    )\n    return () => clearTimeout(timeout)\n  }, [refreshInterval, state])\n  // Revalidate on windows focus\n  useEffect(() => {\n    if (state !== 'hit') {\n      return\n    }\n    const onFocus = () => startTransition(() => setState('stale'))\n    window.addEventListener('focus', onFocus)\n    return () => window.removeEventListener('focus', onFocus)\n  }, [refreshInterval, state])\n  // Revalidate on changes to shouldPause\n  useEffect(() => {\n    // Mark as stale pre-emptively if we're offline or the document isn't visible\n    if (shouldPause && state === 'hit') {\n      startTransition(() => setState('stale'))\n    }\n    // If not paused we can mark stale as ready for refresh\n    if (!shouldPause && state === 'stale') {\n      startTransition(() => setState('refresh'))\n    }\n  }, [shouldPause, state])\n\n  return [state, startRefresh]\n}\n\ntype LiveStoreQueryCacheMap = Map<\n  QueryCacheKey,\n  { query: string; params: QueryParams; listeners: Set<() => void> }\n>\n\n/**\n * Keeps track of store subscribers per cache key, in a way that's designed for useSyncExternalStore.\n * The main difference from a typical subscription state with useEffect is that `adding` and `cleanup`\n * is wholly managed by the `subscribe` function in `useSyncExternalStore`, instead of lifecycles in useEffect.\n * And since the `onStoreChange` callback, provided to `subscribe`, notifies React when to re-render,\n * there is no need to use `setState` to trigger a re-render. That's why the Map is persisted in `useState` but the state setter isn't used.\n */\nfunction useHooks(\n  setSubscriptions: React.Dispatch<React.SetStateAction<QueryCacheKey[]>>\n): {\n  cache: LiveStoreQueryCacheMap\n  subscribe: (\n    key: QueryCacheKey,\n    query: string,\n    params: QueryParams,\n    listener: () => void\n  ) => () => void\n} {\n  const [cache] = useState<LiveStoreQueryCacheMap>(() => new Map())\n  const subscribe = useCallback(\n    (\n      key: QueryCacheKey,\n      query: string,\n      params: QueryParams,\n      listener: () => void\n    ) => {\n      if (!cache.has(key)) {\n        cache.set(key, { query, params, listeners: new Set<() => void>() })\n        startTransition(() =>\n          setSubscriptions((prevSubscriptions) => {\n            if (prevSubscriptions.includes(key)) {\n              return prevSubscriptions\n            }\n            return [...prevSubscriptions, key]\n          })\n        )\n      }\n      const hook = cache.get(key)\n      if (!hook || !hook.listeners) {\n        throw new TypeError('Inconsistent cache for key: ' + key)\n      }\n      const { listeners } = hook\n      listeners.add(listener)\n      return () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          cache.delete(key)\n          startTransition(() =>\n            setSubscriptions((prevSubscriptions) => {\n              if (prevSubscriptions.includes(key)) {\n                return prevSubscriptions.filter((sub) => sub !== key)\n              }\n              return prevSubscriptions\n            })\n          )\n        }\n      }\n    },\n    [cache, setSubscriptions]\n  )\n  return useMemo(() => ({ cache, subscribe }), [cache, subscribe])\n}\n\ninterface TurboProps extends Pick<LiveStoreProviderProps, 'client'> {\n  turboIds: string[]\n  setTurboIds: React.Dispatch<React.SetStateAction<string[]>>\n  cache: LiveStoreQueryCacheMap\n  snapshots: QuerySnapshotsCache\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const { client, snapshots, cache, turboIds, setTurboIds } = props\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Keep track of document ids that the active `useListeningQuery` hooks care about\n  useEffect(() => {\n    const nextTurboIds = new Set<string>()\n    for (const { query, params } of cache.values()) {\n      const key = getQueryCacheKey(query, params)\n      const snapshot = snapshots.get(key)\n      if (snapshot && snapshot.resultSourceMap?.documents?.length) {\n        for (const { _id } of snapshot.resultSourceMap.documents) {\n          nextTurboIds.add(_id)\n        }\n      }\n    }\n    const nextTurboIdsSnapshot = [...nextTurboIds].sort()\n    if (JSON.stringify(turboIds) !== JSON.stringify(nextTurboIdsSnapshot)) {\n      startTransition(() => setTurboIds(nextTurboIdsSnapshot))\n    }\n  }, [cache, setTurboIds, snapshots, turboIds])\n\n  // Figure out which documents are misssing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (\n        !batchSet.has(turboId) &&\n        !documentsCache.has(getTurboCacheKey(projectId, dataset, turboId))\n      ) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, 10)\n    if (nextBatchSlice.length === 0) return\n    startTransition(() =>\n      setBatch((prevBatch) => [...prevBatch.slice(-10), nextBatchSlice])\n    )\n  }, [batch, dataset, projectId, turboIds])\n\n  const [lastMutatedDocumentId, setLastMutatedDocumentId] = useState<string>()\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = client\n      .listen(\n        `*`,\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n        }\n      )\n      .subscribe((update) => {\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const key = getTurboCacheKey(projectId, dataset, update.documentId)\n        const cachedDocument = documentsCache.peek(key)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = { ...cachedDocument } as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          documentsCache.set(key, patchedDocument)\n        }\n\n        startTransition(() => setLastMutatedDocumentId(update.documentId))\n      })\n    return () => subscription.unsubscribe()\n  }, [client, dataset, projectId])\n\n  // If the last mutated document is in the list over turboIds then lets apply the source map\n  useEffect(() => {\n    if (!lastMutatedDocumentId || !turboIds.includes(lastMutatedDocumentId))\n      return\n\n    const updatedKeys: QueryCacheKey[] = []\n    for (const [key, snapshot] of snapshots.entries()) {\n      if (snapshot.resultSourceMap?.documents?.length) {\n        snapshot.result = turboChargeResultIfSourceMap(\n          projectId,\n          dataset,\n          snapshot.result,\n          snapshot.resultSourceMap\n        )\n        updatedKeys.push(key)\n      }\n    }\n    for (const updatedKey of updatedKeys) {\n      const listeners = cache.get(updatedKey)?.listeners\n      if (listeners) {\n        for (const listener of listeners) {\n          listener()\n        }\n      }\n    }\n    startTransition(() => setLastMutatedDocumentId(undefined))\n  }, [cache, dataset, lastMutatedDocumentId, projectId, snapshots, turboIds])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          client={client}\n          projectId={projectId}\n          dataset={dataset}\n          ids={ids}\n        />\n      ))}\n    </>\n  )\n})\n\ninterface GetDocumentsProps extends Pick<LiveStoreProviderProps, 'client'> {\n  projectId: string\n  dataset: string\n  ids: string[]\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const { client, projectId, dataset, ids } = props\n\n  useEffect(() => {\n    const missingIds = ids.filter(\n      (id) => !documentsCache.has(getTurboCacheKey(projectId, dataset, id))\n    )\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          documentsCache.set(getTurboCacheKey(projectId, dataset, doc._id), doc)\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [client, dataset, ids, projectId])\n\n  return null\n})\n\nfunction turboChargeResultIfSourceMap(\n  projectId: string,\n  dataset: string,\n  result: unknown,\n  resultSourceMap?: ContentSourceMap\n) {\n  if (!resultSourceMap) return result\n\n  return walkMap(result, (value, path) => {\n    const resolveMappingResult = resolveMapping(path, resultSourceMap)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const [mapping, , pathSuffix] = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = resultSourceMap.documents[mapping.source.document]\n    const sourcePath = resultSourceMap.paths[mapping.source.path]\n    if (sourceDocument && sourceDocument._id) {\n      const cachedDocument = documentsCache.get(\n        getTurboCacheKey(projectId, dataset, sourceDocument._id)\n      )\n\n      const cachedValue = cachedDocument\n        ? get(\n            cachedDocument,\n            parseNormalisedJsonPath(sourcePath + pathSuffix),\n            value\n          )\n        : value\n      // Preserve stega encoded strings, if they exist\n      if (typeof cachedValue === 'string' && typeof value === 'string') {\n        const { encoded } = vercelStegaSplit(value)\n        const { cleaned } = vercelStegaSplit(cachedValue)\n        return `${encoded}${cleaned}`\n      }\n      return cachedValue\n    }\n\n    return value\n  })\n}\n"],"names":["documentsCache","LRUCache","max","LiveStoreProvider","memo","props","children","client","refreshInterval","turboSourceMap","logger","useMemo","config","resultSourceMap","error","report","concat","useEffect","log","subscriptions","setSubscriptions","useState","snapshots","Map","hooks","useHooks","context","defineListener","initialSnapshot","query","params","key","getQueryCacheKey","has","set","result","subscribe","onStoreChange","unsubscribe","getSnapshot","_a","get","turboIds","setTurboIds","turboIdsFromSourceMap","useCallback","contentSourceMap","nextTurboIds","Set","documents","length","_id","add","startTransition","prevTurboIds","mergedTurboIds","Array","from","JSON","stringify","sort","jsxs","Context","Provider","value","jsx","Turbo","cache","map","listeners","QuerySubscription","projectId","dataset","setError","revalidate","startRefresh","useRevalidate","shouldRefetch","fulfilled","controller","AbortController","effect","signal","fetch","filterResponse","aborted","turboChargeResultIfSourceMap","listener","values","onFinally","catch","name","finally","abort","getTurboCacheKey","onVisibilityChange","document","addEventListener","removeEventListener","useShouldPause","online","setOnline","navigator","onLine","online2","offline","window","visibilityState","useSyncExternalStore","shouldPause","state","setState","timeout","setTimeout","clearTimeout","onFocus","prevSubscriptions","includes","hook","TypeError","delete","size","filter","sub","_b","snapshot","nextTurboIdsSnapshot","batch","setBatch","batchSet","flat","nextBatch","turboId","nextBatchSlice","slice","prevBatch","lastMutatedDocumentId","setLastMutatedDocumentId","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","update","type","effects","apply","documentId","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","_c","updatedKeys","entries","push","updatedKey","Fragment","ids","GetDocuments","missingIds","id","getDocuments","then","doc","console","walkMap","path","resolveMappingResult","resolveMapping","mapping","pathSuffix","source","sourceDocument","sourcePath","paths","cachedValue","parseNormalisedJsonPath","encoded","vercelStegaSplit","cleaned"],"mappings":"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"}