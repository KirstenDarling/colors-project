'use strict';

var jsxRuntime = require('react/jsx-runtime');
var stega = require('@vercel/stega');
var get = require('lodash.get');
var lruCache = require('lru-cache');
var mendoza = require('mendoza');
var react = require('react');
var sourcemap = require('./sourcemap-7a1ad3e9.cjs');
var context = require('./context-6e668875.cjs');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var get__default = /*#__PURE__*/_interopDefaultCompat(get);
const documentsCache = new lruCache.LRUCache({
  // Max 500 documents in memory, no big deal if a document is evicted it just means the eventual consistency might take longer
  max: 500
});
const LiveStoreProvider = react.memo(function LiveStoreProvider2(props) {
  const {
    children,
    client,
    refreshInterval = 1e4,
    turboSourceMap = true,
    logger
  } = props;
  react.useMemo(() => {
    if (turboSourceMap && !client.config().resultSourceMap) {
      logger == null ? void 0 : logger.error("The client needs to be configured with `resultSourceMap: true` to enable turbo mode.`");
    }
  }, [client, turboSourceMap, logger]);
  const report = react.useMemo(() => {
    if (turboSourceMap && client.config().resultSourceMap) {
      return "Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ".concat(refreshInterval, "ms.");
    }
    return "Updates will be applied every ".concat(refreshInterval, "ms.");
  }, [client, refreshInterval, turboSourceMap]);
  react.useEffect(() => {
    if (logger) {
      logger.log("[@sanity/preview-kit]: With the current configuration you can expect that: ".concat(report));
    }
  }, [logger, report]);
  const [subscriptions, setSubscriptions] = react.useState([]);
  const [snapshots] = react.useState(() => /* @__PURE__ */new Map());
  const hooks = useHooks(setSubscriptions);
  const [context$1] = react.useState(() => {
    return function defineListener(initialSnapshot, query, params) {
      const key = context.getQueryCacheKey(query, params);
      if (!snapshots.has(key)) {
        snapshots.set(key, {
          result: initialSnapshot,
          resultSourceMap: {}
        });
      }
      const subscribe = onStoreChange => {
        const unsubscribe = hooks.subscribe(key, query, params, onStoreChange);
        return () => unsubscribe();
      };
      const getSnapshot = () => {
        var _a;
        return (_a = snapshots.get(key)) == null ? void 0 : _a.result;
      };
      return {
        subscribe,
        getSnapshot
      };
    };
  });
  const [turboIds, setTurboIds] = react.useState([]);
  const turboIdsFromSourceMap = react.useCallback(contentSourceMap => {
    var _a;
    if (!turboSourceMap) return;
    const nextTurboIds = /* @__PURE__ */new Set();
    if ((_a = contentSourceMap.documents) == null ? void 0 : _a.length) {
      for (const {
        _id
      } of contentSourceMap.documents) {
        nextTurboIds.add(_id);
      }
    }
    react.startTransition(() => setTurboIds(prevTurboIds => {
      const mergedTurboIds = Array.from( /* @__PURE__ */new Set([...prevTurboIds, ...nextTurboIds]));
      if (JSON.stringify(mergedTurboIds.sort()) === JSON.stringify(prevTurboIds.sort())) {
        return prevTurboIds;
      }
      return mergedTurboIds;
    }));
  }, [turboSourceMap]);
  return /* @__PURE__ */jsxRuntime.jsxs(context.defineListenerContext.Provider, {
    value: context$1,
    children: [children, turboSourceMap && /* @__PURE__ */jsxRuntime.jsx(Turbo, {
      cache: hooks.cache,
      client,
      setTurboIds,
      snapshots,
      turboIds
    }), subscriptions.map(key => {
      if (!hooks.cache.has(key)) return null;
      const {
        query,
        params,
        listeners
      } = hooks.cache.get(key);
      return /* @__PURE__ */jsxRuntime.jsx(QuerySubscription, {
        client,
        listeners,
        params,
        query,
        refreshInterval,
        snapshots,
        turboIdsFromSourceMap
      }, key);
    })]
  });
});
const QuerySubscription = react.memo(function QuerySubscription2(props) {
  const {
    client,
    refreshInterval,
    query,
    params,
    listeners,
    snapshots,
    turboIdsFromSourceMap
  } = props;
  const {
    projectId,
    dataset
  } = react.useMemo(() => {
    const {
      projectId: projectId2,
      dataset: dataset2
    } = client.config();
    return {
      projectId: projectId2,
      dataset: dataset2
    };
  }, [client]);
  const [error, setError] = react.useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = useRevalidate({
    refreshInterval
  });
  const shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  react.useEffect(() => {
    if (!shouldRefetch) {
      return;
    }
    let fulfilled = false;
    const controller = new AbortController();
    async function effect() {
      const {
        signal
      } = controller;
      const {
        result,
        resultSourceMap
      } = await client.fetch(query, params, {
        signal,
        filterResponse: false
      });
      if (!signal.aborted) {
        snapshots.set(context.getQueryCacheKey(query, params), {
          result: turboChargeResultIfSourceMap(projectId, dataset, result, resultSourceMap),
          resultSourceMap: resultSourceMap != null ? resultSourceMap : {}
        });
        if (resultSourceMap) {
          turboIdsFromSourceMap(resultSourceMap);
        }
        for (const listener of listeners.values()) {
          listener();
        }
        fulfilled = true;
      }
    }
    const onFinally = startRefresh();
    effect().catch(error2 => {
      if (error2.name !== "AbortError") {
        setError(error2);
      }
    }).finally(onFinally);
    return () => {
      if (!fulfilled) {
        controller.abort();
      }
    };
  }, [client, dataset, listeners, params, projectId, query, shouldRefetch, snapshots, startRefresh, turboIdsFromSourceMap]);
  return null;
});
function getTurboCacheKey(projectId, dataset, _id) {
  return "".concat(projectId, "-").concat(dataset, "-").concat(_id);
}
function onVisibilityChange(onStoreChange) {
  document.addEventListener("visibilitychange", onStoreChange);
  return () => document.removeEventListener("visibilitychange", onStoreChange);
}
function useShouldPause() {
  const [online, setOnline] = react.useState(false);
  react.useEffect(() => {
    setOnline(navigator.onLine);
    const online2 = () => react.startTransition(() => setOnline(true));
    const offline = () => react.startTransition(() => setOnline(false));
    window.addEventListener("online", online2);
    window.addEventListener("offline", offline);
    return () => {
      window.removeEventListener("online", online2);
      window.removeEventListener("offline", offline);
    };
  }, []);
  const visibilityState = react.useSyncExternalStore(onVisibilityChange, () => document.visibilityState, () => "hidden");
  if (!online) {
    return true;
  }
  if (visibilityState === "hidden") {
    return true;
  }
  return false;
}
function useRevalidate(props) {
  const {
    refreshInterval
  } = props;
  const shouldPause = useShouldPause();
  const [state, setState] = react.useState("hit");
  const startRefresh = react.useCallback(() => {
    react.startTransition(() => setState("inflight"));
    return () => react.startTransition(() => setState("hit"));
  }, []);
  react.useEffect(() => {
    if (!refreshInterval || state !== "hit") {
      return;
    }
    const timeout = setTimeout(() => react.startTransition(() => setState("stale")), refreshInterval);
    return () => clearTimeout(timeout);
  }, [refreshInterval, state]);
  react.useEffect(() => {
    if (state !== "hit") {
      return;
    }
    const onFocus = () => react.startTransition(() => setState("stale"));
    window.addEventListener("focus", onFocus);
    return () => window.removeEventListener("focus", onFocus);
  }, [refreshInterval, state]);
  react.useEffect(() => {
    if (shouldPause && state === "hit") {
      react.startTransition(() => setState("stale"));
    }
    if (!shouldPause && state === "stale") {
      react.startTransition(() => setState("refresh"));
    }
  }, [shouldPause, state]);
  return [state, startRefresh];
}
function useHooks(setSubscriptions) {
  const [cache] = react.useState(() => /* @__PURE__ */new Map());
  const subscribe = react.useCallback((key, query, params, listener) => {
    if (!cache.has(key)) {
      cache.set(key, {
        query,
        params,
        listeners: /* @__PURE__ */new Set()
      });
      react.startTransition(() => setSubscriptions(prevSubscriptions => {
        if (prevSubscriptions.includes(key)) {
          return prevSubscriptions;
        }
        return [...prevSubscriptions, key];
      }));
    }
    const hook = cache.get(key);
    if (!hook || !hook.listeners) {
      throw new TypeError("Inconsistent cache for key: " + key);
    }
    const {
      listeners
    } = hook;
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        cache.delete(key);
        react.startTransition(() => setSubscriptions(prevSubscriptions => {
          if (prevSubscriptions.includes(key)) {
            return prevSubscriptions.filter(sub => sub !== key);
          }
          return prevSubscriptions;
        }));
      }
    };
  }, [cache, setSubscriptions]);
  return react.useMemo(() => ({
    cache,
    subscribe
  }), [cache, subscribe]);
}
const Turbo = react.memo(function Turbo2(props) {
  const {
    client,
    snapshots,
    cache,
    turboIds,
    setTurboIds
  } = props;
  const {
    projectId,
    dataset
  } = react.useMemo(() => {
    const {
      projectId: projectId2,
      dataset: dataset2
    } = client.config();
    return {
      projectId: projectId2,
      dataset: dataset2
    };
  }, [client]);
  react.useEffect(() => {
    var _a, _b;
    const nextTurboIds = /* @__PURE__ */new Set();
    for (const {
      query,
      params
    } of cache.values()) {
      const key = context.getQueryCacheKey(query, params);
      const snapshot = snapshots.get(key);
      if (snapshot && ((_b = (_a = snapshot.resultSourceMap) == null ? void 0 : _a.documents) == null ? void 0 : _b.length)) {
        for (const {
          _id
        } of snapshot.resultSourceMap.documents) {
          nextTurboIds.add(_id);
        }
      }
    }
    const nextTurboIdsSnapshot = [...nextTurboIds].sort();
    if (JSON.stringify(turboIds) !== JSON.stringify(nextTurboIdsSnapshot)) {
      react.startTransition(() => setTurboIds(nextTurboIdsSnapshot));
    }
  }, [cache, setTurboIds, snapshots, turboIds]);
  const [batch, setBatch] = react.useState([]);
  react.useEffect(() => {
    const batchSet = new Set(batch.flat());
    const nextBatch = /* @__PURE__ */new Set();
    for (const turboId of turboIds) {
      if (!batchSet.has(turboId) && !documentsCache.has(getTurboCacheKey(projectId, dataset, turboId))) {
        nextBatch.add(turboId);
      }
    }
    const nextBatchSlice = [...nextBatch].slice(0, 10);
    if (nextBatchSlice.length === 0) return;
    react.startTransition(() => setBatch(prevBatch => [...prevBatch.slice(-10), nextBatchSlice]));
  }, [batch, dataset, projectId, turboIds]);
  const [lastMutatedDocumentId, setLastMutatedDocumentId] = react.useState();
  react.useEffect(() => {
    const subscription = client.listen("*", {}, {
      events: ["mutation"],
      effectFormat: "mendoza",
      includePreviousRevision: false,
      includeResult: false
    }).subscribe(update => {
      var _a, _b;
      if (update.type !== "mutation" || !((_b = (_a = update.effects) == null ? void 0 : _a.apply) == null ? void 0 : _b.length)) return;
      const key = getTurboCacheKey(projectId, dataset, update.documentId);
      const cachedDocument = documentsCache.peek(key);
      if (cachedDocument) {
        const patchDoc = {
          ...cachedDocument
        };
        delete patchDoc._rev;
        const patchedDocument = mendoza.applyPatch(patchDoc, update.effects.apply);
        documentsCache.set(key, patchedDocument);
      }
      react.startTransition(() => setLastMutatedDocumentId(update.documentId));
    });
    return () => subscription.unsubscribe();
  }, [client, dataset, projectId]);
  react.useEffect(() => {
    var _a, _b, _c;
    if (!lastMutatedDocumentId || !turboIds.includes(lastMutatedDocumentId)) return;
    const updatedKeys = [];
    for (const [key, snapshot] of snapshots.entries()) {
      if ((_b = (_a = snapshot.resultSourceMap) == null ? void 0 : _a.documents) == null ? void 0 : _b.length) {
        snapshot.result = turboChargeResultIfSourceMap(projectId, dataset, snapshot.result, snapshot.resultSourceMap);
        updatedKeys.push(key);
      }
    }
    for (const updatedKey of updatedKeys) {
      const listeners = (_c = cache.get(updatedKey)) == null ? void 0 : _c.listeners;
      if (listeners) {
        for (const listener of listeners) {
          listener();
        }
      }
    }
    react.startTransition(() => setLastMutatedDocumentId(void 0));
  }, [cache, dataset, lastMutatedDocumentId, projectId, snapshots, turboIds]);
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: batch.map(ids => /* @__PURE__ */jsxRuntime.jsx(GetDocuments, {
      client,
      projectId,
      dataset,
      ids
    }, JSON.stringify(ids)))
  });
});
const GetDocuments = react.memo(function GetDocuments2(props) {
  const {
    client,
    projectId,
    dataset,
    ids
  } = props;
  react.useEffect(() => {
    const missingIds = ids.filter(id => !documentsCache.has(getTurboCacheKey(projectId, dataset, id)));
    if (missingIds.length === 0) return;
    client.getDocuments(missingIds).then(documents => {
      for (const doc of documents) {
        if (doc && (doc == null ? void 0 : doc._id)) {
          documentsCache.set(getTurboCacheKey(projectId, dataset, doc._id), doc);
        }
      }
    }, console.error);
  }, [client, dataset, ids, projectId]);
  return null;
});
function turboChargeResultIfSourceMap(projectId, dataset, result, resultSourceMap) {
  if (!resultSourceMap) return result;
  return sourcemap.walkMap(result, (value, path) => {
    const resolveMappingResult = sourcemap.resolveMapping(path, resultSourceMap);
    if (!resolveMappingResult) {
      return value;
    }
    const [mapping,, pathSuffix] = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument = resultSourceMap.documents[mapping.source.document];
    const sourcePath = resultSourceMap.paths[mapping.source.path];
    if (sourceDocument && sourceDocument._id) {
      const cachedDocument = documentsCache.get(getTurboCacheKey(projectId, dataset, sourceDocument._id));
      const cachedValue = cachedDocument ? get__default.default(cachedDocument, sourcemap.parseNormalisedJsonPath(sourcePath + pathSuffix), value) : value;
      if (typeof cachedValue === "string" && typeof value === "string") {
        const {
          encoded
        } = stega.vercelStegaSplit(value);
        const {
          cleaned
        } = stega.vercelStegaSplit(cachedValue);
        return "".concat(encoded).concat(cleaned);
      }
      return cachedValue;
    }
    return value;
  });
}
exports.default = LiveStoreProvider;
//# sourceMappingURL=index-2120b5b3.cjs.map
