{"version":3,"file":"sourcemap-7a1ad3e9.cjs","sources":["../../src/client/jsonpath.ts","../../src/client/sourcemap.ts"],"sourcesContent":["import type { PathSegment } from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/** @internal */\nexport function normalisedJsonPath(path: PathSegment[]): string {\n  return `$${path\n    .map((key) => {\n      if (typeof key === 'string') {\n        const escapedKey = key.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      return `[${key}]`\n    })\n    .join('')}`\n}\n\n/** @internal */\nexport function parseNormalisedJsonPath(path: string): PathSegment[] {\n  const parsed: PathSegment[] = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n  }\n\n  return parsed\n}\n","/* eslint-disable no-nested-ternary */\nimport type {\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  ContentSourceMapMapping,\n} from '@sanity/client'\n\nimport { normalisedJsonPath } from './jsonpath'\nimport type {\n  ContentSourceMapQueryResponse,\n  Logger,\n  PathSegment,\n} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\nfunction isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n\n/** @alpha */\nexport type Encoder = (\n  value: string,\n  sourceDocument: ContentSourceMapDocuments[number],\n  path: string\n) => unknown\n\n/** @alpha */\nexport function encode(\n  response: ContentSourceMapQueryResponse,\n  encoder: Encoder\n): ContentSourceMapQueryResponse {\n  if (!response.resultSourceMap) {\n    throw new TypeError('Missing resultSourceMap')\n  }\n\n  response.result = encodeIntoResult(response, encoder)\n  return response\n}\n\n/** @alpha */\nexport function encodeIntoResult(\n  response: ContentSourceMapQueryResponse,\n  encoder: Encoder\n): ReturnType<Encoder> {\n  return walkMap(response.result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const resolveMappingResult = resolveMapping(path, response.resultSourceMap!)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const [mapping, , pathSuffix] = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument =\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      response.resultSourceMap!.documents[mapping.source.document!]\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const sourcePath = response.resultSourceMap!.paths[mapping.source.path]\n\n    return encoder(value, sourceDocument, sourcePath + pathSuffix)\n  })\n}\n\nexport type WalkMapFn = (value: unknown, path: PathSegment[]) => unknown\n\n// generic way to walk a nested object or array and apply a mapping function to each value\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: PathSegment[] = []\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => walkMap(v, mappingFn, path.concat(idx)))\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [\n        k,\n        walkMap(v, mappingFn, path.concat(k)),\n      ])\n    )\n  }\n\n  return mappingFn(value, path)\n}\n\nexport function resolveMapping(\n  resultPath: PathSegment[],\n  csm: ContentSourceMap,\n  logger?: Logger\n): [ContentSourceMapMapping, string, string] | undefined {\n  const resultJsonPath = normalisedJsonPath(resultPath)\n\n  if (!csm.mappings) {\n    logger?.error('Missing resultSourceMap.mappings', { resultSourceMap: csm })\n    return undefined\n  }\n\n  if (csm.mappings[resultJsonPath] !== undefined) {\n    return [csm.mappings[resultJsonPath], resultJsonPath, '']\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultJsonPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultJsonPath.substring(matchedPath.length)\n  return [mapping, matchedPath, pathSuffix]\n}\n"],"names":["ESCAPE","UNESCAPE","normalisedJsonPath","path","concat","map","key","escapedKey","replace","match","join","parseNormalisedJsonPath","parsed","parseRe","exec","m","push","parseInt","isRecord","value","isArray","Array","encode","response","encoder","resultSourceMap","TypeError","result","encodeIntoResult","walkMap","resolveMappingResult","resolveMapping","mapping","pathSuffix","type","source","sourceDocument","documents","document","sourcePath","paths","mappingFn","arguments","length","undefined","v","idx","Object","fromEntries","entries","_ref","k","resultPath","csm","logger","resultJsonPath","mappings","error","filter","_ref2","startsWith","sort","_ref3","_ref4","key1","key2","matchedPath","substring"],"mappings":"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"}