import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { vercelStegaSplit } from '@vercel/stega';
import get from 'lodash.get';
import { LRUCache } from 'lru-cache';
import { applyPatch } from 'mendoza';
import { memo, useMemo, useEffect, useState, useCallback, startTransition, useSyncExternalStore } from 'react';
import { walkMap, resolveMapping, parseNormalisedJsonPath } from './sourcemap-0a868d9e.js';
import { getQueryCacheKey, defineListenerContext } from './context-13c019e1.js';
const documentsCache = new LRUCache({
  // Max 500 documents in memory, no big deal if a document is evicted it just means the eventual consistency might take longer
  max: 500
});
const LiveStoreProvider = memo(function LiveStoreProvider2(props) {
  const {
    children,
    client,
    refreshInterval = 1e4,
    turboSourceMap = true,
    logger
  } = props;
  useMemo(() => {
    if (turboSourceMap && !client.config().resultSourceMap) {
      logger == null ? void 0 : logger.error("The client needs to be configured with `resultSourceMap: true` to enable turbo mode.`");
    }
  }, [client, turboSourceMap, logger]);
  const report = useMemo(() => {
    if (turboSourceMap && client.config().resultSourceMap) {
      return "Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ".concat(refreshInterval, "ms.");
    }
    return "Updates will be applied every ".concat(refreshInterval, "ms.");
  }, [client, refreshInterval, turboSourceMap]);
  useEffect(() => {
    if (logger) {
      logger.log("[@sanity/preview-kit]: With the current configuration you can expect that: ".concat(report));
    }
  }, [logger, report]);
  const [subscriptions, setSubscriptions] = useState([]);
  const [snapshots] = useState(() => /* @__PURE__ */new Map());
  const hooks = useHooks(setSubscriptions);
  const [context] = useState(() => {
    return function defineListener(initialSnapshot, query, params) {
      const key = getQueryCacheKey(query, params);
      if (!snapshots.has(key)) {
        snapshots.set(key, {
          result: initialSnapshot,
          resultSourceMap: {}
        });
      }
      const subscribe = onStoreChange => {
        const unsubscribe = hooks.subscribe(key, query, params, onStoreChange);
        return () => unsubscribe();
      };
      const getSnapshot = () => {
        var _a;
        return (_a = snapshots.get(key)) == null ? void 0 : _a.result;
      };
      return {
        subscribe,
        getSnapshot
      };
    };
  });
  const [turboIds, setTurboIds] = useState([]);
  const turboIdsFromSourceMap = useCallback(contentSourceMap => {
    var _a;
    if (!turboSourceMap) return;
    const nextTurboIds = /* @__PURE__ */new Set();
    if ((_a = contentSourceMap.documents) == null ? void 0 : _a.length) {
      for (const {
        _id
      } of contentSourceMap.documents) {
        nextTurboIds.add(_id);
      }
    }
    startTransition(() => setTurboIds(prevTurboIds => {
      const mergedTurboIds = Array.from( /* @__PURE__ */new Set([...prevTurboIds, ...nextTurboIds]));
      if (JSON.stringify(mergedTurboIds.sort()) === JSON.stringify(prevTurboIds.sort())) {
        return prevTurboIds;
      }
      return mergedTurboIds;
    }));
  }, [turboSourceMap]);
  return /* @__PURE__ */jsxs(defineListenerContext.Provider, {
    value: context,
    children: [children, turboSourceMap && /* @__PURE__ */jsx(Turbo, {
      cache: hooks.cache,
      client,
      setTurboIds,
      snapshots,
      turboIds
    }), subscriptions.map(key => {
      if (!hooks.cache.has(key)) return null;
      const {
        query,
        params,
        listeners
      } = hooks.cache.get(key);
      return /* @__PURE__ */jsx(QuerySubscription, {
        client,
        listeners,
        params,
        query,
        refreshInterval,
        snapshots,
        turboIdsFromSourceMap
      }, key);
    })]
  });
});
const QuerySubscription = memo(function QuerySubscription2(props) {
  const {
    client,
    refreshInterval,
    query,
    params,
    listeners,
    snapshots,
    turboIdsFromSourceMap
  } = props;
  const {
    projectId,
    dataset
  } = useMemo(() => {
    const {
      projectId: projectId2,
      dataset: dataset2
    } = client.config();
    return {
      projectId: projectId2,
      dataset: dataset2
    };
  }, [client]);
  const [error, setError] = useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = useRevalidate({
    refreshInterval
  });
  const shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  useEffect(() => {
    if (!shouldRefetch) {
      return;
    }
    let fulfilled = false;
    const controller = new AbortController();
    async function effect() {
      const {
        signal
      } = controller;
      const {
        result,
        resultSourceMap
      } = await client.fetch(query, params, {
        signal,
        filterResponse: false
      });
      if (!signal.aborted) {
        snapshots.set(getQueryCacheKey(query, params), {
          result: turboChargeResultIfSourceMap(projectId, dataset, result, resultSourceMap),
          resultSourceMap: resultSourceMap != null ? resultSourceMap : {}
        });
        if (resultSourceMap) {
          turboIdsFromSourceMap(resultSourceMap);
        }
        for (const listener of listeners.values()) {
          listener();
        }
        fulfilled = true;
      }
    }
    const onFinally = startRefresh();
    effect().catch(error2 => {
      if (error2.name !== "AbortError") {
        setError(error2);
      }
    }).finally(onFinally);
    return () => {
      if (!fulfilled) {
        controller.abort();
      }
    };
  }, [client, dataset, listeners, params, projectId, query, shouldRefetch, snapshots, startRefresh, turboIdsFromSourceMap]);
  return null;
});
function getTurboCacheKey(projectId, dataset, _id) {
  return "".concat(projectId, "-").concat(dataset, "-").concat(_id);
}
function onVisibilityChange(onStoreChange) {
  document.addEventListener("visibilitychange", onStoreChange);
  return () => document.removeEventListener("visibilitychange", onStoreChange);
}
function useShouldPause() {
  const [online, setOnline] = useState(false);
  useEffect(() => {
    setOnline(navigator.onLine);
    const online2 = () => startTransition(() => setOnline(true));
    const offline = () => startTransition(() => setOnline(false));
    window.addEventListener("online", online2);
    window.addEventListener("offline", offline);
    return () => {
      window.removeEventListener("online", online2);
      window.removeEventListener("offline", offline);
    };
  }, []);
  const visibilityState = useSyncExternalStore(onVisibilityChange, () => document.visibilityState, () => "hidden");
  if (!online) {
    return true;
  }
  if (visibilityState === "hidden") {
    return true;
  }
  return false;
}
function useRevalidate(props) {
  const {
    refreshInterval
  } = props;
  const shouldPause = useShouldPause();
  const [state, setState] = useState("hit");
  const startRefresh = useCallback(() => {
    startTransition(() => setState("inflight"));
    return () => startTransition(() => setState("hit"));
  }, []);
  useEffect(() => {
    if (!refreshInterval || state !== "hit") {
      return;
    }
    const timeout = setTimeout(() => startTransition(() => setState("stale")), refreshInterval);
    return () => clearTimeout(timeout);
  }, [refreshInterval, state]);
  useEffect(() => {
    if (state !== "hit") {
      return;
    }
    const onFocus = () => startTransition(() => setState("stale"));
    window.addEventListener("focus", onFocus);
    return () => window.removeEventListener("focus", onFocus);
  }, [refreshInterval, state]);
  useEffect(() => {
    if (shouldPause && state === "hit") {
      startTransition(() => setState("stale"));
    }
    if (!shouldPause && state === "stale") {
      startTransition(() => setState("refresh"));
    }
  }, [shouldPause, state]);
  return [state, startRefresh];
}
function useHooks(setSubscriptions) {
  const [cache] = useState(() => /* @__PURE__ */new Map());
  const subscribe = useCallback((key, query, params, listener) => {
    if (!cache.has(key)) {
      cache.set(key, {
        query,
        params,
        listeners: /* @__PURE__ */new Set()
      });
      startTransition(() => setSubscriptions(prevSubscriptions => {
        if (prevSubscriptions.includes(key)) {
          return prevSubscriptions;
        }
        return [...prevSubscriptions, key];
      }));
    }
    const hook = cache.get(key);
    if (!hook || !hook.listeners) {
      throw new TypeError("Inconsistent cache for key: " + key);
    }
    const {
      listeners
    } = hook;
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        cache.delete(key);
        startTransition(() => setSubscriptions(prevSubscriptions => {
          if (prevSubscriptions.includes(key)) {
            return prevSubscriptions.filter(sub => sub !== key);
          }
          return prevSubscriptions;
        }));
      }
    };
  }, [cache, setSubscriptions]);
  return useMemo(() => ({
    cache,
    subscribe
  }), [cache, subscribe]);
}
const Turbo = memo(function Turbo2(props) {
  const {
    client,
    snapshots,
    cache,
    turboIds,
    setTurboIds
  } = props;
  const {
    projectId,
    dataset
  } = useMemo(() => {
    const {
      projectId: projectId2,
      dataset: dataset2
    } = client.config();
    return {
      projectId: projectId2,
      dataset: dataset2
    };
  }, [client]);
  useEffect(() => {
    var _a, _b;
    const nextTurboIds = /* @__PURE__ */new Set();
    for (const {
      query,
      params
    } of cache.values()) {
      const key = getQueryCacheKey(query, params);
      const snapshot = snapshots.get(key);
      if (snapshot && ((_b = (_a = snapshot.resultSourceMap) == null ? void 0 : _a.documents) == null ? void 0 : _b.length)) {
        for (const {
          _id
        } of snapshot.resultSourceMap.documents) {
          nextTurboIds.add(_id);
        }
      }
    }
    const nextTurboIdsSnapshot = [...nextTurboIds].sort();
    if (JSON.stringify(turboIds) !== JSON.stringify(nextTurboIdsSnapshot)) {
      startTransition(() => setTurboIds(nextTurboIdsSnapshot));
    }
  }, [cache, setTurboIds, snapshots, turboIds]);
  const [batch, setBatch] = useState([]);
  useEffect(() => {
    const batchSet = new Set(batch.flat());
    const nextBatch = /* @__PURE__ */new Set();
    for (const turboId of turboIds) {
      if (!batchSet.has(turboId) && !documentsCache.has(getTurboCacheKey(projectId, dataset, turboId))) {
        nextBatch.add(turboId);
      }
    }
    const nextBatchSlice = [...nextBatch].slice(0, 10);
    if (nextBatchSlice.length === 0) return;
    startTransition(() => setBatch(prevBatch => [...prevBatch.slice(-10), nextBatchSlice]));
  }, [batch, dataset, projectId, turboIds]);
  const [lastMutatedDocumentId, setLastMutatedDocumentId] = useState();
  useEffect(() => {
    const subscription = client.listen("*", {}, {
      events: ["mutation"],
      effectFormat: "mendoza",
      includePreviousRevision: false,
      includeResult: false
    }).subscribe(update => {
      var _a, _b;
      if (update.type !== "mutation" || !((_b = (_a = update.effects) == null ? void 0 : _a.apply) == null ? void 0 : _b.length)) return;
      const key = getTurboCacheKey(projectId, dataset, update.documentId);
      const cachedDocument = documentsCache.peek(key);
      if (cachedDocument) {
        const patchDoc = {
          ...cachedDocument
        };
        delete patchDoc._rev;
        const patchedDocument = applyPatch(patchDoc, update.effects.apply);
        documentsCache.set(key, patchedDocument);
      }
      startTransition(() => setLastMutatedDocumentId(update.documentId));
    });
    return () => subscription.unsubscribe();
  }, [client, dataset, projectId]);
  useEffect(() => {
    var _a, _b, _c;
    if (!lastMutatedDocumentId || !turboIds.includes(lastMutatedDocumentId)) return;
    const updatedKeys = [];
    for (const [key, snapshot] of snapshots.entries()) {
      if ((_b = (_a = snapshot.resultSourceMap) == null ? void 0 : _a.documents) == null ? void 0 : _b.length) {
        snapshot.result = turboChargeResultIfSourceMap(projectId, dataset, snapshot.result, snapshot.resultSourceMap);
        updatedKeys.push(key);
      }
    }
    for (const updatedKey of updatedKeys) {
      const listeners = (_c = cache.get(updatedKey)) == null ? void 0 : _c.listeners;
      if (listeners) {
        for (const listener of listeners) {
          listener();
        }
      }
    }
    startTransition(() => setLastMutatedDocumentId(void 0));
  }, [cache, dataset, lastMutatedDocumentId, projectId, snapshots, turboIds]);
  return /* @__PURE__ */jsx(Fragment, {
    children: batch.map(ids => /* @__PURE__ */jsx(GetDocuments, {
      client,
      projectId,
      dataset,
      ids
    }, JSON.stringify(ids)))
  });
});
const GetDocuments = memo(function GetDocuments2(props) {
  const {
    client,
    projectId,
    dataset,
    ids
  } = props;
  useEffect(() => {
    const missingIds = ids.filter(id => !documentsCache.has(getTurboCacheKey(projectId, dataset, id)));
    if (missingIds.length === 0) return;
    client.getDocuments(missingIds).then(documents => {
      for (const doc of documents) {
        if (doc && (doc == null ? void 0 : doc._id)) {
          documentsCache.set(getTurboCacheKey(projectId, dataset, doc._id), doc);
        }
      }
    }, console.error);
  }, [client, dataset, ids, projectId]);
  return null;
});
function turboChargeResultIfSourceMap(projectId, dataset, result, resultSourceMap) {
  if (!resultSourceMap) return result;
  return walkMap(result, (value, path) => {
    const resolveMappingResult = resolveMapping(path, resultSourceMap);
    if (!resolveMappingResult) {
      return value;
    }
    const [mapping,, pathSuffix] = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument = resultSourceMap.documents[mapping.source.document];
    const sourcePath = resultSourceMap.paths[mapping.source.path];
    if (sourceDocument && sourceDocument._id) {
      const cachedDocument = documentsCache.get(getTurboCacheKey(projectId, dataset, sourceDocument._id));
      const cachedValue = cachedDocument ? get(cachedDocument, parseNormalisedJsonPath(sourcePath + pathSuffix), value) : value;
      if (typeof cachedValue === "string" && typeof value === "string") {
        const {
          encoded
        } = vercelStegaSplit(value);
        const {
          cleaned
        } = vercelStegaSplit(cachedValue);
        return "".concat(encoded).concat(cleaned);
      }
      return cachedValue;
    }
    return value;
  });
}
export { LiveStoreProvider as default };
//# sourceMappingURL=index-f9874699.js.map
