const ESCAPE = {
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "'": "\\'",
  "\\": "\\\\"
};
const UNESCAPE = {
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	",
  "\\'": "'",
  "\\\\": "\\"
};
function normalisedJsonPath(path) {
  return "$".concat(path.map(key => {
    if (typeof key === "string") {
      const escapedKey = key.replace(/[\f\n\r\t'\\]/g, match => {
        return ESCAPE[match];
      });
      return "['".concat(escapedKey, "']");
    }
    return "[".concat(key, "]");
  }).join(""));
}
function parseNormalisedJsonPath(path) {
  const parsed = [];
  const parseRe = /\['(.*?)'\]|\[(\d+)\]/g;
  let match;
  while ((match = parseRe.exec(path)) !== null) {
    if (match[1] !== void 0) {
      const key = match[1].replace(/\\(\\|f|n|r|t|')/g, m => {
        return UNESCAPE[m];
      });
      parsed.push(key);
      continue;
    }
    if (match[2] !== void 0) {
      parsed.push(parseInt(match[2], 10));
      continue;
    }
  }
  return parsed;
}
function isRecord(value) {
  return typeof value === "object" && value !== null;
}
function isArray(value) {
  return value !== null && Array.isArray(value);
}
function encode(response, encoder) {
  if (!response.resultSourceMap) {
    throw new TypeError("Missing resultSourceMap");
  }
  response.result = encodeIntoResult(response, encoder);
  return response;
}
function encodeIntoResult(response, encoder) {
  return walkMap(response.result, (value, path) => {
    if (typeof value !== "string") {
      return value;
    }
    const resolveMappingResult = resolveMapping(path, response.resultSourceMap);
    if (!resolveMappingResult) {
      return value;
    }
    const [mapping,, pathSuffix] = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument =
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    response.resultSourceMap.documents[mapping.source.document];
    const sourcePath = response.resultSourceMap.paths[mapping.source.path];
    return encoder(value, sourceDocument, sourcePath + pathSuffix);
  });
}
function walkMap(value, mappingFn) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (isArray(value)) {
    return value.map((v, idx) => walkMap(v, mappingFn, path.concat(idx)));
  }
  if (isRecord(value)) {
    return Object.fromEntries(Object.entries(value).map(_ref => {
      let [k, v] = _ref;
      return [k, walkMap(v, mappingFn, path.concat(k))];
    }));
  }
  return mappingFn(value, path);
}
function resolveMapping(resultPath, csm, logger) {
  const resultJsonPath = normalisedJsonPath(resultPath);
  if (!csm.mappings) {
    logger == null ? void 0 : logger.error("Missing resultSourceMap.mappings", {
      resultSourceMap: csm
    });
    return void 0;
  }
  if (csm.mappings[resultJsonPath] !== void 0) {
    return [csm.mappings[resultJsonPath], resultJsonPath, ""];
  }
  const mappings = Object.entries(csm.mappings).filter(_ref2 => {
    let [key] = _ref2;
    return resultJsonPath.startsWith(key);
  }).sort((_ref3, _ref4) => {
    let [key1] = _ref3;
    let [key2] = _ref4;
    return key2.length - key1.length;
  });
  if (mappings.length == 0) {
    return void 0;
  }
  const [matchedPath, mapping] = mappings[0];
  const pathSuffix = resultJsonPath.substring(matchedPath.length);
  return [mapping, matchedPath, pathSuffix];
}
export { encode, encodeIntoResult, parseNormalisedJsonPath, resolveMapping, walkMap };
//# sourceMappingURL=sourcemap-0a868d9e.js.map
