'use strict';

var jsxRuntime = require('react/jsx-runtime');
var DefaultEventSource = require('@sanity/eventsource');
var groqStore = require('@sanity/groq-store');
var react = require('react');
var context = require('./context-6e668875.cjs');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var DefaultEventSource__default = /*#__PURE__*/_interopDefaultCompat(DefaultEventSource);
const GroqStoreProvider = react.memo(function GroqStoreProvider2(props) {
  const {
    children,
    logger,
    // The rest is the store config
    ...config
  } = props;
  const [ready] = react.useState(() => /* @__PURE__ */new Set());
  const [loadedListenersContext, updateLoadedListeners] = context.useLoadingListenersContext(ready);
  const [snapshots] = react.useState(() => /* @__PURE__ */new Map());
  const [store] = react.useState(() => groqStore.groqStore({
    // Override some of the store defaults
    EventSource: props.token ? DefaultEventSource__default.default : void 0,
    listen: true,
    overlayDrafts: true,
    documentLimit: context.DEFAULT_MAX_DOCUMENTS,
    // Spread in the rest
    ...config
  }));
  const report = react.useMemo(() => {
    if (config.listen) {
      return "Updates are applied in real-time. The cache is set to max ".concat(config.documentLimit, " documents.");
    }
    return "Updates require a manual refresh. The cache is set to max ".concat(config.documentLimit, " documents.");
  }, [config.documentLimit, config.listen]);
  react.useEffect(() => {
    if (logger) {
      logger.log("[@sanity/preview-kit]: With the current configuration you can expect that: ".concat(report));
    }
  }, [logger, report]);
  const [error, setError] = react.useState(null);
  if (error) throw error;
  const [listenerContext] = react.useState(() => {
    return function defineListener(initialSnapshot, query, params) {
      const key = context.getQueryCacheKey(query, params);
      if (!snapshots.has(key)) {
        snapshots.set(key, initialSnapshot);
      }
      const subscribe = onStoreChange => {
        if (!ready.has(key)) {
          store.query(query, params).then(result => {
            if (!ready.has(key)) {
              snapshots.set(key, result);
              ready.add(key);
              updateLoadedListeners();
              onStoreChange();
            }
          }, setError);
        }
        const subscription = store.subscribe(query, params, (err, result) => {
          if (err) {
            setError(err);
          } else if (ready.has(key)) {
            snapshots.set(key, result);
            onStoreChange();
          }
        });
        return () => subscription.unsubscribe();
      };
      const getSnapshot = () => snapshots.get(key);
      return {
        subscribe,
        getSnapshot
      };
    };
  });
  return /* @__PURE__ */jsxRuntime.jsx(context.defineListenerContext.Provider, {
    value: listenerContext,
    children: /* @__PURE__ */jsxRuntime.jsx(context.LoadedListenersContext.Provider, {
      value: loadedListenersContext,
      children
    })
  });
});
exports.GroqStoreProvider = GroqStoreProvider;
//# sourceMappingURL=GroqStoreProvider-eb0390a9.cjs.map
