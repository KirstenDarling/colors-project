import { useContext, useMemo, useState, useCallback, lazy, memo, useEffect, Suspense } from 'react';
import isFastEqual from 'react-fast-compare';
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';
import { defineListenerContext, LoadedListenersContext, getQueryCacheKey, DEFAULT_MAX_DOCUMENTS } from './_chunks/context-13c019e1.js';
import { jsx } from 'react/jsx-runtime';
function useLiveQuery(initialData, query, queryParams, options) {
  const {
    isEqual = isFastEqual
  } = options || {};
  const defineStore = useContext(defineListenerContext);
  const params = useParams(queryParams);
  const store = useMemo(() => defineStore(initialData, query, params), [defineStore, initialData, params, query]);
  const [serverSnapshot] = useState(() => {
    if (initialData === void 0) {
      throw new Error("initialSnapshot can't be undefined, if you don't want an initial value use null instead");
    }
    try {
      return JSON.parse(JSON.stringify(initialData));
    } catch (error) {
      console.warn("Failed to deep clone initialSnapshot, this is likely an error and an indication that the snapshot isn't JSON serializable", {
        initialSnapshot: initialData,
        error
      });
      return initialData;
    }
  });
  const getServerSnapshot = useCallback(() => serverSnapshot, [serverSnapshot]);
  const selector = useCallback(snapshot2 => snapshot2, []);
  const snapshot = useSyncExternalStoreWithSelector(store.subscribe, store.getSnapshot, getServerSnapshot, selector, isEqual);
  const loading = useLiveQueryIsLoading(query, params);
  return [snapshot, loading];
}
function useLiveQueryIsLoading(query, params) {
  const loadedListeners = useContext(LoadedListenersContext);
  const key = useMemo(() => getQueryCacheKey(query, params), [params, query]);
  return useMemo(() => {
    if (Array.isArray(loadedListeners)) {
      return loadedListeners.includes(key) ? false : true;
    }
    return false;
  }, [key, loadedListeners]);
}
function useListeningQuery(initialSnapshot, query, queryParams, options) {
  const [snapshot] = useLiveQuery(initialSnapshot, query, queryParams, options);
  return snapshot;
}
function useListeningQueryStatus(query, queryParams) {
  const params = useParams(queryParams);
  const loading = useLiveQueryIsLoading(query, params);
  return loading ? "loading" : "success";
}
function useParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params || {}), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
const LazyGroqStoreProvider = lazy(() => import('./_chunks/index-55699f1a.js'));
const LiveStoreProvider = lazy(() => import('./_chunks/index-f9874699.js'));
const LiveQueryProvider = memo(function LiveQueryProvider2(props) {
  const {
    children,
    experimental__turboSourceMap = false,
    experimental__refreshInterval
  } = props;
  const [client] = useState(() => props.client);
  const [cache] = useState(() => props.cache);
  const [logger] = useState(() => props.logger);
  useEffect(() => {
    if (experimental__refreshInterval || experimental__turboSourceMap) {
      logger == null ? void 0 : logger.warn("[@sanity/preview-kit]: You are using experimental features, these may have breaking changes in minor releases");
    }
  }, [experimental__refreshInterval, experimental__turboSourceMap, logger]);
  if (experimental__turboSourceMap) {
    return /* @__PURE__ */jsx(Suspense, {
      fallback: children,
      children: /* @__PURE__ */jsx(LiveStoreProvider, {
        client,
        logger,
        refreshInterval: experimental__refreshInterval,
        turboSourceMap: experimental__turboSourceMap,
        children
      })
    });
  }
  return /* @__PURE__ */jsx(SelectStoreProvider, {
    client,
    cache,
    logger,
    experimental__refreshInterval,
    children
  });
});
const SelectStoreProvider = memo(function SelectStoreProvider2(props) {
  var _a;
  const {
    children,
    experimental__refreshInterval = 0,
    client,
    cache,
    logger
  } = props;
  const maxDocuments = (_a = cache == null ? void 0 : cache.maxDocuments) != null ? _a : DEFAULT_MAX_DOCUMENTS;
  const [documentsCount, setDocumentsCount] = useState(null);
  const [error, setError] = useState(null);
  const [includeTypes] = useState(() => {
    var _a2;
    return (_a2 = cache == null ? void 0 : cache.includeTypes) != null ? _a2 : [];
  });
  if (error) {
    throw error;
  }
  useEffect(() => {
    if (documentsCount !== null) {
      return;
    }
    logger == null ? void 0 : logger.log("[@sanity/preview-kit]: fetch documents count");
    const controller = new AbortController();
    client.fetch(includeTypes.length > 0 ? "count(*[_type in $includeTypes])" : "count(*)", {
      includeTypes
    }, {
      filterResponse: true,
      signal: controller.signal
    }).then(result => {
      logger == null ? void 0 : logger.log("[@sanity/preview-kit]: documents count", result);
      setDocumentsCount(result);
    }).catch(error2 => {
      if (error2.name !== "AbortError") {
        setError(error2);
      }
    });
    return () => {
      controller.abort();
    };
  }, [client, documentsCount, includeTypes, logger]);
  if (documentsCount === null) {
    return children;
  }
  if (experimental__refreshInterval && documentsCount >= maxDocuments) {
    return /* @__PURE__ */jsx(Suspense, {
      fallback: children,
      children: /* @__PURE__ */jsx(LiveStoreProvider, {
        client,
        refreshInterval: experimental__refreshInterval,
        turboSourceMap: false,
        logger,
        children
      })
    });
  }
  if (documentsCount >= maxDocuments) {
    throw new Error("[@sanity/preview-kit]: You have ".concat(documentsCount, " documents in your dataset, which is more than the maximum of ").concat(maxDocuments, " documents. Please reduce the number of documents in your dataset or increase the limit."));
  }
  return /* @__PURE__ */jsx(Suspense, {
    fallback: children,
    children: /* @__PURE__ */jsx(GroqStoreProvider, {
      ...props,
      children
    })
  });
});
const GroqStoreProvider = memo(function GroqStoreProvider2(props) {
  var _a;
  const {
    children,
    client,
    cache,
    logger
  } = props;
  const {
    projectId,
    dataset,
    token,
    perspective = "previewDrafts"
  } = useMemo(() => client.config(), [client]);
  return /* @__PURE__ */jsx(LazyGroqStoreProvider, {
    projectId,
    dataset,
    token,
    logger,
    listen: (_a = cache == null ? void 0 : cache.listen) != null ? _a : true,
    documentLimit: cache == null ? void 0 : cache.maxDocuments,
    overlayDrafts: perspective === "previewDrafts",
    includeTypes: cache == null ? void 0 : cache.includeTypes,
    children
  });
});
export { LiveQueryProvider, useListeningQuery, useListeningQueryStatus, useLiveQuery };
//# sourceMappingURL=index.js.map
