import { requester, SanityClient, createClient as createClient$1 } from '@sanity/client';
import isPlainObject from 'lodash.isplainobject';
import invariant from 'tiny-invariant';
import { vercelStegaCombine } from '@vercel/stega';
import { parseNormalisedJsonPath, encode, encodeIntoResult } from './_chunks/sourcemap-0a868d9e.js';
function defineEditLink(_studioUrl) {
  const studioUrl = _studioUrl.replace(/\/$/, "");
  return (sourceDocument, path) => "".concat(studioUrl, "/intent/edit/id=").concat(sourceDocument._id, ";path=").concat(encodeJsonPathToUriComponent(path));
}
function encodeJsonPathToUriComponent(path) {
  const sourcePath = Array.isArray(path) ? path : parseNormalisedJsonPath(path);
  return encodeURIComponent(sourcePath.map((key, i) =>
  // eslint-disable-next-line no-nested-ternary
  typeof key === "number" ? "[".concat(key, "]") : i > 0 ? ".".concat(key) : key).join(""));
}
const filterDefault = _ref => {
  let {
    path
  } = _ref;
  const endPath = path.at(-1);
  if (path.at(-2) === "slug" && endPath === "current") {
    return false;
  }
  if (typeof endPath === "string" && endPath.startsWith("_")) {
    return false;
  }
  if (typeof endPath === "number" && path.at(-2) === "marks" && typeof path.at(-3) === "number" && path.at(-4) === "children" && typeof path.at(-5) === "number") {
    return false;
  }
  if (endPath === "href" && typeof path.at(-2) === "number" && path.at(-3) === "markDefs" && typeof path.at(-4) === "number") {
    return false;
  }
  if (typeof endPath === "string" && typeof path.at(-2) === "number") {
    if (endPath === "style" || endPath === "listItem") {
      return false;
    }
  }
  return true;
};
const TRUNCATE_LENGTH = 20;
function createTranscoder(studioUrl, encodeSourceMapAtPath, logger) {
  const createEditLink = defineEditLink(studioUrl);
  const report = {
    encoded: [],
    skipped: []
  };
  const transcode = (input, sourceDocument, sourcePath) => {
    if ((typeof encodeSourceMapAtPath === "function" ? encodeSourceMapAtPath({
      path: sourcePath,
      filterDefault
    }) : filterDefault({
      path: sourcePath,
      filterDefault
    })) === false) {
      if (logger) {
        report.skipped.push({
          path: prettyPathForLogging(sourcePath),
          value: "".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? "..." : ""),
          length: input.length
        });
      }
      return input;
    }
    if (logger) {
      report.encoded.push({
        path: prettyPathForLogging(sourcePath),
        value: "".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? "..." : ""),
        length: input.length
      });
    }
    return vercelStegaCombine(input, {
      origin: "sanity.io",
      href: createEditLink(sourceDocument, sourcePath)
    }, "auto");
  };
  return {
    report,
    transcode,
    walk: input => {
      report.encoded.length = 0;
      report.skipped.length = 0;
      return encode(input, (value, sourceDocument, path) => transcode(value, sourceDocument, parseNormalisedJsonPath(path)));
    }
  };
}
function prettyPathForLogging(path) {
  return path.map((segment, index) => typeof segment === "number" ? "[".concat(segment, "]") : index > 0 ? ".".concat(segment) : segment).join("");
}
function transcodeResponse(_ref2) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref2;
  const transcoder = createTranscoder(studioUrl, encodeSourceMapAtPath, logger);
  return {
    onResponse: response => {
      if (!isBodyResponse(response)) {
        return response;
      }
      if (Array.isArray(response.body) || typeof response.body === "string" || isPlainObject(response.body)) {
        if (!isContentSourceMapBody(response.body)) {
          if (logger) {
            logger == null ? void 0 : logger.error("[@sanity/preview-kit]: Missing Content Source Map from response body", response.body);
          }
          return response;
        }
        const body = transcoder.walk(response.body);
        if (logger) {
          const isSkipping = transcoder.report.skipped.length;
          const isEncoding = transcoder.report.encoded.length;
          if (isSkipping || isEncoding) {
            logger == null ? void 0 : logger.groupCollapsed("[@sanity/preview-kit]: Stega encoding source map into result");
            logger == null ? void 0 : logger.log("[@sanity/preview-kit]: Paths encoded: ".concat(transcoder.report.encoded.length, ", skipped: ").concat(transcoder.report.skipped.length));
          }
          if (transcoder.report.encoded.length > 0) {
            logger == null ? void 0 : logger.log("[@sanity/preview-kit]: Table of encoded paths");
            logger == null ? void 0 : logger.table(transcoder.report.encoded);
          }
          if (transcoder.report.skipped.length > 0) {
            const skipped = /* @__PURE__ */new Set();
            for (const {
              path
            } of transcoder.report.skipped) {
              skipped.add(path.replace(/\[\d+\]/g, "[]"));
            }
            logger == null ? void 0 : logger.log("[@sanity/preview-kit]: List of skipped paths", [...skipped.values()]);
          }
          if (isSkipping || isEncoding) {
            logger == null ? void 0 : logger.groupEnd();
          }
        }
        return {
          ...response,
          body
        };
      }
      return response;
    }
  };
}
function createHttpRequest(_ref3) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref3;
  invariant(studioUrl, "Missing studioUrl in client config");
  const superRequester = requester.clone();
  superRequester.use(transcodeResponse({
    studioUrl,
    encodeSourceMapAtPath,
    logger
  }));
  function httpRequest(options) {
    let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : superRequester;
    return requester({
      maxRedirects: 0,
      ...options
    });
  }
  httpRequest.defaultRequester = superRequester;
  return httpRequest;
}
function isBodyResponse(response) {
  return typeof response === "object" && response !== null;
}
function isContentSourceMapBody(body) {
  return typeof body === "object" && body !== null && "resultSourceMap" in body;
}
function mapToEditLinks(response, studioUrl) {
  const createEditLink = defineEditLink(studioUrl);
  return encodeIntoResult(response, (_, sourceDocument, path) => {
    return createEditLink(sourceDocument, path);
  });
}
const createClient = config => {
  const {
    encodeSourceMap = detectEnableSourceMap(),
    studioUrl = detectStudioUrl(),
    logger
  } = config;
  let shouldEncodeSourceMap = encodeSourceMap === true;
  if (encodeSourceMap === "auto") {
    shouldEncodeSourceMap = isVercelPreviewEnvironment();
  }
  try {
    if (shouldEncodeSourceMap && config.resultSourceMap !== false) {
      logger == null ? void 0 : logger.debug("[@sanity/preview-kit]: Creating source map enabled client");
      const httpRequest = createHttpRequest({
        ...config,
        studioUrl
      });
      return new SanityClient(httpRequest, {
        ...config,
        // Source maps by Content Lake are required in order to know where to insert the encoded source maps into strings
        resultSourceMap: true
      });
    }
  } catch (err) {
    console.error("[@sanity/preview-kit]: Error creating client", err, "falling back to non-embedded sourcemap mode");
  }
  return createClient$1(config);
};
function isVercelPreviewEnvironment() {
  try {
    return import.meta.env.VERCEL_ENV === "preview";
  } catch {}
  try {
    return process.env.VERCEL_ENV === "preview";
  } catch {}
  return false;
}
function detectEnableSourceMap() {
  try {
    return import.meta.env.SANITY_SOURCE_MAP === "true" || "auto";
  } catch {}
  try {
    return process.env.SANITY_SOURCE_MAP === "true" || "auto";
  } catch {}
  return "auto";
}
function detectStudioUrl() {
  try {
    return import.meta.env.SANITY_STUDIO_URL;
  } catch {}
  try {
    return process.env.SANITY_STUDIO_URL;
  } catch {}
}
export { createClient, mapToEditLinks };
//# sourceMappingURL=client.js.map
