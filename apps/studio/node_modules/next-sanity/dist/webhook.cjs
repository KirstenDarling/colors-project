'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var sanityWebhook = require('@sanity/webhook');
var server = require('next/server');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var sanityWebhook__default = /*#__PURE__*/_interopDefaultCompat(sanityWebhook);
const config = {
  api: {
    /**
     * Next.js will by default parse the body, which can lead to invalid signatures.
     */
    bodyParser: false
  },
  /**
   * `@sanity/webhook` isn't updated to support the edge runtime yet, and currently requires Node.js APIs such as Buffer.
   */
  runtime: "nodejs"
};
async function _readBody(readable) {
  const chunks = [];
  for await (const chunk of readable) {
    chunks.push(typeof chunk === "string" ? Buffer.from(chunk) : chunk);
  }
  return Buffer.concat(chunks).toString("utf8");
}
const {
  isValidSignature,
  SIGNATURE_HEADER_NAME
} = sanityWebhook__default.default;
async function parseBody(req, secret) {
  let waitForContentLakeEventualConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let signature;
  if (req instanceof server.NextRequest) {
    signature = req.headers.get(SIGNATURE_HEADER_NAME);
  } else {
    signature = req.headers[SIGNATURE_HEADER_NAME];
  }
  if (Array.isArray(signature)) {
    signature = signature[0];
  }
  let body;
  if (req instanceof server.NextRequest) {
    body = JSON.stringify(await req.json());
  } else {
    body = await _readBody(req);
  }
  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null;
  if (validSignature !== false && waitForContentLakeEventualConsistency) {
    await new Promise(resolve => setTimeout(resolve, 1e3));
  }
  return {
    body: body.trim() && JSON.parse(body),
    isValidSignature: validSignature
  };
}
exports.config = config;
exports.parseBody = parseBody;
//# sourceMappingURL=webhook.cjs.map
