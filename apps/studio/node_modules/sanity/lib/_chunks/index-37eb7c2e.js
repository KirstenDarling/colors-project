var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import React, { useState, useEffect, useMemo, useCallback, useContext, memo, lazy, Suspense, useRef, createElement, useId, forwardRef, isValidElement, useLayoutEffect, Fragment as Fragment$1 } from 'react';
import { useElementRect, Card, Container, Heading, Stack, Label, Code, Box, Text, Button, Flex, _raf2, Spinner, useToast, AvatarStack, rem, Popover, useClickOutside, useGlobalKeyDown, BoundaryElementProvider, TextInput, Dialog, TabList, Tab, TabPanel, focusFirstDescendant, MenuButton, Menu, Inline, usePortal, PortalProvider, useLayer, Grid, MenuItem, Tooltip, Hotkeys, LayerProvider, Badge, DialogProvider, ErrorBoundary } from '@sanity/ui';
import { ChildLink, BackLink, ReferenceChildLink, ParameterizedLink, PaneRouterContext, PANE_DEFAULT_MIN_WIDTH, PANE_COLLAPSED_WIDTH, PaneLayoutContext, Root as Root$6, DeskToolContext, LOADING_PANE, SerializeError, Pane, PaneHeader, PaneContent, useDocumentPane, usePaneRouter, DocumentPaneContext, usePane, DocTitle, PaneContextMenuButton, usePaneLayout, DOCUMENT_PANEL_PORTAL_ELEMENT, HistoryRestoreAction, PaneFooter, setActivePanes, DeskToolProvider } from './desk-c925d322.js';
import omit from 'lodash/omit.js';
import { isObservable, from, of, firstValueFrom, NEVER, concat, ReplaySubject, merge } from 'rxjs';
import { nanoid } from 'nanoid';
import { switchMap, publishReplay, refCount, map, startWith, pairwise, scan, distinctUntilChanged, mapTo, delay, debounceTime, catchError, tap } from 'rxjs/operators';
import { GetHookCollectionState, isRecord, useDocumentStore, isDev, useDocumentOperationEvent, useSource, useSchema, useTemplates, usePresenceStore, useUnique, getPublishedId, useInitialValue, useDocumentOperation, useEditState, useValidationStatus, useConnectionState, useTimelineStore, useTimelineSelector, toMutationPatches, setAtPath, getDraftId, useDocumentValuePermissions, useFormState, getExpandOperations, UserAvatar, CommandList, TextWithTone, visitDiff, ScrollContainer, ChangeFieldWrapper, DiffTooltip, NoChanges, DocumentChangeContext, ChangeList, useSettingsStore, isString, useDocumentPreviewStore, useCurrentUser, useDocumentPresence, createPatchChannel, PresenceOverlay, FormBuilder, fromMutationPatches, ValidationList, unstable_useValuePreview, VirtualizerScrollInstanceProvider, LegacyLayerProvider, useTimeAgo, useSyncState, ChangeConnectorRoot, SourceProvider, useDocumentType, useTemplatePermissions, ReferenceInputOptionsProvider, useZIndex, _isCustomDocumentTypeDefinition, useWorkspace } from 'sanity';
import { generateHelpUrl } from '@sanity/generate-help-url';
import isEqual from 'lodash/isEqual.js';
import { useRouter, useRouterState } from 'sanity/router';
import { uuid } from '@sanity/uuid';
import styled, { css, keyframes } from 'styled-components';
import { SyncIcon, RestoreIcon, BinaryDocumentIcon, EarthAmericasIcon, AddCircleIcon, TrashIcon, CloseIcon, EditIcon, PublishIcon, UnpublishIcon, ErrorOutlineIcon, SelectIcon, SearchIcon, WarningOutlineIcon, ReadOnlyIcon, InfoOutlineIcon, ArrowLeftIcon, SplitVerticalIcon, ChevronDownIcon, PlayIcon } from '@sanity/icons';
import 'lodash/camelCase.js';
import 'speakingurl';
import 'lodash/uniq.js';
import 'lodash/kebabCase.js';
import 'lodash/pickBy.js';
import 'lodash/find.js';
import 'lodash/uniqueId.js';
import { isValidElementType } from 'react-is';
import 'lodash/startCase.js';
import isHotkey from 'is-hotkey';
import { toString, fromString, resolveKeyedPath, get } from '@sanity/util/paths';
import { isValidationErrorMarker, isValidationWarningMarker, isValidationInfoMarker } from '@sanity/types';
import 'lodash/isNumber.js';
import 'lodash/isString.js';
import { useAsObservable, useMemoObservable } from 'react-rx';
import { isActionEnabled } from '@sanity/schema/_internal';
import { format } from 'date-fns';
import upperFirst from 'lodash/upperFirst.js';
import JSONInspector from '@rexxars/react-json-inspector';
import HLRU from 'hashlru';
import negate from 'lodash/negate.js';
import { motion } from 'framer-motion';
function Delay(_ref) {
  let {
    children,
    ms = 0
  } = _ref;
  const [ready, setReady] = useState(ms <= 0);
  useEffect(() => {
    if (ms <= 0) {
      return void 0;
    }
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]);
  if (!ready || !children) {
    return /* @__PURE__ */jsx(Fragment, {});
  }
  return typeof children === "function" ? children() : children;
}
const RenderActionCollectionState = props => {
  const {
    actions,
    children,
    actionProps,
    onActionComplete
  } = props;
  return /* @__PURE__ */jsx(GetHookCollectionState, {
    onReset: onActionComplete,
    hooks: actions,
    args: actionProps,
    children
  });
};
const RenderBadgeCollectionState = props => {
  const {
    badges,
    children,
    badgeProps,
    ...rest
  } = props;
  return /* @__PURE__ */jsx(GetHookCollectionState, {
    ...rest,
    hooks: badges,
    args: badgeProps,
    children
  });
};
const emptyArray = [];
function PaneRouterProvider(props) {
  const {
    children,
    flatIndex,
    index,
    params,
    payload,
    siblingIndex
  } = props;
  const {
    navigate,
    navigateIntent
  } = useRouter();
  const routerState = useRouterState();
  const routerPaneGroups = useMemo(() => (routerState == null ? void 0 : routerState.panes) || emptyArray, [routerState == null ? void 0 : routerState.panes]);
  const groupIndex = index - 1;
  const modifyCurrentGroup = useCallback(modifier => {
    const currentGroup = routerPaneGroups[groupIndex] || [];
    const currentItem = currentGroup[siblingIndex];
    const nextGroup = modifier(currentGroup, currentItem);
    const nextPanes = [...routerPaneGroups.slice(0, groupIndex), nextGroup, ...routerPaneGroups.slice(groupIndex + 1)];
    const nextRouterState = {
      ...(routerState || {}),
      panes: nextPanes
    };
    setTimeout(() => navigate(nextRouterState), 0);
    return nextRouterState;
  }, [groupIndex, navigate, routerPaneGroups, routerState, siblingIndex]);
  const setPayload = useCallback(nextPayload => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      payload: nextPayload
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const setParams = useCallback(nextParams => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const handleEditReference = useCallback(_ref2 => {
    let {
      id,
      parentRefPath,
      type,
      template
    } = _ref2;
    navigate({
      panes: [...routerPaneGroups.slice(0, groupIndex + 1), [{
        id,
        params: {
          template: template.id,
          parentRefPath: toString(parentRefPath),
          type
        },
        payload: template.params
      }]]
    });
  }, [groupIndex, navigate, routerPaneGroups]);
  const ctx = useMemo(() => ({
    // Zero-based index (position) of pane, visually
    index: flatIndex,
    // Zero-based index of pane group (within URL structure)
    groupIndex,
    // Zero-based index of pane within sibling group
    siblingIndex,
    // Payload of the current pane
    payload,
    // Params of the current pane
    params,
    // Whether or not the pane has any siblings (within the same group)
    hasGroupSiblings: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length > 1 : false,
    // The length of the current group
    groupLength: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0,
    // Current router state for the "panes" property
    routerPanesState: routerPaneGroups,
    // Curried StateLink that passes the correct state automatically
    ChildLink,
    // Curried StateLink that pops off the last pane group
    BackLink,
    // A specialized `ChildLink` that takes in the needed props to open a
    // referenced document to the right
    ReferenceChildLink,
    // Similar to `ReferenceChildLink` expect without the wrapping component
    handleEditReference,
    // Curried StateLink that passed the correct state, but merges params/payload
    ParameterizedLink,
    // Replaces the current pane with a new one
    replaceCurrent: function () {
      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      modifyCurrentGroup(() => [{
        id: opts.id || "",
        payload: opts.payload,
        params: opts.params || {}
      }]);
    },
    // Removes the current pane from the group
    closeCurrent: () => {
      modifyCurrentGroup((siblings, item) => siblings.length > 1 ? siblings.filter(sibling => sibling !== item) : siblings);
    },
    // Duplicate the current pane, with optional overrides for payload, parameters
    duplicateCurrent: options => {
      modifyCurrentGroup((siblings, item) => {
        const duplicatedItem = {
          ...item,
          payload: (options == null ? void 0 : options.payload) || item.payload,
          params: (options == null ? void 0 : options.params) || item.params
        };
        return [...siblings.slice(0, siblingIndex), duplicatedItem, ...siblings.slice(siblingIndex)];
      });
    },
    // Set the view for the current pane
    setView: viewId => {
      const restParams = omit(params, "view");
      return setParams(viewId ? {
        ...restParams,
        view: viewId
      } : restParams);
    },
    // Set the parameters for the current pane
    setParams,
    // Set the payload for the current pane
    setPayload,
    // Proxied navigation to a given intent. Consider just exposing `router` instead?
    navigateIntent
  }), [flatIndex, groupIndex, handleEditReference, modifyCurrentGroup, navigateIntent, params, payload, routerPaneGroups, setParams, setPayload, siblingIndex]);
  return /* @__PURE__ */jsx(PaneRouterContext.Provider, {
    value: ctx,
    children
  });
}
function _calcPaneResize(cache, left, right, deltaX) {
  var _a, _b;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  };
  const leftMinWidth = (_a = left.minWidth) != null ? _a : PANE_DEFAULT_MIN_WIDTH;
  const rightMinWidth = (_b = right.minWidth) != null ? _b : PANE_DEFAULT_MIN_WIDTH;
  const leftMaxWidth = Math.min(left.maxWidth || Infinity, sum.width - rightMinWidth);
  const rightMaxWidth = Math.min(right.maxWidth || Infinity, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  if (minDeltaX < rightMinDeltaX) {
    minDeltaX = rightMinDeltaX;
  }
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  if (maxDeltaX > leftMaxDeltaX) {
    maxDeltaX = leftMaxDeltaX;
  }
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX);
  const leftW = cache.left.width + _deltaX;
  const rightW = cache.right.width - _deltaX;
  const leftFlex = leftW / sum.width * sum.flex;
  const rightFlex = rightW / sum.width * sum.flex;
  return {
    leftFlex,
    leftW,
    rightFlex,
    rightW
  };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map = /* @__PURE__ */new WeakMap();
  for (const element of elements) {
    map.set(element, _getDOMPath(rootElement, element));
  }
  const _sortByElementPath = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH;
    const _b = map.get(b) || EMPTY_PATH;
    const len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1;
      const bIndex = _b[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [];
  const elements = [];
  const optionsMap = /* @__PURE__ */new WeakMap();
  const userCollapsedElementSet = /* @__PURE__ */new Set();
  const cache = {};
  let rootElement = null;
  let rootWidth = 0;
  let expandedElement = null;
  let resizeDataMap = /* @__PURE__ */new Map();
  let resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element);
    if (expandedElement === element) {
      expandedElement = null;
    }
    _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element);
    expandedElement = element;
    _notifyObservers();
  }
  function mount(element, options) {
    optionsMap.set(element, {
      ...options,
      original: options
    });
    elements.push(element);
    if (rootElement) {
      _sortElements(rootElement, elements);
    }
    expand(element);
    return () => {
      const idx = elements.indexOf(element);
      if (idx > -1) {
        elements.splice(idx, 1);
      }
      optionsMap.delete(element);
      _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a, _b, _c, _d;
    const leftIndex = elements.indexOf(leftElement);
    const leftOptions = optionsMap.get(leftElement);
    if (!leftOptions) return;
    const rightElement = elements[leftIndex + 1];
    const rightOptions = optionsMap.get(rightElement);
    if (!rightOptions) return;
    if (type === "start") {
      resizing = true;
      cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      };
      cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      };
      _notifyObservers();
    }
    if (type === "move" && cache.left && cache.right) {
      resizeDataMap = /* @__PURE__ */new Map();
      const {
        leftW,
        rightW,
        leftFlex,
        rightFlex
      } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
      resizeDataMap.set(leftElement, {
        flex: leftFlex,
        width: leftW
      });
      resizeDataMap.set(rightElement, {
        flex: rightFlex,
        width: rightW
      });
      _notifyObservers();
    }
    if (type === "end") {
      resizing = false;
      const leftResizeData = resizeDataMap.get(leftElement);
      const rightResizeData = resizeDataMap.get(rightElement);
      optionsMap.set(leftElement, {
        ...leftOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_a = leftOptions.maxWidth) != null ? _a : Infinity,
        flex: (_b = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b : leftOptions.flex
      });
      optionsMap.set(rightElement, {
        ...rightOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_c = leftOptions.maxWidth) != null ? _c : Infinity,
        flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
      });
      resizeDataMap = /* @__PURE__ */new Map();
      delete cache.left;
      delete cache.right;
      _notifyObservers();
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth;
    _notifyObservers();
  }
  function subscribe(observer) {
    observers.push(observer);
    return () => {
      const idx = observers.push(observer);
      if (idx > -1) {
        observers.splice(idx, 1);
      }
    };
  }
  return {
    collapse,
    expand,
    mount,
    resize,
    setRootElement,
    setRootWidth,
    subscribe
  };
  function _notifyObservers() {
    var _a, _b, _c, _d;
    if (!rootWidth) return;
    const _elements = [];
    for (const element of elements) {
      if (element !== expandedElement) {
        _elements.unshift(element);
      }
    }
    if (expandedElement) {
      _elements.unshift(expandedElement);
    }
    const dataMap = /* @__PURE__ */new WeakMap();
    const len = _elements.length;
    const lastElement = _elements[0];
    const collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options) {
        continue;
      }
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH;
      const isLast = element === lastElement;
      const userCollapsed = userCollapsedElementSet.has(element);
      const sizeCollapsed = minWidth > remaingWidth;
      const collapsed = isLast ? false : userCollapsed || sizeCollapsed;
      const resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a = resizeData == null ? void 0 : resizeData.width) != null ? _a : options.currentMinWidth,
        currentMaxWidth: (_b = resizeData == null ? void 0 : resizeData.width) != null ? _b : options.currentMaxWidth,
        flex: (_d = (_c = resizeData == null ? void 0 : resizeData.flex) != null ? _c : options.flex) != null ? _d : 1
      });
      if (collapsed) {
        remaingWidth -= PANE_COLLAPSED_WIDTH;
      } else {
        remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
      }
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      if (data) panes.push(data);
    }
    for (const observer of observers) {
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
    }
  }
}
function PaneLayout(props) {
  const {
    children,
    minWidth,
    onCollapse,
    onExpand,
    ...restProps
  } = props;
  const controller = useMemo(() => createPaneLayoutController(), []);
  const [rootElement, setRootElement] = useState(null);
  const rootRect = useElementRect(rootElement);
  const width = (rootRect == null ? void 0 : rootRect.width) || 0;
  const collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  const [state, setState] = useState({
    expandedElement: null,
    panes: [],
    resizing: false
  });
  useEffect(() => controller.setRootElement(rootElement), [controller, rootElement]);
  useEffect(() => controller.setRootWidth(width), [controller, width]);
  useEffect(() => controller.subscribe(setState), [controller]);
  useEffect(() => {
    if (collapsed === void 0) return;
    if (collapsed && onCollapse) onCollapse();
    if (!collapsed && onExpand) onExpand();
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = useMemo(() => ({
    collapse: controller.collapse,
    collapsed,
    expand: controller.expand,
    expandedElement: state.expandedElement,
    mount: controller.mount,
    panes: state.panes,
    resize: controller.resize,
    resizing: state.resizing
  }), [collapsed, controller, state.expandedElement, state.panes, state.resizing]);
  return /* @__PURE__ */jsx(PaneLayoutContext.Provider, {
    value: paneLayout,
    children: /* @__PURE__ */jsx(Root$6, {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    })
  });
}
class PaneResolutionError extends Error {
  constructor(_ref3) {
    let {
      message,
      context,
      helpId,
      cause
    } = _ref3;
    super(message);
    this.context = context;
    this.helpId = helpId;
    this.cause = cause;
  }
}
const randomIdCache = /* @__PURE__ */new WeakMap();
function assignId(obj) {
  const cachedValue = randomIdCache.get(obj);
  if (cachedValue) return cachedValue;
  const id = nanoid();
  randomIdCache.set(obj, id);
  return id;
}
const bindCache = /* @__PURE__ */new WeakMap();
function memoBind(obj, methodKey) {
  const boundMethods = bindCache.get(obj) || /* @__PURE__ */new Map();
  if (boundMethods) {
    const bound2 = boundMethods.get(methodKey);
    if (bound2) return bound2;
  }
  const method = obj[methodKey];
  if (typeof method !== "function") {
    throw new Error("Expected property `".concat(methodKey, "` to be a function but got ").concat(typeof method, " instead."));
  }
  const bound = method.bind(obj);
  boundMethods.set(methodKey, bound);
  bindCache.set(obj, boundMethods);
  return bound;
}
const isPromise = thing => {
  return !!thing && typeof (thing == null ? void 0 : thing.then) === "function";
};
const isSerializable = thing => {
  if (!isRecord(thing)) return false;
  return typeof thing.serialize === "function";
};
const rethrowWithPaneResolutionErrors = next => (unresolvedPane, context, flatIndex) => {
  try {
    return next(unresolvedPane, context, flatIndex);
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      throw e;
    }
    throw new PaneResolutionError({
      message: typeof (e == null ? void 0 : e.message) === "string" ? e.message : "",
      context,
      cause: e
    });
  }
};
const wrapWithPublishReplay = next => function () {
  return next(...arguments).pipe(
  // need to add publishReplay + refCount to ensure new subscribers always
  // get an emission. without this, memoized observables may get stuck
  // waiting for their first emissions resulting in a loading pane
  publishReplay(1), refCount());
};
function createPaneResolver(middleware) {
  const resolvePane = rethrowWithPaneResolutionErrors(wrapWithPublishReplay(middleware((unresolvedPane, context, flatIndex) => {
    if (!unresolvedPane) {
      throw new PaneResolutionError({
        message: "Pane returned no child",
        context,
        helpId: "structure-item-returned-no-child"
      });
    }
    if (isPromise(unresolvedPane) || isObservable(unresolvedPane)) {
      return from(unresolvedPane).pipe(switchMap(result => resolvePane(result, context, flatIndex)));
    }
    if (isSerializable(unresolvedPane)) {
      return resolvePane(unresolvedPane.serialize(context), context, flatIndex);
    }
    if (typeof unresolvedPane === "function") {
      return resolvePane(unresolvedPane(context.id, context), context, flatIndex);
    }
    return of(unresolvedPane);
  })));
  return resolvePane;
}
async function resolveIntent(options) {
  const resolvedPaneCache = /* @__PURE__ */new Map();
  const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(context.path.join("__"));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane) return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key) resolvedPaneCache.set(key, result);
    return result;
  };
  const resolvePane = createPaneResolver(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: {
      ...omit(options.params, ["id"]),
      type: options.params.type
    },
    payload: options.payload
  }]];
  async function traverse(_ref4) {
    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref4;
    var _a;
    if (!unresolvedPane) return [];
    const {
      id: targetId,
      type: schemaTypeName,
      ...otherParams
    } = params;
    const context = {
      id: currentId,
      splitIndex: 0,
      parent,
      path,
      index: flatIndex,
      params: {},
      payload: void 0,
      structureContext
    };
    const resolvedPane = await firstValueFrom(resolvePane(unresolvedPane, context, flatIndex));
    if (resolvedPane.type === "document" && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map(i => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (
    // if the resolve pane's `canHandleIntent` returns true, then resolve
    ((_a = resolvedPane.canHandleIntent) == null ? void 0 : _a.call(resolvedPane, intent, params, {
      pane: resolvedPane,
      index: flatIndex
    })) ||
    // if the pane's `canHandleIntent` did not return true, then match against
    // this default case. we will resolve the intent if:
    resolvedPane.type === "documentList" &&
    // 1. the schema type matches (this required for the document to render)
    resolvedPane.schemaTypeName === schemaTypeName &&
    // 2. the filter is the default filter.
    //
    // NOTE: this case is to prevent false positive matches where the user
    // has configured a more specific filter for a particular type. In that
    // case, the user can implement their own `canHandleIntent` function
    resolvedPane.options.filter === "_type == $type") {
      return [{
        panes: [
        // map the current path to router panes
        ...path.map(id => [{
          id
        }]),
        // then augment with the intents IDs and params
        [{
          id: params.id,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (resolvedPane.type === "list" && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === "divider") return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === "function" ? memoBind(resolvedPane, "child") : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }
    return [];
  }
  const matchingPanes = await traverse({
    currentId: "root",
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];
  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }
  return fallbackEditorPanes;
}
function useDeskTool() {
  const deskTool = useContext(DeskToolContext);
  if (!deskTool) throw new Error("DeskTool: missing context value");
  return deskTool;
}
const fallbackEditorChild = (nodeId, context) => {
  const id = nodeId.replace(/^__edit__/, "");
  const {
    params,
    payload,
    structureContext: {
      resolveDocumentNode
    }
  } = context;
  const {
    type,
    template
  } = params;
  if (!type) {
    throw new Error("Document type for document with ID ".concat(id, " was not provided in the router params."));
  }
  let defaultDocumentBuilder = resolveDocumentNode({
    schemaType: type,
    documentId: id
  });
  defaultDocumentBuilder = defaultDocumentBuilder.id("editor").title("Editor");
  if (template) {
    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(template, payload);
  }
  return defaultDocumentBuilder.serialize();
};
function hashContext(context) {
  var _a, _b;
  return "contextHash(".concat(JSON.stringify({
    id: context.id,
    parentId: parent && assignId(parent),
    path: context.path,
    index: context.index,
    splitIndex: context.splitIndex,
    serializeOptionsIndex: (_a = context.serializeOptions) == null ? void 0 : _a.index,
    serializeOptionsPath: (_b = context.serializeOptions) == null ? void 0 : _b.path
  }), ")");
}
const hashResolvedPaneMeta = meta => {
  const normalized = {
    type: meta.type,
    id: meta.routerPaneSibling.id,
    params: meta.routerPaneSibling.params || {},
    payload: meta.routerPaneSibling.payload || null,
    flatIndex: meta.flatIndex,
    groupIndex: meta.groupIndex,
    siblingIndex: meta.siblingIndex,
    path: meta.path,
    paneNode: meta.type === "resolvedMeta" ? assignId(meta.paneNode) : null
  };
  return "metaHash(".concat(JSON.stringify(normalized), ")");
};
function resolvePaneTree(_ref5) {
  let {
    unresolvedPane,
    flattenedRouterPanes,
    parent: parent2,
    path,
    resolvePane,
    structureContext
  } = _ref5;
  const [current, ...rest] = flattenedRouterPanes;
  const next = rest[0];
  const context = {
    id: current.routerPaneSibling.id,
    splitIndex: current.siblingIndex,
    parent: parent2,
    path: [...path, current.routerPaneSibling.id],
    index: current.flatIndex,
    params: current.routerPaneSibling.params || {},
    payload: current.routerPaneSibling.payload,
    structureContext
  };
  try {
    return resolvePane(unresolvedPane, context, current.flatIndex).pipe(
    // this switch map receives a resolved pane
    switchMap(paneNode => {
      const resolvedPaneMeta = {
        type: "resolvedMeta",
        ...current,
        paneNode,
        path: context.path
      };
      const loadingPanes = rest.map((i, restIndex) => {
        const loadingPanePath = [...context.path, ...rest.slice(restIndex).map((_, currentIndex) => "[".concat(i.flatIndex + currentIndex, "]"))];
        const loadingPane = {
          type: "loading",
          path: loadingPanePath,
          paneNode: null,
          ...i
        };
        return loadingPane;
      });
      if (!rest.length) {
        return of([resolvedPaneMeta]);
      }
      let nextStream;
      if (
      // the fallback editor case
      next == null ? void 0 : next.routerPaneSibling.id.startsWith("__edit__")) {
        nextStream = resolvePaneTree({
          unresolvedPane: fallbackEditorChild,
          flattenedRouterPanes: rest,
          parent: parent2,
          path: context.path,
          resolvePane,
          structureContext
        });
      } else if (current.groupIndex === (next == null ? void 0 : next.groupIndex)) {
        nextStream = resolvePaneTree({
          unresolvedPane,
          flattenedRouterPanes: rest,
          parent: parent2,
          path,
          resolvePane,
          structureContext
        });
      } else {
        nextStream = resolvePaneTree({
          unresolvedPane: typeof paneNode.child === "function" ? memoBind(paneNode, "child") : paneNode.child,
          flattenedRouterPanes: rest,
          parent: paneNode,
          path: context.path,
          resolvePane,
          structureContext
        });
      }
      return concat(
      // we emit the loading panes first in a concat (this emits immediately)
      of([resolvedPaneMeta, ...loadingPanes]),
      // then whenever the next stream is done, the results will be combined.
      nextStream.pipe(map(nextResolvedPanes => [resolvedPaneMeta, ...nextResolvedPanes])));
    }));
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      if (e.context) {
        console.warn("Pane resolution error at index ".concat(e.context.index).concat(e.context.splitIndex > 0 ? " for split pane index ".concat(e.context.splitIndex) : "", ": ").concat(e.message).concat(e.helpId ? " - see ".concat(generateHelpUrl(e.helpId)) : ""), e);
      }
      if (e.helpId === "structure-item-returned-no-child") {
        return of([]);
      }
    }
    throw e;
  }
}
function createResolvedPaneNodeStream(_ref6) {
  let {
    routerPanesStream,
    rootPaneNode,
    initialCacheState = {
      cacheKeysByFlatIndex: [],
      flattenedRouterPanes: [],
      resolvedPaneCache: /* @__PURE__ */new Map(),
      resolvePane: () => NEVER
    },
    structureContext
  } = _ref6;
  const resolvedPanes$ = routerPanesStream.pipe(
  // add in implicit "root" router pane
  map(rawRouterPanes => [[{
    id: "root"
  }], ...rawRouterPanes]),
  // create flattened router panes
  map(routerPanes => {
    const flattenedRouterPanes = routerPanes.flatMap((routerPaneGroup, groupIndex) => routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({
      routerPaneSibling,
      groupIndex,
      siblingIndex
    }))).map((i, index) => ({
      ...i,
      flatIndex: index
    }));
    return flattenedRouterPanes;
  }),
  // calculate a "diffIndex" used for clearing the memo cache
  startWith([]), pairwise(), map(_ref7 => {
    let [prev, curr] = _ref7;
    for (let i = 0; i < curr.length; i++) {
      const prevValue = prev[i];
      const currValue = curr[i];
      if (!isEqual(prevValue, currValue)) {
        return {
          flattenedRouterPanes: curr,
          diffIndex: i
        };
      }
    }
    return {
      flattenedRouterPanes: curr,
      diffIndex: curr.length
    };
  }),
  // create the memoized `resolvePane` function and manage the memo cache
  scan((acc, next) => {
    const {
      cacheKeysByFlatIndex,
      resolvedPaneCache
    } = acc;
    const {
      flattenedRouterPanes,
      diffIndex
    } = next;
    const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1);
    const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1);
    const keysToKeep = new Set(beforeDiffIndex.flatMap(keySet => Array.from(keySet)));
    const keysToDelete = afterDiffIndex.flatMap(keySet => Array.from(keySet)).filter(key => !keysToKeep.has(key));
    for (const key of keysToDelete) {
      resolvedPaneCache.delete(key);
    }
    const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
      const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(hashContext(context));
      const cachedResolvedPane = key && resolvedPaneCache.get(key);
      if (cachedResolvedPane) return cachedResolvedPane;
      const result = nextFn(unresolvedPane, context, flatIndex);
      if (!key) return result;
      const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || /* @__PURE__ */new Set();
      cacheKeySet.add(key);
      cacheKeysByFlatIndex[flatIndex] = cacheKeySet;
      resolvedPaneCache.set(key, result);
      return result;
    };
    return {
      flattenedRouterPanes,
      cacheKeysByFlatIndex,
      resolvedPaneCache,
      resolvePane: createPaneResolver(memoize)
    };
  }, initialCacheState),
  // run the memoized, recursive resolving
  switchMap(_ref8 => {
    let {
      flattenedRouterPanes,
      resolvePane
    } = _ref8;
    return resolvePaneTree({
      unresolvedPane: rootPaneNode,
      flattenedRouterPanes,
      parent: null,
      path: [],
      resolvePane,
      structureContext
    });
  }));
  return resolvedPanes$.pipe(
  // this diffs the previous emission with the current one. if there is a new
  // loading pane at the same position where a previous pane already had a
  // resolved value (looking at the IDs to compare), then return the previous
  // pane instead of the loading pane
  scan((prev, next) => next.map((nextPane, index) => {
    const prevPane = prev[index];
    if (!prevPane) return nextPane;
    if (nextPane.type !== "loading") return nextPane;
    if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {
      return prevPane;
    }
    return nextPane;
  }), []),
  // this prevents duplicate emissions
  distinctUntilChanged((prev, next) => {
    if (prev.length !== next.length) return false;
    for (let i = 0; i < next.length; i++) {
      const prevValue = prev[i];
      const nextValue = next[i];
      if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {
        return false;
      }
    }
    return true;
  }));
}
function useRouterPanesStream() {
  const routerStateSubject = useMemo(() => new ReplaySubject(1), []);
  const routerPanes$ = useMemo(() => routerStateSubject.asObservable().pipe(map(_routerState => (_routerState == null ? void 0 : _routerState.panes) || [])), [routerStateSubject]);
  const {
    state: routerState
  } = useRouter();
  useEffect(() => {
    routerStateSubject.next(routerState);
  }, [routerState, routerStateSubject]);
  return routerPanes$;
}
function useResolvedPanes() {
  const [error, setError] = useState();
  if (error) throw error;
  const {
    structureContext,
    rootPaneNode
  } = useDeskTool();
  const [data, setData] = useState({
    paneDataItems: [],
    resolvedPanes: [],
    routerPanes: []
  });
  const routerPanesStream = useRouterPanesStream();
  useEffect(() => {
    const resolvedPanes$ = createResolvedPaneNodeStream({
      rootPaneNode,
      routerPanesStream,
      structureContext
    }).pipe(map(resolvedPanes => {
      const routerPanes = resolvedPanes.reduce((acc, next) => {
        const currentGroup = acc[next.groupIndex] || [];
        currentGroup[next.siblingIndex] = next.routerPaneSibling;
        acc[next.groupIndex] = currentGroup;
        return acc;
      }, []);
      const groupsLen = routerPanes.length;
      const paneDataItems = resolvedPanes.map(pane => {
        var _a;
        const {
          groupIndex,
          flatIndex,
          siblingIndex,
          routerPaneSibling,
          path
        } = pane;
        const itemId = routerPaneSibling.id;
        const nextGroup = routerPanes[groupIndex + 1];
        const paneDataItem = {
          active: groupIndex === groupsLen - 2,
          childItemId: (_a = nextGroup == null ? void 0 : nextGroup[0].id) != null ? _a : null,
          index: flatIndex,
          itemId: routerPaneSibling.id,
          groupIndex,
          key: "".concat(pane.type === "loading" ? "unknown" : pane.paneNode.id, "-").concat(itemId, "-").concat(siblingIndex),
          pane: pane.type === "loading" ? LOADING_PANE : pane.paneNode,
          params: routerPaneSibling.params || {},
          path: path.join(";"),
          payload: routerPaneSibling.payload,
          selected: flatIndex === resolvedPanes.length - 1,
          siblingIndex
        };
        return paneDataItem;
      });
      return {
        paneDataItems,
        routerPanes,
        resolvedPanes: paneDataItems.map(pane => pane.pane)
      };
    }));
    const subscription = resolvedPanes$.subscribe({
      next: result => setData(result),
      error: e => setError(e)
    });
    return () => subscription.unsubscribe();
  }, [rootPaneNode, routerPanesStream, structureContext]);
  return data;
}
async function ensureDocumentIdAndType(documentStore, id, type) {
  if (id && type) return {
    id,
    type
  };
  if (!id && type) return {
    id: uuid(),
    type
  };
  if (id && !type) {
    const resolvedType = await firstValueFrom(documentStore.resolveTypeForDocument(id));
    return {
      id,
      type: resolvedType
    };
  }
  throw new PaneResolutionError({
    message: "Neither document `id` or `type` was provided when trying to resolve intent."
  });
}
const EMPTY_RECORD = {};
const IntentResolver = memo(function IntentResolver2() {
  const {
    navigate
  } = useRouter();
  const maybeIntent = useRouterState(useCallback(routerState => {
    const intentName = typeof routerState.intent === "string" ? routerState.intent : void 0;
    return intentName ? {
      intent: intentName,
      params: isRecord(routerState.params) ? routerState.params : EMPTY_RECORD,
      payload: routerState.payload
    } : void 0;
  }, []));
  const {
    rootPaneNode,
    structureContext
  } = useDeskTool();
  const documentStore = useDocumentStore();
  const [error, setError] = useState(null);
  if (error) throw error;
  useEffect(() => {
    if (maybeIntent) {
      const {
        intent,
        params,
        payload
      } = maybeIntent;
      let cancelled = false;
      async function effect() {
        const {
          id,
          type
        } = await ensureDocumentIdAndType(documentStore, typeof params.id === "string" ? params.id : void 0, typeof params.type === "string" ? params.type : void 0);
        if (cancelled) return;
        const panes = await resolveIntent({
          intent,
          params: {
            ...params,
            id,
            type
          },
          payload,
          rootPaneNode,
          structureContext
        });
        if (cancelled) return;
        navigate({
          panes
        }, {
          replace: true
        });
      }
      effect().catch(setError);
      return () => {
        cancelled = true;
      };
    }
  }, [documentStore, maybeIntent, navigate, rootPaneNode, structureContext]);
  return null;
});
const PathSegment = styled.span(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  &:not(:last-child)::after {\n    content: ' \u279D ';\n    opacity: 0.5;\n  }\n"])));
function formatStack(stack) {
  return stack.replace(/\(\.\.\.\)\./g, "(...)\n  .").replace(/__WEBPACK_IMPORTED_MODULE_\d+_+/g, "").replace(/___default\./g, ".").replace(new RegExp(" \\(https?:\\/\\/".concat(window.location.host), "g"), " (");
}
function StructureError(_ref9) {
  let {
    error
  } = _ref9;
  if (!(error instanceof PaneResolutionError)) {
    throw error;
  }
  const {
    cause
  } = error;
  const stack = (cause == null ? void 0 : cause.stack) || error.stack;
  const showStack = stack && !(cause instanceof SerializeError) && !error.message.includes("Module build failed:");
  const path = cause instanceof SerializeError ? cause.path : [];
  const helpId = cause instanceof SerializeError && cause.helpId || error.helpId;
  const handleReload = useCallback(() => {
    window.location.reload();
  }, []);
  return /* @__PURE__ */jsx(Card, {
    height: "fill",
    overflow: "auto",
    padding: 4,
    sizing: "border",
    tone: "critical",
    children: /* @__PURE__ */jsxs(Container, {
      children: [/* @__PURE__ */jsx(Heading, {
        as: "h2",
        children: "Encountered an error while reading structure"
      }), /* @__PURE__ */jsxs(Card, {
        marginTop: 4,
        padding: 4,
        radius: 2,
        overflow: "auto",
        shadow: 1,
        tone: "inherit",
        children: [path.length > 0 && /* @__PURE__ */jsxs(Stack, {
          space: 2,
          children: [/* @__PURE__ */jsx(Label, {
            children: "Structure path"
          }), /* @__PURE__ */jsx(Code, {
            children: path.slice(1).map((segment, i) =>
            // eslint-disable-next-line react/no-array-index-key
            /* @__PURE__ */
            jsx(PathSegment, {
              children: segment
            }, "".concat(segment, "-").concat(i)))
          })]
        }), /* @__PURE__ */jsxs(Stack, {
          marginTop: 4,
          space: 2,
          children: [/* @__PURE__ */jsx(Label, {
            children: "Error"
          }), /* @__PURE__ */jsx(Code, {
            children: showStack ? formatStack(stack) : error.message
          })]
        }), helpId && /* @__PURE__ */jsx(Box, {
          marginTop: 4,
          children: /* @__PURE__ */jsx(Text, {
            children: /* @__PURE__ */jsx("a", {
              href: generateHelpUrl(helpId),
              rel: "noopener noreferrer",
              target: "_blank",
              children: "View documentation"
            })
          })
        }), /* @__PURE__ */jsx(Box, {
          marginTop: 4,
          children: /* @__PURE__ */jsx(Button, {
            text: "Reload",
            icon: SyncIcon,
            tone: "primary",
            onClick: handleReload
          })
        })]
      })]
    })
  });
}
function UnknownPane(props) {
  const {
    isSelected,
    pane,
    paneKey
  } = props;
  const type = isRecord(pane) && pane.type || null;
  return /* @__PURE__ */jsxs(Pane, {
    id: paneKey,
    selected: isSelected,
    children: [/* @__PURE__ */jsx(PaneHeader, {
      title: "Unknown pane type"
    }), /* @__PURE__ */jsx(PaneContent, {
      children: /* @__PURE__ */jsx(Box, {
        padding: 4,
        children: typeof type === "string" ? /* @__PURE__ */jsxs(Text, {
          as: "p",
          muted: true,
          children: ["Structure item of type ", /* @__PURE__ */jsx("code", {
            children: type
          }), " is not a known entity."]
        }) : /* @__PURE__ */jsxs(Text, {
          as: "p",
          muted: true,
          children: ["Structure item is missing required ", /* @__PURE__ */jsx("code", {
            children: "type"
          }), " property."]
        })
      })
    })]
  });
}
function getWaitMessages(path) {
  const thresholds = [{
    ms: 300,
    message: "Loading\u2026"
  }, {
    ms: 5e3,
    message: "Still loading\u2026"
  }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? "Structure path: ".concat(path.join(" \u279D ")) : ""];
    thresholds.push({
      ms: 1e4,
      message: message.join("\n")
    });
  }
  const src = of(null);
  return merge(...thresholds.map(_ref10 => {
    let {
      ms,
      message
    } = _ref10;
    return src.pipe(mapTo(message), delay(ms));
  }));
}
const DEFAULT_MESSAGE = "Loading\u2026";
const Content$1 = styled(Flex)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  opacity: 0;\n  transition: opacity 200ms;\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n"])));
const LoadingPane = memo(props => {
  const {
    delay = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props;
  const resolvedMessage = useMemo(() => {
    if (typeof messageProp === "function") {
      return messageProp(path ? path.split(";") : []);
    }
    return messageProp;
  }, [messageProp, path]);
  const [currentMessage, setCurrentMessage] = useState(() => {
    if (typeof resolvedMessage === "string") return resolvedMessage;
    return DEFAULT_MESSAGE;
  });
  useEffect(() => {
    if (typeof resolvedMessage !== "object") return void 0;
    if (typeof resolvedMessage.subscribe === "function") return void 0;
    const sub = resolvedMessage.subscribe(setCurrentMessage);
    return () => sub.unsubscribe();
  }, [resolvedMessage]);
  const [contentElement, setContentElement] = useState(null);
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    if (!contentElement) return void 0;
    return _raf2(() => setMounted(true));
  }, [contentElement]);
  const content = /* @__PURE__ */jsxs(Content$1, {
    align: "center",
    "data-mounted": mounted ? "" : void 0,
    direction: "column",
    height: "fill",
    justify: "center",
    ref: setContentElement,
    children: [/* @__PURE__ */jsx(Spinner, {
      muted: true
    }), (title || currentMessage) && /* @__PURE__ */jsx(Box, {
      marginTop: 3,
      children: /* @__PURE__ */jsx(Text, {
        align: "center",
        muted: true,
        size: 1,
        children: title || currentMessage
      })
    })]
  });
  return /* @__PURE__ */jsx(Pane, {
    flex,
    id: paneKey,
    minWidth,
    selected,
    tone,
    children: /* @__PURE__ */jsx(PaneContent, {
      children: content
    })
  });
});
LoadingPane.displayName = "LoadingPane";
const paneMap = {
  component: lazy(() => import('./index-0938a916.js')),
  document: lazy(() => import('./index-aa34881c.js')),
  documentList: lazy(() => import('./index-b1b17983.js')),
  list: lazy(() => import('./index-3e4bcd52.js'))
};
const DeskToolPane = memo(function DeskToolPane2(props) {
  const {
    active,
    childItemId,
    groupIndex,
    index,
    itemId,
    pane,
    paneKey,
    params,
    payload,
    path,
    selected,
    siblingIndex
  } = props;
  const PaneComponent = paneMap[pane.type] || UnknownPane;
  return /* @__PURE__ */jsx(PaneRouterProvider, {
    flatIndex: index,
    index: groupIndex,
    params,
    payload,
    siblingIndex,
    children: /* @__PURE__ */jsx(Suspense, {
      fallback: /* @__PURE__ */jsx(LoadingPane, {
        paneKey,
        path,
        selected
      }),
      children: /* @__PURE__ */jsx(PaneComponent, {
        childItemId: childItemId || "",
        index,
        itemId,
        isActive: active,
        isSelected: selected,
        paneKey,
        pane
      })
    })
  });
}, (_ref11, _ref12) => {
  let {
    params: prevParams = {},
    payload: prevPayload = null,
    ...prev
  } = _ref11;
  let {
    params: nextParams = {},
    payload: nextPayload = null,
    ...next
  } = _ref12;
  if (!isEqual(prevParams, nextParams)) return false;
  if (!isEqual(prevPayload, nextPayload)) return false;
  const keys = /* @__PURE__ */new Set([...Object.keys(prev), ...Object.keys(next)]);
  for (const key of keys) {
    if (prev[key] !== next[key]) return false;
  }
  return true;
});
function ErrorPane(props) {
  const {
    children,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return /* @__PURE__ */jsxs(Pane, {
    flex,
    id: paneKey,
    minWidth,
    tone,
    children: [/* @__PURE__ */jsx(PaneHeader, {
      title
    }), /* @__PURE__ */jsx(PaneContent, {
      overflow: "auto",
      children: /* @__PURE__ */jsx(Box, {
        paddingX: 4,
        paddingY: 5,
        children
      })
    })]
  });
}
function getOpErrorTitle(op) {
  if (op === "delete") {
    return "An error occurred while attempting to delete this document.\n      This usually means that there are other documents that refers to it.";
  }
  if (op === "unpublish") {
    return "An error occurred while attempting to unpublish this document.\n      This usually means that there are other documents that refers to it.";
  }
  return "An error occurred during ".concat(op);
}
function getOpSuccessTitle(op) {
  if (op === "publish") {
    return "The document was published";
  }
  if (op === "unpublish") {
    return "The document was unpublished. A draft has been created from the latest published version.";
  }
  if (op === "discardChanges") {
    return "All changes since last publish has now been discarded. The discarded draft can still be recovered from history";
  }
  if (op === "delete") {
    return "The document was successfully deleted";
  }
  return "Successfully performed ".concat(op, " on document");
}
const IGNORE_OPS = ["patch", "commit"];
const DocumentOperationResults = memo(function DocumentOperationResults2() {
  const {
    push: pushToast
  } = useToast();
  const {
    documentId,
    documentType
  } = useDocumentPane();
  const event = useDocumentOperationEvent(documentId, documentType);
  const prevEvent = useRef(event);
  useEffect(() => {
    if (!event || event === prevEvent.current) return;
    if (event.type === "error") {
      pushToast({
        closable: true,
        duration: 3e4,
        // 30s
        status: "error",
        title: getOpErrorTitle(event.op),
        description: /* @__PURE__ */jsxs("details", {
          children: [/* @__PURE__ */jsx("summary", {
            children: "Details"
          }), event.error.message]
        })
      });
    }
    if (event.type === "success" && !IGNORE_OPS.includes(event.op)) {
      pushToast({
        closable: true,
        status: "success",
        title: getOpSuccessTitle(event.op)
      });
    }
    prevEvent.current = event;
  }, [event, pushToast]);
  return null;
});
const getHistoryMenuItem = params => {
  const {
    features,
    hasValue,
    changesOpen
  } = params;
  if (!features.reviewChanges) return null;
  return {
    action: "reviewChanges",
    title: "Review changes",
    icon: RestoreIcon,
    isDisabled: changesOpen || !hasValue
  };
};
const getInspectItem = _ref13 => {
  let {
    hasValue
  } = _ref13;
  return {
    action: "inspect",
    title: "Inspect",
    icon: BinaryDocumentIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
};
const getProductionPreviewItem = _ref14 => {
  let {
    previewUrl
  } = _ref14;
  if (!previewUrl) return null;
  return {
    action: "production-preview",
    title: "Open preview",
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  };
};
const getMenuItems = params => {
  const items = [getProductionPreviewItem, getHistoryMenuItem, getInspectItem].filter(Boolean).map(fn => fn(params));
  return items.filter(i => i !== null);
};
const isSanityDocument = value => isRecord(value) && typeof value._id === "string" && typeof value._type === "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = useState(void 0);
  const [error, setError] = useState(null);
  const {
    resolveProductionUrl
  } = useSource().document;
  const value$ = useAsObservable(value);
  if (error) throw error;
  useEffect(() => {
    value$.pipe(
    // this so that the preview URL isn't fetched on every keystroke
    debounceTime(500), switchMap(document => isSanityDocument(document) ? from(resolveProductionUrl({
      document
    })) : of(void 0)), catchError(e => {
      const message = isRecord(e) && typeof e.message === "string" ? e.message : "Unknown error";
      throw new Error("An error was thrown while trying to get your preview url: ".concat(message));
    })).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]);
  return previewUrl;
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {};
  const structureNodeTemplate = opts.templateName;
  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    console.warn("Conflicting templates: URL says \"".concat(opts.urlTemplate, "\", structure node says \"").concat(structureNodeTemplate, "\". Using \"").concat(structureNodeTemplate, "\"."));
  }
  const template = structureNodeTemplate || opts.urlTemplate;
  const typeTemplates = templates.filter(t => t.schemaType === opts.documentType);
  const templateParams = {
    ...opts.templateParams,
    ...(typeof payload === "object" ? payload || {} : {})
  };
  let templateName = template;
  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }
  return {
    templateName,
    templateParams
  };
}
const emptyObject = {};
const DocumentPaneProvider = memo(props => {
  const {
    children,
    index,
    pane,
    paneKey
  } = props;
  const schema = useSchema();
  const templates = useTemplates();
  const {
    actions: documentActions,
    badges: documentBadges,
    unstable_languageFilter: languageFilterResolver
  } = useSource().document;
  const presenceStore = usePresenceStore();
  const paneRouter = usePaneRouter();
  const {
    features
  } = useDeskTool();
  const {
    push: pushToast
  } = useToast();
  const {
    options,
    menuItemGroups,
    title = null,
    views: viewsProp = []
  } = pane;
  const paneOptions = useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = getPublishedId(documentIdRaw);
  const documentType = options.type;
  const paneParams = useUnique(paneRouter.params);
  const panePayload = useUnique(paneRouter.payload);
  const {
    templateName,
    templateParams
  } = useMemo(() => getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: paneParams == null ? void 0 : paneParams.template
  }), [documentType, paneOptions, paneParams, panePayload, templates]);
  const initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  });
  const initialValue = useUnique(initialValueRaw);
  const {
    patch
  } = useDocumentOperation(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const {
    validation: validationRaw
  } = useValidationStatus(documentId, documentType);
  const connectionState = useConnectionState(documentId, documentType);
  const schemaType = schema.get(documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value;
  const actions = useMemo(() => documentActions({
    schemaType: documentType,
    documentId
  }), [documentActions, documentId, documentType]);
  const badges = useMemo(() => documentBadges({
    schemaType: documentType,
    documentId
  }), [documentBadges, documentId, documentType]);
  const languageFilter = useMemo(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]);
  const validation = useUnique(validationRaw);
  const views = useUnique(viewsProp);
  const params = paneRouter.params || emptyObject;
  const [focusPath, setFocusPath] = useState(() => params.path ? fromString(params.path) : []);
  const activeViewId = params.view || views[0] && views[0].id || null;
  const [timelineMode, setTimelineMode] = useState("closed");
  const changesOpen = !!params.since;
  const [timelineError, setTimelineError] = useState(null);
  const timelineStore = useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  });
  const onOlderRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  const revTime = useTimelineSelector(timelineStore, state => state.revTime);
  const sinceAttributes = useTimelineSelector(timelineStore, state => state.sinceAttributes);
  const timelineDisplayed = useTimelineSelector(timelineStore, state => state.timelineDisplayed);
  const timelineReady = useTimelineSelector(timelineStore, state => state.timelineReady);
  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = useState([]);
  useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(nextPresence => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const hasValue = Boolean(value);
  const menuItems = useMemo(() => getMenuItems({
    features,
    hasValue,
    changesOpen,
    previewUrl
  }), [changesOpen, features, hasValue, previewUrl]);
  const inspectOpen = params.inspect === "on";
  const compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null;
  const ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError);
  const displayed = useMemo(() => onOlderRevision ? timelineDisplayed || {
    _id: value._id,
    _type: value._type
  } : value, [onOlderRevision, timelineDisplayed, value]);
  const setTimelineRange = useCallback((newSince, newRev) => {
    paneRouter.setParams({
      ...paneRouter.params,
      since: newSince,
      rev: newRev || void 0
    });
  }, [paneRouter]);
  const handleFocus = useCallback(nextFocusPath => {
    setFocusPath(nextFocusPath);
    presenceStore.setLocation([{
      type: "document",
      documentId,
      path: nextFocusPath,
      lastActiveAt: /* @__PURE__ */new Date().toISOString()
    }]);
  }, [documentId, presenceStore, setFocusPath]);
  const handleBlur = useCallback(blurredPath => {
    setFocusPath([]);
  }, [setFocusPath]);
  const patchRef = useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = event => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = useCallback(event => patchRef.current(event), []);
  const handleHistoryClose = useCallback(() => {
    paneRouter.setParams({
      ...params,
      since: void 0
    });
  }, [paneRouter, params]);
  const handleHistoryOpen = useCallback(() => {
    paneRouter.setParams({
      ...params,
      since: "@lastPublished"
    });
  }, [paneRouter, params]);
  const handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleInspect = useCallback(function () {
    let toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !inspectOpen;
    if (toggle) {
      paneRouter.setParams({
        ...params,
        inspect: "on"
      });
    } else {
      paneRouter.setParams(omit(params, "inspect"));
    }
  }, [inspectOpen, paneRouter, params]);
  const handleMenuAction = useCallback(item => {
    if (item.action === "production-preview" && previewUrl) {
      window.open(previewUrl);
      return true;
    }
    if (item.action === "inspect") {
      toggleInspect(true);
      return true;
    }
    if (item.action === "reviewChanges") {
      handleHistoryOpen();
      return true;
    }
    return false;
  }, [handleHistoryOpen, previewUrl, toggleInspect]);
  const handleKeyUp = useCallback(event => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if (isHotkey(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          handleMenuAction(item);
          return;
        }
      }
    }
  }, [handleMenuAction, menuItems]);
  const handleInspectClose = useCallback(() => toggleInspect(false), [toggleInspect]);
  const [openPath, onSetOpenPath] = useState([]);
  const [fieldGroupState, onSetFieldGroupState] = useState();
  const [collapsedPaths, onSetCollapsedPath] = useState();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = useState();
  const handleOnSetCollapsedPath = useCallback((path, collapsed) => {
    onSetCollapsedPath(prevState => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
    onSetCollapsedFieldSets(prevState => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = useCallback((path, groupName) => onSetFieldGroupState(prevState => setAtPath(prevState, path, groupName)), []);
  const requiredPermission = value._createdAt ? "update" : "create";
  const liveEdit = useMemo(() => Boolean(schemaType == null ? void 0 : schemaType.liveEdit), [schemaType == null ? void 0 : schemaType.liveEdit]);
  const docId = value._id ? value._id : "dummy-id";
  const docPermissionsInput = useMemo(() => {
    return {
      ...value,
      _id: liveEdit ? getPublishedId(docId) : getDraftId(docId)
    };
  }, [liveEdit, value, docId]);
  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  });
  const isNonExistent = !(value == null ? void 0 : value._id);
  const readOnly = useMemo(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted);
    const updateActionDisabled = !isActionEnabled(schemaType, "update");
    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create");
    const reconnecting = connectionState === "reconnecting";
    const isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked;
  }, [connectionState, isNonExistent, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, ready, revTime, schemaType, editState.transactionSyncLock]);
  const formState = useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  });
  const formStateRef = useRef(formState);
  formStateRef.current = formState;
  const setOpenPath = useCallback(path => {
    const ops = getExpandOperations(formStateRef.current, path);
    ops.forEach(op => {
      if (op.type === "expandPath") {
        onSetCollapsedPath(prevState => setAtPath(prevState, op.path, false));
      }
      if (op.type === "expandFieldSet") {
        onSetCollapsedFieldSets(prevState => setAtPath(prevState, op.path, false));
      }
      if (op.type === "setSelectedGroup") {
        onSetFieldGroupState(prevState => setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState,
    focusPath,
    menuItems,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onPathOpen: setOpenPath,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleInspectClose,
    onKeyUp: handleKeyUp,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup: handleSetActiveFieldGroup,
    onSetCollapsedPath: handleOnSetCollapsedPath,
    onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType,
    isPermissionsLoading,
    permissions,
    setTimelineMode,
    setTimelineRange,
    timelineError,
    timelineMode,
    timelineStore,
    title,
    value,
    views,
    formState,
    unstable_languageFilter: languageFilter
  };
  useEffect(() => {
    if (connectionState === "reconnecting") {
      pushToast({
        id: "sanity/desk/reconnecting",
        status: "warning",
        title: /* @__PURE__ */jsx(Fragment, {
          children: "Connection lost. Reconnecting\u2026"
        })
      });
    }
  }, [connectionState, pushToast]);
  useEffect(() => {
    var _a;
    if (ready && params.path) {
      const {
        path,
        ...restParams
      } = params;
      const pathFromUrl = resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, fromString(path));
      setFocusPath(pathFromUrl);
      setOpenPath(pathFromUrl);
      paneRouter.setParams(restParams);
    }
  }, [params, documentId, setOpenPath, ready, paneRouter]);
  return /* @__PURE__ */jsx(DocumentPaneContext.Provider, {
    value: documentPane,
    children
  });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
const TIMELINE_LABELS = {
  create: "created",
  delete: "deleted",
  discardDraft: "discarded draft",
  initial: "created",
  editDraft: "edited",
  editLive: "live edited",
  publish: "published",
  unpublish: "unpublished"
};
const TIMELINE_ICON_COMPONENTS = {
  create: AddCircleIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddCircleIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function formatTimelineEventLabel(type) {
  return TIMELINE_LABELS[type];
}
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function UserAvatarStack(_ref15) {
  let {
    maxLength,
    userIds
  } = _ref15;
  return /* @__PURE__ */jsx(AvatarStack, {
    maxLength,
    children: userIds.map(userId => /* @__PURE__ */jsx(UserAvatar, {
      user: userId,
      withTooltip: true
    }, userId))
  });
}
const IconWrapper = styled(Flex)(_ref16 => {
  let {
    theme
  } = _ref16;
  var _a;
  const borderColor = (_a = theme.sanity.color.base.skeleton) == null ? void 0 : _a.from;
  return css(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n    --timeline-hairline-width: 1px;\n    position: relative;\n    z-index: 2;\n    margin: 0;\n    padding: 0;\n\n    &::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: var(--timeline-hairline-width);\n      background: ", ";\n      top: 0;\n      left: calc((100% - var(--timeline-hairline-width)) / 2);\n      z-index: 1;\n    }\n  "])), borderColor);
});
const Root$5 = styled(Button)(_ref17 => {
  let {
    $selected
  } = _ref17;
  return css(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n    position: relative;\n    width: 100%;\n\n    /* Line styling */\n    &[data-first] ", "::before {\n      height: 50%;\n      top: unset;\n      bottom: 0;\n    }\n\n    &[data-last] ", "::before {\n      height: 50%;\n    }\n\n    ", "\n  "])), IconWrapper, IconWrapper, $selected && css(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      ", "::before {\n        background: transparent;\n      }\n    "])), IconWrapper));
});
const IconBox = styled(Box)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n  background: var(--card-bg-color);\n  border-radius: 50px;\n  position: relative;\n  z-index: 2;\n"])));
const EventLabel = styled(Text)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n  text-transform: capitalize;\n"])));
const TimestampBox = styled(Box)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n  min-width: 1rem;\n  margin-left: ", ";\n"])), _ref18 => {
  let {
    theme
  } = _ref18;
  return "-".concat(rem(theme.sanity.space[1]));
});
const TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem(_ref19) {
  let {
    chunk,
    isFirst,
    isLast,
    isLatest,
    isSelected,
    onSelect,
    timestamp,
    type
  } = _ref19;
  const iconComponent = getTimelineEventIconComponent(type);
  const authorUserIds = Array.from(chunk.authors);
  const formattedTimestamp = useMemo(() => {
    const parsedDate = new Date(timestamp);
    const formattedDate = format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [timestamp]);
  const handleClick = useCallback(evt => {
    evt.preventDefault();
    evt.stopPropagation();
    onSelect(chunk);
  }, [onSelect, chunk]);
  return /* @__PURE__ */jsx(Root$5, {
    $selected: isSelected,
    "data-chunk-id": chunk.id,
    "data-first": isFirst ? true : void 0,
    "data-last": isLast ? true : void 0,
    "data-ui": "timelineItem",
    mode: isSelected ? "default" : "bleed",
    onClick: handleClick,
    padding: 0,
    radius: 2,
    tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
    children: /* @__PURE__ */jsx(Box, {
      paddingX: 2,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "stretch",
        children: [/* @__PURE__ */jsx(IconWrapper, {
          align: "center",
          children: /* @__PURE__ */jsx(IconBox, {
            padding: 2,
            children: /* @__PURE__ */jsx(Text, {
              size: 2,
              children: iconComponent && createElement(iconComponent)
            })
          })
        }), /* @__PURE__ */jsxs(Stack, {
          space: 2,
          margin: 2,
          children: [isLatest && /* @__PURE__ */jsx(Flex, {
            children: /* @__PURE__ */jsx(Card, {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: /* @__PURE__ */jsx(Label, {
                muted: true,
                size: 0,
                children: "Latest"
              })
            })
          }), /* @__PURE__ */jsx(Box, {
            children: /* @__PURE__ */jsx(EventLabel, {
              size: 1,
              weight: "medium",
              children: formatTimelineEventLabel(type) || /* @__PURE__ */jsx("code", {
                children: type
              })
            })
          }), /* @__PURE__ */jsx(TimestampBox, {
            paddingX: 1,
            children: /* @__PURE__ */jsx(Text, {
              size: 0,
              muted: true,
              children: formattedTimestamp
            })
          })]
        }), /* @__PURE__ */jsx(Flex, {
          flex: 1,
          justify: "flex-end",
          align: "center",
          children: /* @__PURE__ */jsx(UserAvatarStack, {
            maxLength: 3,
            userIds: authorUserIds
          })
        })]
      })
    })
  });
}
const StackWrapper = styled(Stack)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n  max-width: 200px;\n"])));
const ListWrapper = styled(Flex)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n  max-height: calc(100vh - 198px);\n  min-width: 244px;\n"])));
const Root$4 = styled(Box)(_ref20 => {
  let {
    $visible
  } = _ref20;
  return css(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n    opacity: 0;\n    pointer-events: none;\n\n    ", "\n  "])), $visible && css(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["\n      opacity: 1;\n      pointer-events: auto;\n    "]))));
});
const Timeline = _ref21 => {
  let {
    chunks,
    disabledBeforeFirstChunk,
    hasMoreChunks,
    lastChunk,
    onLoadMore,
    onSelect,
    firstChunk
  } = _ref21;
  const [mounted, setMounted] = useState(false);
  const filteredChunks = useMemo(() => {
    return chunks.filter(c => {
      if (disabledBeforeFirstChunk && firstChunk) {
        return c.index < firstChunk.index;
      }
      return true;
    });
  }, [chunks, disabledBeforeFirstChunk, firstChunk]);
  const selectedIndex = useMemo(() => (lastChunk == null ? void 0 : lastChunk.id) ? filteredChunks.findIndex(c => c.id === lastChunk.id) : -1, [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]);
  const renderItem = useCallback((chunk, _ref22) => {
    let {
      activeIndex
    } = _ref22;
    const isFirst = activeIndex === 0;
    const isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
    return /* @__PURE__ */jsxs(Box, {
      paddingBottom: isLast ? 1 : 0,
      paddingTop: isFirst ? 1 : 0,
      paddingX: 1,
      children: [/* @__PURE__ */jsx(TimelineItem, {
        chunk,
        isFirst,
        isLast,
        isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
        isSelected: activeIndex === selectedIndex,
        onSelect,
        timestamp: chunk.endTimestamp,
        type: chunk.type
      }), activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */jsx(Flex, {
        align: "center",
        justify: "center",
        padding: 4,
        children: /* @__PURE__ */jsx(Spinner, {
          muted: true
        })
      })]
    });
  }, [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]);
  useEffect(() => setMounted(true), []);
  return /* @__PURE__ */jsxs(Root$4, {
    $visible: !selectedIndex || mounted,
    "data-ui": "timeline",
    children: [filteredChunks.length === 0 && /* @__PURE__ */jsxs(StackWrapper, {
      padding: 3,
      space: 3,
      children: [/* @__PURE__ */jsx(Text, {
        size: 1,
        weight: "semibold",
        children: "No document history"
      }), /* @__PURE__ */jsx(Text, {
        muted: true,
        size: 1,
        children: "When changing the content of the document, the document versions will appear in this menu."
      })]
    }), filteredChunks.length > 0 && /* @__PURE__ */jsx(ListWrapper, {
      direction: "column",
      children: /* @__PURE__ */jsx(CommandList, {
        activeItemDataAttr: "data-hovered",
        ariaLabel: "Document revisions",
        autoFocus: "list",
        initialIndex: selectedIndex,
        initialScrollAlign: "center",
        itemHeight: 40,
        items: filteredChunks,
        onEndReached: onLoadMore,
        onEndReachedIndexOffset: 20,
        overscan: 5,
        renderItem,
        wrapAround: false
      })
    })]
  });
};
Timeline.displayName = "Timeline";
function TimelineError() {
  return /* @__PURE__ */jsxs(Flex, {
    align: "flex-start",
    gap: 3,
    padding: 4,
    children: [/* @__PURE__ */jsx(TextWithTone, {
      tone: "critical",
      children: /* @__PURE__ */jsx(ErrorOutlineIcon, {})
    }), /* @__PURE__ */jsxs(Stack, {
      space: 4,
      children: [/* @__PURE__ */jsx(TextWithTone, {
        size: 1,
        tone: "critical",
        weight: "semibold",
        children: "An error occurred whilst retrieving document changes."
      }), /* @__PURE__ */jsx(TextWithTone, {
        size: 1,
        tone: "critical",
        children: "Document history transactions have not been affected."
      })]
    })]
  });
}
const Root$3 = styled(Popover)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["\n  overflow: hidden;\n  overflow: clip;\n"])));
function TimelineMenu(_ref23) {
  let {
    chunk,
    mode,
    placement
  } = _ref23;
  const {
    setTimelineRange,
    setTimelineMode,
    timelineError,
    ready,
    timelineStore
  } = useDocumentPane();
  const [open, setOpen] = useState(false);
  const [button, setButton] = useState(null);
  const [popover, setPopover] = useState(null);
  const toast = useToast();
  const chunks = useTimelineSelector(timelineStore, state => state.chunks);
  const loading = useTimelineSelector(timelineStore, state => state.isLoading);
  const hasMoreChunks = useTimelineSelector(timelineStore, state => state.hasMoreChunks);
  const realRevChunk = useTimelineSelector(timelineStore, state => state.realRevChunk);
  const sinceTime = useTimelineSelector(timelineStore, state => state.sinceTime);
  const handleOpen = useCallback(() => {
    setTimelineMode(mode);
    setOpen(true);
  }, [mode, setTimelineMode]);
  const handleClose = useCallback(() => {
    setTimelineMode("closed");
    setOpen(false);
  }, [setTimelineMode]);
  const handleClickOutside = useCallback(() => {
    if (open) {
      handleClose();
    }
  }, [handleClose, open]);
  const handleGlobalKeyDown = useCallback(event => {
    if (open && (event.key === "Escape" || event.key === "Tab")) {
      handleClose();
      button == null ? void 0 : button.focus();
    }
  }, [button, handleClose, open]);
  useClickOutside(handleClickOutside, [button, popover]);
  useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = useCallback(revChunk => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const selectSince = useCallback(sinceChunk => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const handleLoadMore = useCallback(() => {
    if (!loading) {
      timelineStore.loadMore();
    }
  }, [loading, timelineStore]);
  const content = timelineError ? /* @__PURE__ */jsx(TimelineError, {}) : /* @__PURE__ */jsxs(Fragment, {
    children: [mode === "rev" && /* @__PURE__ */jsx(Timeline, {
      chunks,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: realRevChunk,
      onLoadMore: handleLoadMore,
      onSelect: selectRev
    }), mode === "since" && /* @__PURE__ */jsx(Timeline, {
      chunks,
      disabledBeforeFirstChunk: true,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: sinceTime,
      onLoadMore: handleLoadMore,
      onSelect: selectSince
    })]
  });
  const timeLabel = useFormattedTimestamp((chunk == null ? void 0 : chunk.endTimestamp) || "");
  const revLabel = chunk ? "".concat(upperFirst(formatTimelineEventLabel(chunk.type)), ": ").concat(timeLabel) : "Latest version";
  const sinceLabel = chunk ? "Since: ".concat(timeLabel) : "Since: unknown version";
  const buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return /* @__PURE__ */jsx(Root$3, {
    constrainSize: true,
    content: open && content,
    "data-ui": "versionMenu",
    open,
    placement,
    portal: true,
    ref: setPopover,
    children: /* @__PURE__ */jsx(Button, {
      disabled: !ready,
      mode: "bleed",
      fontSize: 1,
      padding: 2,
      iconRight: SelectIcon,
      onClick: open ? handleClose : handleOpen,
      ref: setButton,
      selected: open,
      text: ready ? buttonLabel : "Loading history"
    })
  });
}
function useFormattedTimestamp(time) {
  const formatted = useMemo(() => {
    const parsedDate = time ? new Date(time) : /* @__PURE__ */new Date();
    const formattedDate = format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [time]);
  return formatted;
}
function LoadingContent() {
  return /* @__PURE__ */jsx(Delay, {
    ms: 300,
    children: /* @__PURE__ */jsxs(Flex, {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      paddingTop: 3,
      children: [/* @__PURE__ */jsx(Spinner, {
        muted: true
      }), /* @__PURE__ */jsx(Box, {
        marginTop: 3,
        children: /* @__PURE__ */jsx(Text, {
          align: "center",
          muted: true,
          size: 1,
          children: "Loading changes"
        })
      })]
    })
  });
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */new Map();
  visitDiff(diff, child => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation) {
      return true;
    }
    const {
      author,
      timestamp
    } = child.annotation;
    const previous = authorMap.get(author);
    if (!previous || previous.timestamp < timestamp) {
      authorMap.set(author, child.annotation);
    }
    return true;
  });
  return Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
const Scroller$1 = styled(ScrollContainer)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["\n  height: 100%;\n  overflow: auto;\n  position: relative;\n  scroll-behavior: smooth;\n"])));
function ChangesPanel() {
  const {
    documentId,
    onHistoryClose,
    schemaType,
    timelineError,
    timelineStore,
    value
  } = useDocumentPane();
  const {
    collapsed
  } = usePane();
  const scrollRef = useRef(null);
  const diff = useTimelineSelector(timelineStore, state => state.diff);
  const onOlderRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  const selectionState = useTimelineSelector(timelineStore, state => state.selectionState);
  const sinceTime = useTimelineSelector(timelineStore, state => state.sinceTime);
  const loading = selectionState === "loading";
  const isComparingCurrent = !onOlderRevision;
  const documentContext = React.useMemo(() => ({
    documentId,
    schemaType,
    FieldWrapper: ChangeFieldWrapper,
    rootDiff: diff,
    isComparingCurrent,
    value
  }), [documentId, diff, isComparingCurrent, schemaType, value]);
  const changeAnnotations = React.useMemo(() => diff ? collectLatestAuthorAnnotations(diff) : [], [diff]);
  if (collapsed) {
    return null;
  }
  return /* @__PURE__ */jsxs(Flex, {
    direction: "column",
    flex: 1,
    style: {
      borderLeft: "1px dashed var(--card-border-color)",
      overflow: "hidden",
      minWidth: 320
    },
    "data-testid": "review-changes-pane",
    children: [/* @__PURE__ */jsx(PaneHeader, {
      actions: /* @__PURE__ */jsx(Button, {
        icon: CloseIcon,
        mode: "bleed",
        onClick: onHistoryClose,
        padding: 3,
        title: "Hide changes panel"
      }),
      subActions: changeAnnotations.length > 0 && /* @__PURE__ */jsx(Box, {
        paddingRight: 1,
        children: /* @__PURE__ */jsx(DiffTooltip, {
          annotations: changeAnnotations,
          description: "Changes by",
          placement: "bottom-end",
          children: /* @__PURE__ */jsx(AvatarStack, {
            maxLength: 4,
            children: changeAnnotations.map(_ref24 => {
              let {
                author
              } = _ref24;
              return /* @__PURE__ */jsx(UserAvatar, {
                user: author
              }, author);
            })
          })
        })
      }),
      tabs: /* @__PURE__ */jsx(TimelineMenu, {
        mode: "since",
        chunk: sinceTime,
        placement: "bottom-start"
      }),
      title: "Changes"
    }), /* @__PURE__ */jsx(PaneContent, {
      children: /* @__PURE__ */jsx(BoundaryElementProvider, {
        element: scrollRef.current,
        children: /* @__PURE__ */jsx(Scroller$1, {
          "data-ui": "Scroller",
          ref: scrollRef,
          children: /* @__PURE__ */jsx(Box, {
            flex: 1,
            padding: 4,
            children: /* @__PURE__ */jsx(Content, {
              diff,
              documentContext,
              error: timelineError,
              loading
            })
          })
        })
      })
    })]
  });
}
function Content(_ref25) {
  let {
    error,
    diff,
    documentContext,
    loading
  } = _ref25;
  const {
    schemaType
  } = useDocumentPane();
  if (error) {
    return /* @__PURE__ */jsx(NoChanges, {});
  }
  if (loading) {
    return /* @__PURE__ */jsx(LoadingContent, {});
  }
  if (!diff) {
    return /* @__PURE__ */jsx(NoChanges, {});
  }
  return /* @__PURE__ */jsx(DocumentChangeContext.Provider, {
    value: documentContext,
    children: /* @__PURE__ */jsx(ChangeList, {
      diff,
      schemaType
    })
  });
}
function useDeskToolSetting(namespace, key, defaultValue) {
  const settingsStore = useSettingsStore();
  const [value, setValue] = useState(defaultValue);
  const deskToolSettings = useMemo(() => settingsStore.forNamespace("desk-tool"), [settingsStore]);
  const settings = useMemo(() => {
    if (namespace) {
      return deskToolSettings.forNamespace(namespace).forKey(key);
    }
    return deskToolSettings.forKey(key);
  }, [deskToolSettings, namespace, key]);
  useEffect(() => {
    const sub = settings.listen(defaultValue).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, key, namespace, settings]);
  const set = useCallback(newValue => {
    setValue(newValue);
    settings.set(newValue);
  }, [settings]);
  return useMemo(() => [value, set], [set, value]);
}
const VIEW_MODE_PARSED = {
  id: "parsed",
  title: "Parsed"
};
const VIEW_MODE_RAW = {
  id: "raw",
  title: "Raw JSON"
};
const VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
const lru = HLRU(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (cached === void 0) {
    lru.set(keyPath, Array.isArray(value) || isRecord(value));
    return isExpanded(keyPath, value);
  }
  return cached;
}
function toggleExpanded(event) {
  const {
    path
  } = event;
  const current = lru.get(path);
  if (current === void 0) {
    return;
  }
  lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges();
    range.selectNodeContents(element);
    sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  const selectAll = event.keyCode === 65 && (event.metaKey || event.ctrlKey);
  if (!selectAll) {
    return;
  }
  event.preventDefault();
  selectElement(event.currentTarget);
}
function isDocumentLike(value) {
  return isRecord(value) && isString(value._id) && isString(value._type);
}
const JSONInspectorWrapper = styled.div(_ref26 => {
  let {
    theme
  } = _ref26;
  const {
    color,
    fonts,
    space
  } = theme.sanity;
  return css(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral(["\n    & .json-inspector,\n    & .json-inspector .json-inspector__selection {\n      font-family: ", ";\n      font-size: ", "px;\n      line-height: ", "px;\n      color: var(--card-code-fg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf {\n      padding-left: ", ";\n    }\n\n    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {\n      padding-top: ", ";\n      padding-left: 0;\n    }\n\n    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__line {\n      display: block;\n      position: relative;\n      cursor: default;\n    }\n\n    & .json-inspector .json-inspector__line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: -200px;\n      right: -50px;\n      bottom: 0;\n      z-index: -1;\n      pointer-events: none;\n    }\n\n    & .json-inspector .json-inspector__line:hover::after {\n      background: var(--card-code-bg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {\n      content: '\u25B8 ';\n      margin-left: calc(0 - ", " + 3px);\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    &\n      .json-inspector\n      .json-inspector__leaf_expanded.json-inspector__leaf_composite\n      > .json-inspector__line::before {\n      content: '\u25BE ';\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    & .json-inspector .json-inspector__radio,\n    & .json-inspector .json-inspector__flatpath {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__value {\n      margin-left: ", ";\n    }\n\n    &\n      .json-inspector\n      > .json-inspector__leaf_root\n      > .json-inspector__line\n      > .json-inspector__key\n      + .json-inspector__value {\n      margin: 0;\n    }\n\n    & .json-inspector .json-inspector__key {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_helper,\n    & .json-inspector .json-inspector__value_null {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__not-found {\n      padding-top: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_string {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_boolean {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_number {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__show-original {\n      display: inline-block;\n      padding: 0 6px;\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__show-original:hover {\n      color: inherit;\n    }\n\n    & .json-inspector .json-inspector__show-original::before {\n      content: '\u2194';\n    }\n\n    & .json-inspector .json-inspector__show-original:hover::after {\n      content: ' expand';\n    }\n  "])), fonts.code.family, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, rem(space[4]), rem(space[3]), rem(space[4]), fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, rem(space[4] / 2), color.syntax.property, color.syntax.constant, rem(space[3]), color.syntax.string, color.syntax.boolean, color.syntax.number);
});
function Search(props) {
  const {
    onChange,
    query
  } = props;
  const handleChange = useCallback(event => onChange(event.target.value), [onChange]);
  return /* @__PURE__ */jsx(TextInput, {
    icon: SearchIcon,
    onChange: handleChange,
    placeholder: "Search",
    radius: 2,
    value: query || ""
  });
}
function InspectDialog(props) {
  const {
    value
  } = props;
  const {
    onInspectClose,
    paneKey
  } = useDocumentPane();
  const dialogIdPrefix = "".concat(paneKey, "_inspect_");
  const [viewModeId, onViewModeChange] = useDeskToolSetting("desk-tool", "inspect-view-preferred-view-mode-".concat(paneKey), "parsed");
  const viewMode = VIEW_MODES.find(mode => mode.id === viewModeId);
  const setParsedViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]);
  const setRawViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]);
  return /* @__PURE__ */jsx(Dialog, {
    id: "".concat(dialogIdPrefix, "dialog"),
    header: isDocumentLike(value) ? /* @__PURE__ */jsxs(Fragment, {
      children: ["Inspecting", " ", /* @__PURE__ */jsx("em", {
        children: /* @__PURE__ */jsx(DocTitle, {
          document: value
        })
      })]
    }) : /* @__PURE__ */jsx("em", {
      children: "No value"
    }),
    onClose: onInspectClose,
    onClickOutside: onInspectClose,
    width: 3,
    children: /* @__PURE__ */jsxs(Flex, {
      direction: "column",
      height: "fill",
      children: [/* @__PURE__ */jsx(Card, {
        padding: 3,
        shadow: 1,
        style: {
          position: "sticky",
          bottom: 0,
          zIndex: 3
        },
        children: /* @__PURE__ */jsxs(TabList, {
          space: 1,
          children: [/* @__PURE__ */jsx(Tab, {
            "aria-controls": "".concat(dialogIdPrefix, "tabpanel"),
            fontSize: 1,
            id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_PARSED.id),
            label: VIEW_MODE_PARSED.title,
            onClick: setParsedViewMode,
            selected: viewMode === VIEW_MODE_PARSED
          }), /* @__PURE__ */jsx(Tab, {
            "aria-controls": "".concat(dialogIdPrefix, "tabpanel"),
            fontSize: 1,
            id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_RAW.id),
            label: VIEW_MODE_RAW.title,
            onClick: setRawViewMode,
            selected: viewMode === VIEW_MODE_RAW
          })]
        })
      }), /* @__PURE__ */jsxs(TabPanel, {
        "aria-labelledby": "".concat(dialogIdPrefix, "tab-").concat(viewModeId),
        flex: 1,
        id: "".concat(dialogIdPrefix, "tabpanel"),
        overflow: "auto",
        padding: 4,
        style: {
          outline: "none"
        },
        children: [viewMode === VIEW_MODE_PARSED && /* @__PURE__ */jsx(JSONInspectorWrapper, {
          children: /* @__PURE__ */jsx(JSONInspector, {
            data: value,
            isExpanded,
            onClick: toggleExpanded,
            search: Search
          })
        }), viewMode === VIEW_MODE_RAW && /* @__PURE__ */jsx(Code, {
          language: "json",
          tabIndex: 0,
          onKeyDown: maybeSelectAll,
          onDoubleClick: select,
          onFocus: select,
          children: JSON.stringify(value, null, 2)
        })]
      })]
    })
  });
}
const Root$2 = styled(Card)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral(["\n  position: relative;\n  z-index: 50;\n"])));
const TextOneLine = styled(Text)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral(["\n  & > * {\n    overflow: hidden;\n    overflow: clip;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n"])));
const ReferenceChangedBanner = memo(() => {
  var _a, _b, _c, _d, _e, _f;
  const documentPreviewStore = useDocumentPreviewStore();
  const {
    params,
    groupIndex,
    routerPanesState,
    replaceCurrent,
    BackLink
  } = usePaneRouter();
  const routerReferenceId = (_a = routerPanesState[groupIndex]) == null ? void 0 : _a[0].id;
  const parentGroup = routerPanesState[groupIndex - 1];
  const parentSibling = parentGroup == null ? void 0 : parentGroup[0];
  const parentId = parentSibling == null ? void 0 : parentSibling.id;
  const hasHistoryOpen = Boolean((_b = parentSibling == null ? void 0 : parentSibling.params) == null ? void 0 : _b.rev);
  const parentRefPath = useMemo(() => {
    return (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null;
  }, [params == null ? void 0 : params.parentRefPath]);
  const referenceInfo = useMemoObservable(() => {
    const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      return of({
        loading: false
      });
    }
    const publishedId = getPublishedId(parentId);
    const path = fromString(parentRefPathSegment);
    const keyedSegmentIndex = path.findIndex(p => typeof p == "object" && "_key" in p);
    return concat(
    // emit a loading state instantly
    of({
      loading: true
    }),
    // then emit the values from watching the published ID's path
    documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)).pipe(
    // this debounce time is needed to prevent flashing banners due to
    // the router state updating faster than the content-lake state. we
    // debounce to wait for more emissions because the value pulled
    // initially could be stale.
    debounceTime(750), map(_ref27 => {
      let {
        draft,
        published
      } = _ref27;
      var _a2;
      return {
        loading: false,
        result: {
          availability: {
            draft: draft.availability,
            published: published.availability
          },
          refValue: (_a2 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a2._ref
        }
      };
    })));
  }, [documentPreviewStore, parentId, parentRefPath], {
    loading: true
  });
  const handleReloadReference = useCallback(() => {
    var _a2;
    if (referenceInfo.loading) return;
    if ((_a2 = referenceInfo.result) == null ? void 0 : _a2.refValue) {
      replaceCurrent({
        id: referenceInfo.result.refValue,
        params
      });
    }
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  const shouldHide =
  // if `parentId` or `parentRefPath` is not present then this banner is n/a
  !parentId || !parentRefPath ||
  // if viewing this pane via history, then hide
  hasHistoryOpen ||
  // if loading, hide
  referenceInfo.loading ||
  // if the parent document is not available (e.g. due to permission denied or
  // not found) we don't want to display a warning here, but instead rely on the
  // parent view to display the appropriate message
  !((_c = referenceInfo.result) == null ? void 0 : _c.availability.draft.available) && !((_d = referenceInfo.result) == null ? void 0 : _d.availability.published.available) ||
  // if the references are the same, then hide the reference changed banner
  ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId;
  if (shouldHide) return null;
  return /* @__PURE__ */jsx(Root$2, {
    shadow: 1,
    tone: "caution",
    "data-testid": "reference-changed-banner",
    children: /* @__PURE__ */jsx(Container, {
      paddingX: 4,
      paddingY: 2,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsx(Text, {
          size: 1,
          children: /* @__PURE__ */jsx(WarningOutlineIcon, {})
        }), ((_f = referenceInfo.result) == null ? void 0 : _f.refValue) ? /* @__PURE__ */jsxs(Fragment, {
          children: [/* @__PURE__ */jsx(Box, {
            flex: 1,
            marginLeft: 3,
            children: /* @__PURE__ */jsx(TextOneLine, {
              title: "This reference has changed since you opened it.",
              size: 1,
              children: "This reference has changed since you opened it."
            })
          }), /* @__PURE__ */jsx(Box, {
            marginLeft: 3,
            children: /* @__PURE__ */jsx(Button, {
              onClick: handleReloadReference,
              icon: SyncIcon,
              fontSize: 1,
              mode: "ghost",
              padding: 2,
              space: 2,
              text: "Reload reference"
            })
          })]
        }) : /* @__PURE__ */jsxs(Fragment, {
          children: [/* @__PURE__ */jsx(Box, {
            flex: 1,
            marginLeft: 3,
            children: /* @__PURE__ */jsx(TextOneLine, {
              title: "This reference has been removed since you opened it.",
              size: 1,
              children: "This reference has been removed since you opened it."
            })
          }), /* @__PURE__ */jsx(Box, {
            marginLeft: 3,
            children: /* @__PURE__ */jsx(Button, {
              as: BackLink,
              icon: CloseIcon,
              fontSize: 1,
              mode: "ghost",
              padding: 2,
              space: 2,
              text: "Close reference"
            })
          })]
        })]
      })
    })
  });
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
const Root$1 = styled(Card)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral(["\n  position: relative;\n  z-index: 50;\n"])));
function PermissionCheckBanner(_ref28) {
  let {
    granted,
    requiredPermission
  } = _ref28;
  var _a, _b;
  const currentUser = useCurrentUser();
  const plural = ((_a = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _a.length) !== 1;
  const roles = join(((_b = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _b.map(r => /* @__PURE__ */jsx("code", {
    children: r.title
  }, r.name))) || [], ", ");
  if (granted) return null;
  return /* @__PURE__ */jsx(Root$1, {
    "data-testid": "permission-check-banner",
    shadow: 1,
    tone: "transparent",
    children: /* @__PURE__ */jsx(Container, {
      paddingX: 4,
      paddingY: 3,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "flex-start",
        children: [/* @__PURE__ */jsx(Text, {
          size: 1,
          children: /* @__PURE__ */jsx(ReadOnlyIcon, {})
        }), /* @__PURE__ */jsx(Box, {
          flex: 1,
          marginLeft: 3,
          children: /* @__PURE__ */jsxs(Text, {
            size: 1,
            children: ["Your role", plural && "s", " ", roles, " ", plural ? "do" : "does", " not have permissions to", " ", requiredPermission, " this document."]
          })
        })]
      })
    })
  });
}
function join(array, sep) {
  return array.reduce((result, item) => {
    if (result === null) {
      return [item];
    }
    return result.concat([sep, item]);
  }, null);
}
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
const LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast();
  const wasEnabled = usePrevious(params.enabled);
  useEffect(() => {
    if (!wasEnabled && params.enabled) {
      toast.push({
        ...params,
        duration: LONG_ENOUGH_BUT_NOT_TOO_LONG
      });
    }
    if (wasEnabled && !params.enabled) {
      toast.push({
        ...params,
        // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
        duration: 0.01
      });
    }
  }, [params, toast, wasEnabled]);
}
const preventDefault = ev => ev.preventDefault();
function FormView(props) {
  var _a;
  const {
    hidden,
    margins
  } = props;
  const {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane();
  const documentStore = useDocumentStore();
  const presence = useDocumentPresence(documentId);
  const patchChannel = useMemo(() => createPatchChannel(), []);
  const isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled;
  useConditionalToast({
    id: "sync-lock-".concat(documentId),
    status: "warning",
    enabled: isLocked,
    title: "Syncing document\u2026",
    description: "Please hold tight while the document is synced. This usually happens right after the document has been published, and it shouldn't take more than a few seconds"
  });
  useEffect(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(tap(event => {
      if (event.type === "mutation") {
        patchChannel.publish(prepareMutationEvent(event));
      }
      if (event.type === "rebase") {
        patchChannel.publish(prepareRebaseEvent(event));
      }
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = Boolean(value == null ? void 0 : value._rev);
  useEffect(() => {
    if (hasRev) {
      patchChannel.publish({
        type: "mutation",
        patches: [],
        snapshot: value
      });
    }
  }, [hasRev]);
  const formRef = useRef(null);
  useEffect(() => {
    if (ready && !(formState == null ? void 0 : formState.focusPath.length)) {
      focusFirstDescendant(formRef.current);
    }
  }, [ready]);
  return /* @__PURE__ */jsx(Container, {
    hidden,
    paddingX: 4,
    paddingTop: 5,
    paddingBottom: 9,
    sizing: "border",
    width: 1,
    children: /* @__PURE__ */jsx(PresenceOverlay, {
      margins,
      children: /* @__PURE__ */jsx(Box, {
        as: "form",
        onSubmit: preventDefault,
        ref: formRef,
        children: ready ? formState === null ? /* @__PURE__ */jsx(Box, {
          padding: 2,
          children: /* @__PURE__ */jsx(Text, {
            children: "This form is hidden"
          })
        }) : /* @__PURE__ */jsx(FormBuilder, {
          __internal_patchChannel: patchChannel,
          collapsedFieldSets,
          collapsedPaths,
          focusPath: formState.focusPath,
          changed: formState.changed,
          focused: formState.focused,
          groups: formState.groups,
          id: "root",
          members: formState.members,
          onChange,
          onFieldGroupSelect: onSetActiveFieldGroup,
          onPathBlur: onBlur,
          onPathFocus: onFocus,
          onPathOpen,
          onSetFieldSetCollapsed: onSetCollapsedFieldSet,
          onSetPathCollapsed: onSetCollapsedPath,
          presence,
          readOnly: formState.readOnly,
          schemaType: formState.schemaType,
          validation,
          value: formState.value
        }) : /* @__PURE__ */jsx(Delay, {
          ms: 300,
          children: /* @__PURE__ */jsxs(Flex, {
            align: "center",
            direction: "column",
            height: "fill",
            justify: "center",
            children: [/* @__PURE__ */jsx(Spinner, {
              muted: true
            }), /* @__PURE__ */jsx(Box, {
              marginTop: 3,
              children: /* @__PURE__ */jsx(Text, {
                align: "center",
                muted: true,
                size: 1,
                children: "Loading document"
              })
            })]
          })
        })
      })
    })
  });
}
function prepareMutationEvent(event) {
  const patches = event.mutations.map(mut => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map(mut => mut.patch).filter(Boolean);
  const localPatches = event.localMutations.map(mut => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches))
  };
}
function DocumentHeaderTabs() {
  const {
    activeViewId,
    paneKey,
    views
  } = useDocumentPane();
  const tabPanelId = "".concat(paneKey, "tabpanel");
  return /* @__PURE__ */jsx(TabList, {
    space: 1,
    children: views.map((view, index) => {
      var _a;
      return /* @__PURE__ */jsx(DocumentHeaderTab, {
        icon: view.icon,
        id: "".concat(paneKey, "tab-").concat(view.id),
        isActive: activeViewId === view.id,
        label: /* @__PURE__ */jsx(Fragment, {
          children: view.title
        }),
        tabPanelId,
        viewId: index === 0 ? null : (_a = view.id) != null ? _a : null
      }, view.id);
    })
  });
}
function DocumentHeaderTab(props) {
  const {
    isActive,
    tabPanelId,
    viewId
  } = props;
  const {
    ready
  } = useDocumentPane();
  const {
    setView
  } = usePaneRouter();
  const handleClick = useCallback(() => setView(viewId), [setView, viewId]);
  return /* @__PURE__ */jsx(Tab, {
    ...props,
    "aria-controls": tabPanelId,
    disabled: !ready,
    fontSize: 1,
    selected: isActive,
    onClick: handleClick
  });
}
const BUTTON_PROPS = {
  error: {
    tone: "critical",
    icon: ErrorOutlineIcon
  },
  warning: {
    tone: "caution",
    icon: WarningOutlineIcon
  },
  info: {
    tone: "primary",
    icon: InfoOutlineIcon
  }
};
function ValidationMenu(props) {
  const {
    boundaryElement,
    isOpen,
    setOpen
  } = props;
  const {
    onFocus,
    onPathOpen,
    schemaType,
    validation
  } = useDocumentPane();
  const id = useId();
  const hasValidationMarkers = validation.length > 0;
  const hasErrorMarkers = validation.some(isValidationErrorMarker);
  const hasWarningMarkers = validation.some(isValidationWarningMarker);
  const hasInfoMarkers = validation.some(isValidationInfoMarker);
  const buttonProps = useMemo(() => {
    if (hasErrorMarkers) return BUTTON_PROPS.error;
    if (hasWarningMarkers) return BUTTON_PROPS.warning;
    if (hasInfoMarkers) return BUTTON_PROPS.info;
    return void 0;
  }, [hasErrorMarkers, hasInfoMarkers, hasWarningMarkers]);
  const handleOpen = useCallback(path => {
    onPathOpen(path);
    onFocus(path);
  }, [onFocus, onPathOpen]);
  const handleClose = useCallback(() => setOpen(false), [setOpen]);
  if (!hasValidationMarkers) return null;
  return /* @__PURE__ */jsx(MenuButton, {
    id: id || "",
    button: /* @__PURE__ */jsx(Button, {
      ...buttonProps,
      title: "Show validation issues",
      mode: "bleed",
      "data-testid": "validation-list-button"
    }),
    menu: /* @__PURE__ */jsx(Menu, {
      open: isOpen,
      children: /* @__PURE__ */jsx(ValidationList, {
        documentType: schemaType,
        validation,
        onClose: handleClose,
        onFocus: handleOpen
      })
    }),
    popover: {
      portal: true,
      boundaryElement,
      constrainSize: true,
      preventOverflow: true,
      width: 0
    },
    placement: "bottom"
  });
}
function DocumentHeaderTitle() {
  const {
    connectionState,
    schemaType,
    title,
    value: documentValue
  } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState === "connected";
  const {
    error,
    value
  } = unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  if (connectionState !== "connected") {
    return /* @__PURE__ */jsx(Fragment, {});
  }
  if (title) {
    return /* @__PURE__ */jsx(Fragment, {
      children: title
    });
  }
  if (!documentValue) {
    return /* @__PURE__ */jsxs(Fragment, {
      children: ["New ", (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)]
    });
  }
  if (error) {
    return /* @__PURE__ */jsxs(Fragment, {
      children: ["Error: ", error.message]
    });
  }
  return /* @__PURE__ */jsx(Fragment, {
    children: (value == null ? void 0 : value.title) || /* @__PURE__ */jsx("span", {
      style: {
        color: "var(--card-muted-fg-color)"
      },
      children: "Untitled"
    })
  });
}
const isActionButton = item => Boolean(item.showAsAction);
const isMenuButton = negate(isActionButton);
const DocumentPanelHeader = memo(forwardRef((_ref29, ref) => {
  let {
    rootElement
  } = _ref29;
  const {
    onMenuAction,
    onPaneClose,
    onPaneSplit,
    validation,
    menuItems,
    menuItemGroups,
    schemaType,
    timelineStore,
    ready,
    views,
    unstable_languageFilter
  } = useDocumentPane();
  const {
    features
  } = useDeskTool();
  const {
    index,
    BackLink,
    hasGroupSiblings
  } = usePaneRouter();
  const contextMenuItems = useMemo(() => menuItems.filter(isMenuButton), [menuItems]);
  const [isValidationOpen, setValidationOpen] = React.useState(false);
  const showTabs = views.length > 1;
  const showVersionMenu = features.reviewChanges;
  const rev = useTimelineSelector(timelineStore, state => state.revTime);
  const {
    collapsed,
    isLast
  } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const showSplitPaneButton = features.splitViews && onPaneSplit && views.length > 1;
  const showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings;
  const showPaneGroupCloseButton = !showSplitPaneCloseButton && !features.backButton;
  return /* @__PURE__ */jsx(PaneHeader, {
    ref,
    loading: !ready,
    title: /* @__PURE__ */jsx(DocumentHeaderTitle, {}),
    tabs: showTabs && /* @__PURE__ */jsx(DocumentHeaderTabs, {}),
    tabIndex,
    backButton: features.backButton && index > 0 && /* @__PURE__ */jsx(Button, {
      as: BackLink,
      "data-as": "a",
      icon: ArrowLeftIcon,
      mode: "bleed"
    }),
    subActions: showVersionMenu && /* @__PURE__ */jsx(TimelineMenu, {
      chunk: rev,
      mode: "rev",
      placement: "bottom-end"
    }),
    actions: /* @__PURE__ */jsxs(Inline, {
      space: 1,
      children: [unstable_languageFilter.length > 0 && /* @__PURE__ */jsx(Fragment, {
        children: unstable_languageFilter.map((languageFilterComponent, idx) => {
          return createElement(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: "language-filter-".concat(idx),
            schemaType
          });
        })
      }), validation.length > 0 && /* @__PURE__ */jsx(ValidationMenu, {
        boundaryElement: rootElement,
        isOpen: isValidationOpen,
        setOpen: setValidationOpen
      }, "validation-menu"), /* @__PURE__ */jsx(PaneContextMenuButton, {
        itemGroups: menuItemGroups,
        items: contextMenuItems,
        onAction: onMenuAction
      }, "context-menu"), showSplitPaneButton && /* @__PURE__ */jsx(Button, {
        icon: SplitVerticalIcon,
        mode: "bleed",
        onClick: onPaneSplit,
        title: "Split pane right"
      }, "split-pane-button"), showSplitPaneCloseButton && /* @__PURE__ */jsx(Button, {
        icon: CloseIcon,
        mode: "bleed",
        onClick: onPaneClose,
        title: "Close split pane"
      }, "close-view-button"), showPaneGroupCloseButton && /* @__PURE__ */jsx(Button, {
        icon: CloseIcon,
        mode: "bleed",
        title: "Close pane group",
        as: BackLink
      }, "close-view-button")]
    })
  });
}));
DocumentPanelHeader.displayName = "DocumentPanelHeader";
const Scroller = styled(ScrollContainer)(_ref30 => {
  let {
    $disabled
  } = _ref30;
  if ($disabled) {
    return {
      height: "100%"
    };
  }
  return css(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral(["\n    height: 100%;\n    overflow: auto;\n    position: relative;\n    scroll-behavior: smooth;\n    outline: none;\n  "])));
});
const DocumentPanel = function DocumentPanel2(props) {
  const {
    footerHeight,
    isInspectOpen,
    rootElement,
    setDocumentPanelPortalElement
  } = props;
  const {
    activeViewId,
    displayed,
    documentId,
    editState,
    value,
    views,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading
  } = useDocumentPane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  const parentPortal = usePortal();
  const {
    features
  } = useDeskTool();
  const [headerElement, setHeaderElement] = useState(null);
  const headerRect = useElementRect(headerElement);
  const portalRef = useRef(null);
  const [documentScrollElement, setDocumentScrollElement] = useState(null);
  const requiredPermission = value._createdAt ? "update" : "create";
  const activeView = useMemo(() => views.find(view => view.id === activeViewId) || views[0] || {
    type: "form"
  }, [activeViewId, views]);
  const portalElement = features.splitPanes ? portalRef.current || parentPortal.element : parentPortal.element;
  const margins = useMemo(() => {
    if (layoutCollapsed) {
      return [(headerRect == null ? void 0 : headerRect.height) || 0, 0, footerHeight ? footerHeight + 2 : 2, 0];
    }
    return [0, 0, 2, 0];
  }, [layoutCollapsed, footerHeight, headerRect]);
  const formViewHidden = activeView.type !== "form";
  const activeViewNode = useMemo(() => activeView.type === "component" && activeView.component && createElement(activeView.component, {
    document: {
      draft: (editState == null ? void 0 : editState.draft) || null,
      displayed: displayed || value,
      historical: displayed,
      published: (editState == null ? void 0 : editState.published) || null
    },
    documentId,
    options: activeView.options,
    schemaType
  }), [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]);
  useEffect(() => {
    if (!(documentScrollElement == null ? void 0 : documentScrollElement.scrollTo)) return;
    documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]);
  useEffect(() => {
    if (portalElement) {
      setDocumentPanelPortalElement(portalElement);
    }
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = useMemo(() => {
    return isInspectOpen ? /* @__PURE__ */jsx(InspectDialog, {
      value: displayed || value
    }) : null;
  }, [isInspectOpen, displayed, value]);
  return /* @__PURE__ */jsxs(Flex, {
    direction: "column",
    flex: 2,
    overflow: layoutCollapsed ? void 0 : "hidden",
    children: [/* @__PURE__ */jsx(DocumentPanelHeader, {
      rootElement,
      ref: setHeaderElement
    }), /* @__PURE__ */jsx(PaneContent, {
      children: /* @__PURE__ */jsx(PortalProvider, {
        element: portalElement,
        __unstable_elements: {
          documentScrollElement
        },
        children: /* @__PURE__ */jsx(BoundaryElementProvider, {
          element: documentScrollElement,
          children: /* @__PURE__ */jsxs(VirtualizerScrollInstanceProvider, {
            scrollElement: documentScrollElement,
            children: [activeView.type === "form" && !isPermissionsLoading && ready && /* @__PURE__ */jsxs(Fragment, {
              children: [/* @__PURE__ */jsx(PermissionCheckBanner, {
                granted: Boolean(permissions == null ? void 0 : permissions.granted),
                requiredPermission
              }), /* @__PURE__ */jsx(ReferenceChangedBanner, {})]
            }), /* @__PURE__ */jsxs(Scroller, {
              $disabled: layoutCollapsed || false,
              "data-testid": "document-panel-scroller",
              ref: setDocumentScrollElement,
              children: [/* @__PURE__ */jsx(FormView, {
                hidden: formViewHidden,
                margins
              }, documentId + (ready ? "_ready" : "_pending")), activeViewNode]
            }), inspectDialog, /* @__PURE__ */jsx("div", {
              "data-testid": "document-panel-portal",
              ref: portalRef
            })]
          })
        })
      })
    })]
  });
};
const POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
const DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const {
    dialog,
    referenceElement
  } = props;
  return /* @__PURE__ */jsx(Popover, {
    content: /* @__PURE__ */jsx(ConfirmDialogContent, {
      dialog
    }),
    fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
    open: true,
    placement: "top",
    portal: true,
    preventOverflow: true,
    referenceElement
  });
}
function ConfirmDialogContent(props) {
  const {
    dialog
  } = props;
  const {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog;
  const {
    isTopLayer
  } = useLayer();
  const [element, setElement] = useState(null);
  const handleClickOutside = useCallback(() => {
    if (isTopLayer) onCancel();
  }, [isTopLayer, onCancel]);
  const handleGlobalKeyDown = useCallback(event => {
    if (event.key === "Escape" && isTopLayer) onCancel();
  }, [isTopLayer, onCancel]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return /* @__PURE__ */jsxs(Flex, {
    direction: "column",
    ref: setElement,
    style: {
      minWidth: 320 - 16,
      maxWidth: 400
    },
    children: [/* @__PURE__ */jsx(Box, {
      flex: 1,
      overflow: "auto",
      padding: 4,
      children: /* @__PURE__ */jsx(Text, {
        children: message
      })
    }), /* @__PURE__ */jsx(Box, {
      paddingX: 4,
      paddingY: 3,
      style: {
        borderTop: "1px solid var(--card-border-color)"
      },
      children: /* @__PURE__ */jsxs(Grid, {
        columns: 2,
        gap: 2,
        children: [/* @__PURE__ */jsx(Button, {
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || "Cancel"
        }), /* @__PURE__ */jsx(Button, {
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || "Confirm",
          tone
        })]
      })
    })]
  });
}
function ModalDialog(props) {
  const {
    dialog
  } = props;
  const dialogId = useId();
  const footer = dialog.footer && /* @__PURE__ */jsx(Box, {
    paddingX: 4,
    paddingY: 3,
    children: dialog.footer
  });
  return /* @__PURE__ */jsx(LegacyLayerProvider, {
    zOffset: "fullscreen",
    children: /* @__PURE__ */jsx(Dialog, {
      __unstable_hideCloseButton: dialog.showCloseButton === false,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: /* @__PURE__ */jsx(Box, {
        padding: 4,
        children: dialog.content
      })
    })
  });
}
function PopoverDialog(props) {
  const {
    dialog,
    referenceElement
  } = props;
  return /* @__PURE__ */jsx(Popover, {
    content: /* @__PURE__ */jsx(PopoverDialogContent, {
      dialog
    }),
    fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
    open: true,
    placement: "top",
    portal: true,
    preventOverflow: true,
    referenceElement
  });
}
function PopoverDialogContent(props) {
  const {
    dialog
  } = props;
  const {
    content,
    onClose
  } = dialog;
  const {
    isTopLayer
  } = useLayer();
  const [element, setElement] = useState(null);
  const handleClickOutside = useCallback(() => {
    if (isTopLayer) onClose();
  }, [isTopLayer, onClose]);
  const handleGlobalKeyDown = useCallback(event => {
    if (event.key === "Escape" && isTopLayer) onClose();
  }, [isTopLayer, onClose]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return /* @__PURE__ */jsx("div", {
    ref: setElement,
    children: content
  });
}
function DocumentActionPortalProvider(props) {
  const {
    children
  } = props;
  const {
    element,
    elements
  } = usePortal();
  const portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return /* @__PURE__ */jsx(PortalProvider, {
    element: portalElement,
    children
  });
}
function ActionStateDialog(props) {
  const {
    dialog,
    referenceElement = null
  } = props;
  const modalId = useId();
  if (dialog.type === "confirm") {
    return /* @__PURE__ */jsx(ConfirmDialog, {
      dialog,
      referenceElement
    });
  }
  if (dialog.type === "popover") {
    return /* @__PURE__ */jsx(PopoverDialog, {
      dialog,
      referenceElement
    });
  }
  if (dialog.type === "dialog" || !dialog.type) {
    return /* @__PURE__ */jsx(DocumentActionPortalProvider, {
      children: /* @__PURE__ */jsx(ModalDialog, {
        dialog
      })
    });
  }
  if (dialog.type === "custom") {
    return /* @__PURE__ */jsx(DocumentActionPortalProvider, {
      children: dialog == null ? void 0 : dialog.component
    });
  }
  const unknownModal = dialog;
  console.warn("Unsupported modal type ".concat(unknownModal.type));
  return /* @__PURE__ */jsx(Dialog, {
    id: modalId,
    onClose: unknownModal.onClose,
    onClickOutside: unknownModal.onClose,
    width: 2,
    children: /* @__PURE__ */jsx(Box, {
      padding: 4,
      children: unknownModal.content || /* @__PURE__ */jsxs(Fragment, {
        children: ["Unexpected modal type (", /* @__PURE__ */jsx("code", {
          children: unknownModal.type
        }), ")"]
      })
    })
  });
}
function ActionMenuButton(props) {
  const {
    actionStates,
    disabled
  } = props;
  const idPrefix = useId();
  const buttonRef = useRef(null);
  const [actionIndex, setActionIndex] = useState(-1);
  const [referenceElement, setReferenceElement] = useState(null);
  const handleAction = useCallback(idx => {
    setActionIndex(idx);
  }, []);
  const popoverProps = useMemo(() => ({
    placement: "top-end",
    portal: true,
    preventOverflow: true
  }), []);
  const currentAction = actionStates[actionIndex];
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(MenuButton, {
      id: "".concat(idPrefix, "-action-menu"),
      button: /* @__PURE__ */jsx(Button, {
        "data-testid": "action-menu-button",
        "aria-label": "Open document actions",
        disabled,
        icon: ChevronDownIcon,
        mode: "ghost",
        ref: buttonRef
      }),
      menu: /* @__PURE__ */jsx(Menu, {
        padding: 1,
        children: actionStates.map((actionState, idx) => /* @__PURE__ */jsx(ActionMenuListItem, {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        }, idx))
      }),
      popover: popoverProps,
      ref: setReferenceElement
    }), currentAction && currentAction.dialog && /* @__PURE__ */jsx(LegacyLayerProvider, {
      zOffset: "paneFooter",
      children: /* @__PURE__ */jsx(ActionStateDialog, {
        dialog: currentAction.dialog,
        referenceElement
      })
    })]
  });
}
function ActionMenuListItem(props) {
  const {
    actionState,
    disabled,
    index,
    onAction
  } = props;
  const {
    onHandle
  } = actionState;
  const handleClick = useCallback(() => {
    onAction(index);
    if (onHandle) onHandle();
  }, [index, onAction, onHandle]);
  const tooltipContent = actionState.title && /* @__PURE__ */jsx(Box, {
    padding: 2,
    children: /* @__PURE__ */jsx(Text, {
      size: 1,
      children: actionState.title
    })
  });
  return /* @__PURE__ */jsx(MenuItem, {
    "data-testid": "action-".concat(actionState.label.replace(" ", "")),
    disabled: disabled || Boolean(actionState.disabled),
    onClick: handleClick,
    padding: 0,
    tone: actionState.tone,
    children: /* @__PURE__ */jsx(Tooltip, {
      content: tooltipContent,
      disabled: !tooltipContent,
      fallbackPlacements: ["left", "bottom"],
      placement: "top",
      portal: true,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        paddingX: 3,
        children: [/* @__PURE__ */jsxs(Flex, {
          flex: 1,
          paddingY: 3,
          children: [actionState.icon && /* @__PURE__ */jsx(Box, {
            marginRight: 3,
            children: /* @__PURE__ */jsxs(Text, {
              children: [isValidElement(actionState.icon) && actionState.icon, isValidElementType(actionState.icon) && createElement(actionState.icon)]
            })
          }), /* @__PURE__ */jsx(Text, {
            children: actionState.label
          })]
        }), actionState.shortcut && /* @__PURE__ */jsx(Box, {
          marginLeft: 3,
          children: /* @__PURE__ */jsx(Hotkeys, {
            keys: String(actionState.shortcut).split("+").map(s => s.slice(0, 1).toUpperCase() + s.slice(1))
          })
        })]
      })
    })
  });
}
function DocumentStatusBarActionsInner(props) {
  const {
    disabled,
    showMenu,
    states
  } = props;
  const [firstActionState, ...menuActionStates] = states;
  const [buttonElement, setButtonElement] = useState(null);
  const tooltipContent = useMemo(() => {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut) return null;
    return /* @__PURE__ */jsxs(Flex, {
      padding: 2,
      style: {
        maxWidth: 300
      },
      align: "center",
      children: [/* @__PURE__ */jsx(Text, {
        size: 1,
        children: firstActionState.title
      }), firstActionState.shortcut && /* @__PURE__ */jsx(Box, {
        marginLeft: firstActionState.title ? 2 : 0,
        children: /* @__PURE__ */jsx(Hotkeys, {
          keys: String(firstActionState.shortcut).split("+").map(s => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
        })
      })]
    });
  }, [firstActionState]);
  return /* @__PURE__ */jsxs(Flex, {
    children: [firstActionState && /* @__PURE__ */jsx(LayerProvider, {
      zOffset: 200,
      children: /* @__PURE__ */jsx(Tooltip, {
        disabled: !tooltipContent,
        content: tooltipContent,
        portal: true,
        placement: "top",
        children: /* @__PURE__ */jsx(Stack, {
          flex: 1,
          children: /* @__PURE__ */jsx(Button, {
            "data-testid": "action-".concat(firstActionState.label),
            disabled: disabled || Boolean(firstActionState.disabled),
            icon: firstActionState.icon,
            onClick: firstActionState.onHandle,
            ref: setButtonElement,
            text: firstActionState.label,
            tone: firstActionState.tone || "primary"
          })
        })
      })
    }), showMenu && menuActionStates.length > 0 && /* @__PURE__ */jsx(Box, {
      marginLeft: 1,
      children: /* @__PURE__ */jsx(ActionMenuButton, {
        actionStates: menuActionStates,
        disabled
      })
    }), firstActionState && firstActionState.dialog && /* @__PURE__ */jsx(ActionStateDialog, {
      dialog: firstActionState.dialog,
      referenceElement: buttonElement
    })]
  });
}
const DocumentStatusBarActions = memo(function DocumentStatusBarActions2() {
  const {
    actions,
    connectionState,
    documentId,
    editState
  } = useDocumentPane();
  if (!actions || !editState) {
    return null;
  }
  return /* @__PURE__ */jsx(RenderActionCollectionState, {
    actions,
    actionProps: editState,
    children: _ref31 => {
      let {
        states
      } = _ref31;
      return /* @__PURE__ */jsx(DocumentStatusBarActionsInner, {
        disabled: connectionState !== "connected",
        showMenu: actions.length > 1,
        states
      }, documentId);
    }
  });
});
const HistoryStatusBarActions = memo(function HistoryStatusBarActions2() {
  const {
    connectionState,
    editState,
    timelineStore
  } = useDocumentPane();
  const revTime = useTimelineSelector(timelineStore, state => state.revTime);
  const revision = (revTime == null ? void 0 : revTime.id) || "";
  const disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision;
  const actionProps = useMemo(() => ({
    ...(editState || {}),
    revision
  }), [editState, revision]);
  const historyActions = useMemo(() => [HistoryRestoreAction], []);
  return /* @__PURE__ */jsx(RenderActionCollectionState, {
    actions: historyActions,
    actionProps,
    children: _ref32 => {
      let {
        states
      } = _ref32;
      return /* @__PURE__ */jsx(DocumentStatusBarActionsInner, {
        disabled: connectionState !== "connected" || Boolean(disabled),
        showMenu: false,
        states
      });
    }
  });
});
const BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner(_ref33) {
  let {
    states
  } = _ref33;
  return /* @__PURE__ */jsx(Inline, {
    space: 1,
    children: states.map((badge, index) => /* @__PURE__ */jsx(Tooltip, {
      content: badge.title && /* @__PURE__ */jsx(Box, {
        padding: 2,
        children: /* @__PURE__ */jsx(Text, {
          size: 1,
          children: badge.title
        })
      }),
      disabled: !badge.title,
      placement: "top",
      portal: true,
      children: /* @__PURE__ */jsx(Badge, {
        fontSize: 1,
        mode: "outline",
        paddingX: 2,
        paddingY: 1,
        radius: 4,
        tone: badge.color ? BADGE_TONES[badge.color] : void 0,
        style: {
          whiteSpace: "nowrap"
        },
        children: badge.label
      })
    }, String(index)))
  });
}
function DocumentBadges() {
  const {
    badges,
    editState
  } = useDocumentPane();
  if (!editState || !badges) return null;
  return /* @__PURE__ */jsx(RenderBadgeCollectionState, {
    badges,
    badgeProps: editState,
    children: _ref34 => {
      let {
        states
      } = _ref34;
      return /* @__PURE__ */jsx(DocumentBadgesInner, {
        states
      });
    }
  });
}
const Root = styled(Flex)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral(["\n  cursor: default;\n"])));
function PublishStatus(props) {
  const {
    collapsed,
    disabled,
    lastPublished,
    lastUpdated,
    liveEdit
  } = props;
  const lastPublishedTimeAgo = useTimeAgo(lastPublished || "", {
    minimal: true,
    agoSuffix: true
  });
  const lastPublishedTime = useTimeAgo(lastPublished || "", {
    minimal: true
  });
  const lastUpdatedTimeAgo = useTimeAgo(lastUpdated || "", {
    minimal: true,
    agoSuffix: true
  });
  const lastUpdatedTime = useTimeAgo(lastUpdated || "", {
    minimal: true
  });
  return /* @__PURE__ */jsx(Root, {
    align: "center",
    "data-ui": "SessionLayout",
    sizing: "border",
    children: /* @__PURE__ */jsx(Tooltip, {
      placement: "top",
      portal: true,
      content: /* @__PURE__ */jsx(Stack, {
        padding: 3,
        space: 3,
        children: /* @__PURE__ */jsx(Text, {
          size: 1,
          muted: true,
          children: liveEdit ? /* @__PURE__ */jsxs(Fragment, {
            children: ["Last updated ", lastUpdated ? lastUpdatedTimeAgo : lastPublishedTimeAgo]
          }) : /* @__PURE__ */jsxs(Fragment, {
            children: ["Last published ", lastPublishedTimeAgo]
          })
        })
      }),
      children: /* @__PURE__ */jsx(Button, {
        mode: "bleed",
        tone: liveEdit ? "critical" : "positive",
        tabIndex: -1,
        disabled,
        children: /* @__PURE__ */jsxs(Flex, {
          align: "center",
          children: [/* @__PURE__ */jsx(Box, {
            marginRight: collapsed ? 0 : 3,
            children: /* @__PURE__ */jsx(Text, {
              size: 2,
              children: liveEdit ? /* @__PURE__ */jsx(PlayIcon, {}) : /* @__PURE__ */jsx(PublishIcon, {})
            })
          }), !collapsed && /* @__PURE__ */jsx(Text, {
            size: 1,
            weight: "medium",
            children: liveEdit ? /* @__PURE__ */jsx(Fragment, {
              children: lastUpdated ? lastUpdatedTime : lastPublishedTime
            }) : lastPublishedTime
          })]
        })
      })
    })
  });
}
const StyledMotionPath = styled(motion.path)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral(["\n  transform-origin: center;\n"])));
const Circle = props => /* @__PURE__ */jsx(motion.circle, {
  fill: "none",
  r: "8",
  cx: "12.5",
  cy: "12.5",
  strokeWidth: "1.2",
  ...props
});
const Arrows = props => /* @__PURE__ */jsx(StyledMotionPath, {
  fill: "none",
  d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
  ...props
});
const Checkmark = props => /* @__PURE__ */jsx(motion.path, {
  d: "M9.5 12.1316L11.7414 14.5L16 10",
  ...props
});
const Edit = props => /* @__PURE__ */jsx(motion.path, {
  d: "M15 7L18 10M6 19L7 15L17 5L20 8L10 18L6 19Z",
  ...props
});
const rotateAnimation = keyframes(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral(["\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
const RotateGroup = styled.g(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral(["\n  transform-origin: center;\n\n  &[data-rotate] {\n    animation: ", " 1s ease-in-out infinite;\n  }\n"])), rotateAnimation);
const root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: {
    transition: {
      duration: 0
    }
  }
};
const circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
};
const arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
};
const checkmark = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
const edit = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  changes: {
    pathLength: 1,
    transition: {
      duration: 0.4,
      delay: 0.5
    }
  }
};
function AnimatedStatusIcon(props) {
  const {
    status
  } = props;
  if (!status) {
    return null;
  }
  return /* @__PURE__ */jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.2",
    "data-sanity-icon": "",
    children: /* @__PURE__ */jsxs(motion.g, {
      variants: root,
      initial: status,
      animate: status,
      children: [/* @__PURE__ */jsxs(RotateGroup, {
        "data-rotate": status === "changes" ? void 0 : "",
        children: [/* @__PURE__ */jsx(Arrows, {
          variants: arrows,
          initial: status,
          animate: status
        }), /* @__PURE__ */jsx(Circle, {
          variants: circle,
          initial: status,
          animate: status
        })]
      }), /* @__PURE__ */jsx(Checkmark, {
        variants: checkmark,
        initial: status,
        animate: status
      }), /* @__PURE__ */jsx(Edit, {
        variants: edit,
        initial: status,
        animate: status
      })]
    })
  });
}
const ReviewButton = React.forwardRef(function ReviewButton2(props, ref) {
  const {
    collapsed,
    status,
    lastUpdated,
    ...rest
  } = props;
  const lastUpdatedTime = useTimeAgo(lastUpdated || "", {
    minimal: true
  });
  const lastUpdatedTimeAgo = useTimeAgo(lastUpdated || "", {
    minimal: true,
    agoSuffix: true
  });
  const buttonProps = useMemo(() => {
    if (status === "syncing") {
      return {
        text: "Saving...",
        tone: void 0
      };
    }
    if (status === "changes") {
      return {
        text: lastUpdatedTime,
        tone: "caution"
      };
    }
    if (status === "saved") {
      return {
        text: "Saved!",
        tone: "positive"
      };
    }
    return {};
  }, [status, lastUpdatedTime]);
  if (!status) {
    return null;
  }
  return /* @__PURE__ */jsx(Tooltip, {
    placement: "top",
    portal: true,
    disabled: status !== "changes",
    content: /* @__PURE__ */jsxs(Stack, {
      padding: 3,
      space: 3,
      children: [/* @__PURE__ */jsx(Text, {
        size: 1,
        weight: "semibold",
        children: "Review changes"
      }), /* @__PURE__ */jsxs(Text, {
        size: 1,
        muted: true,
        children: ["Changes saved ", lastUpdatedTimeAgo]
      })]
    }),
    children: /* @__PURE__ */jsx(Button, {
      mode: "bleed",
      justify: "flex-start",
      tone: buttonProps == null ? void 0 : buttonProps.tone,
      ...rest,
      "data-testid": "review-changes-button",
      ref,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsx(Box, {
          marginRight: collapsed ? 0 : 3,
          children: /* @__PURE__ */jsx(Text, {
            children: /* @__PURE__ */jsx(AnimatedStatusIcon, {
              status
            })
          })
        }), !collapsed && /* @__PURE__ */jsx(Text, {
          size: 1,
          weight: "medium",
          children: buttonProps == null ? void 0 : buttonProps.text
        })]
      })
    })
  });
});
const ReviewChangesButton = React.memo(ReviewButton);
const SYNCING_TIMEOUT = 1e3;
const SAVED_TIMEOUT = 3e3;
const DocumentSparkline = memo(function DocumentSparkline2() {
  var _a;
  const {
    changesOpen,
    documentId,
    documentType,
    editState,
    onHistoryClose,
    onHistoryOpen,
    timelineStore,
    value
  } = useDocumentPane();
  const syncState = useSyncState(documentId, documentType);
  const lastUpdated = value == null ? void 0 : value._updatedAt;
  const lastPublished = (_a = editState == null ? void 0 : editState.published) == null ? void 0 : _a._updatedAt;
  const liveEdit = Boolean(editState == null ? void 0 : editState.liveEdit);
  const published = Boolean(editState == null ? void 0 : editState.published);
  const changed = Boolean(editState == null ? void 0 : editState.draft);
  const [rootFlexElement, setRootFlexElement] = useState(null);
  const rootFlexRect = useElementRect(rootFlexElement);
  const collapsed = !rootFlexRect || (rootFlexRect == null ? void 0 : rootFlexRect.width) < 300;
  const [status, setStatus] = useState(null);
  const showingRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  useEffect(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]);
  useLayoutEffect(() => {
    setStatus(null);
  }, [documentId]);
  useLayoutEffect(() => {
    if (syncState.isSyncing) {
      setStatus("syncing");
    }
  }, [syncState.isSyncing, lastUpdated]);
  const reviewButton = useMemo(() => /* @__PURE__ */jsx(ReviewChangesButton, {
    lastUpdated,
    status: status || (changed ? "changes" : void 0),
    onClick: changesOpen ? onHistoryClose : onHistoryOpen,
    disabled: showingRevision,
    selected: changesOpen,
    collapsed
  }), [changed, changesOpen, onHistoryClose, onHistoryOpen, lastUpdated, showingRevision, status, collapsed]);
  const publishStatus = useMemo(() => (liveEdit || published) && /* @__PURE__ */jsx(Box, {
    marginRight: 1,
    children: /* @__PURE__ */jsx(PublishStatus, {
      disabled: showingRevision,
      lastPublished,
      lastUpdated,
      liveEdit,
      collapsed
    })
  }), [collapsed, lastPublished, lastUpdated, liveEdit, published, showingRevision]);
  return /* @__PURE__ */jsxs(Flex, {
    align: "center",
    "data-ui": "DocumentSparkline",
    ref: setRootFlexElement,
    children: [publishStatus, /* @__PURE__ */jsxs(Flex, {
      align: "center",
      flex: 1,
      children: [reviewButton, !collapsed && /* @__PURE__ */jsx(Box, {
        marginLeft: 3,
        children: /* @__PURE__ */jsx(DocumentBadges, {})
      })]
    })]
  });
});
const DocumentActionsBox = styled(Box)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral(["\n  min-width: 10em;\n  max-width: 16em;\n"])));
function DocumentStatusBar(props) {
  const {
    actionsBoxRef
  } = props;
  const {
    badges,
    timelineStore
  } = useDocumentPane();
  const showingRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  return useMemo(() => /* @__PURE__ */jsx(Box, {
    paddingLeft: 2,
    paddingRight: [2, 3],
    paddingY: 2,
    children: /* @__PURE__ */jsxs(Flex, {
      align: "center",
      children: [/* @__PURE__ */jsx(Box, {
        flex: [1, 2],
        children: badges && /* @__PURE__ */jsx(DocumentSparkline, {})
      }), /* @__PURE__ */jsx(DocumentActionsBox, {
        flex: 1,
        marginLeft: [1, 3],
        ref: actionsBoxRef,
        children: showingRevision ? /* @__PURE__ */jsx(HistoryStatusBarActions, {}) : /* @__PURE__ */jsx(DocumentStatusBarActions, {})
      })]
    })
  }), [actionsBoxRef, badges, showingRevision]);
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props;
  const activeAction = states[activeIndex];
  const handleKeyDown = useCallback(event => {
    const matchingStates = states.filter(state => state.shortcut && isHotkey(state.shortcut, event));
    const matchingState = matchingStates[0];
    if (matchingStates.length > 1) {
      console.warn("Keyboard shortcut conflict: More than one document action matches the shortcut \"".concat(matchingState.shortcut, "\""));
    }
    if (matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault();
      matchingState.onHandle();
      onActionStart(states.indexOf(matchingState));
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onActionStart, onKeyDown, states]);
  return /* @__PURE__ */jsxs(Pane, {
    id,
    onKeyDown: handleKeyDown,
    tabIndex: -1,
    ...rest,
    ref: rootRef,
    children: [children, activeAction && activeAction.dialog && /* @__PURE__ */jsx(LegacyLayerProvider, {
      zOffset: "paneFooter",
      children: /* @__PURE__ */jsx(ActionStateDialog, {
        dialog: activeAction.dialog,
        referenceElement: actionsBoxElement
      })
    })]
  });
}
const DocumentActionShortcuts = React.memo(props => {
  const {
    actionsBoxElement,
    children,
    ...rest
  } = props;
  const {
    actions,
    editState
  } = useDocumentPane();
  const [activeIndex, setActiveIndex] = useState(-1);
  const onActionStart = useCallback(idx => {
    setActiveIndex(idx);
  }, []);
  const actionProps = useMemo(() => editState && {
    ...editState,
    // @todo: what to call here?
    onComplete: () => void 0,
    // @todo: get revision string
    revision: void 0
  }, [editState]);
  if (!actionProps || !actions) return null;
  return /* @__PURE__ */jsx(RenderActionCollectionState, {
    actionProps,
    actions,
    children: _ref35 => {
      let {
        states
      } = _ref35;
      return /* @__PURE__ */jsx(KeyboardShortcutResponder, {
        ...rest,
        activeIndex,
        actionsBoxElement,
        onActionStart,
        states,
        children
      });
    }
  });
});
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
const DOCUMENT_PANEL_MIN_WIDTH = 320;
const DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
const CHANGES_PANEL_MIN_WIDTH = 320;
const DIALOG_PROVIDER_POSITION = [
// We use the `position: fixed` for dialogs on narrow screens (< 512px).
"fixed",
// And we use the `position: absolute` strategy (within panes) on wide screens.
"absolute"];
const StyledChangeConnectorRoot = styled(ChangeConnectorRoot)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral(["\n  flex: 1;\n  display: flex;\n  min-height: 0;\n  min-width: 0;\n"])));
const DocumentPane = memo(function DocumentPane2(props) {
  const {
    name: parentSourceName
  } = useSource();
  return /* @__PURE__ */jsx(SourceProvider, {
    name: props.pane.source || parentSourceName,
    children: /* @__PURE__ */jsx(DocumentPaneInner, {
      ...props
    })
  });
});
function DocumentPaneInner(props) {
  var _a;
  const {
    pane,
    paneKey
  } = props;
  const {
    resolveNewDocumentOptions
  } = useSource().document;
  const paneRouter = usePaneRouter();
  const options = usePaneOptions(pane.options, paneRouter.params);
  const {
    documentType,
    isLoaded: isDocumentLoaded
  } = useDocumentType(options.id, options.type);
  const templateItems = useMemo(() => {
    return resolveNewDocumentOptions({
      type: "global"
    });
  }, [resolveNewDocumentOptions]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  });
  const isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  const providerProps = useMemo(() => {
    return isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props;
  }, [props, documentType, isLoaded, options]);
  const {
    ReferenceChildLink,
    handleEditReference,
    groupIndex,
    routerPanesState
  } = paneRouter;
  const childParams = ((_a = routerPanesState[groupIndex + 1]) == null ? void 0 : _a[0].params) || {};
  const routerPanesStateLength = routerPanesState.length;
  const {
    parentRefPath
  } = childParams;
  const activePath = useMemo(() => {
    return parentRefPath ? {
      path: fromString(parentRefPath),
      state:
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    } : {
      path: [],
      state: "none"
    };
  }, [parentRefPath, groupIndex, routerPanesStateLength]);
  if (options.type === "*" && !isLoaded) {
    return /* @__PURE__ */jsx(LoadingPane, {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: "Loading document\u2026"
    });
  }
  if (!documentType) {
    return /* @__PURE__ */jsx(ErrorPane, {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: /* @__PURE__ */jsx(Fragment, {
        children: "The document was not found"
      }),
      children: /* @__PURE__ */jsx(Stack, {
        space: 4,
        children: /* @__PURE__ */jsxs(Text, {
          as: "p",
          children: ["The document type is not defined, and a document with the ", /* @__PURE__ */jsx("code", {
            children: options.id
          }), " ", "identifier could not be found."]
        })
      })
    });
  }
  return /* @__PURE__ */jsx(DocumentPaneProvider, {
    ...providerProps,
    children: /* @__PURE__ */jsx(ReferenceInputOptionsProvider, {
      EditReferenceLinkComponent: ReferenceChildLink,
      onEditReference: handleEditReference,
      initialValueTemplateItems: templatePermissions,
      activePath,
      children: /* @__PURE__ */jsx(InnerDocumentPane, {})
    })
  }, "".concat(documentType, "-").concat(options.id));
}
function usePaneOptions(options) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const templates = useTemplates();
  return useMemo(() => {
    if (options.type && options.type !== "*") {
      return options;
    }
    const templateName = options.template || params.template;
    const template = templateName ? templates.find(t => t.id === templateName) : void 0;
    const documentType = template == null ? void 0 : template.schemaType;
    if (!documentType) {
      return options;
    }
    return {
      ...options,
      type: documentType
    };
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: {
        ...options,
        type: documentType
      }
    }
  };
}
function InnerDocumentPane() {
  const {
    changesOpen,
    documentType,
    onFocus,
    onPathOpen,
    onHistoryOpen,
    onKeyUp,
    inspectOpen,
    paneKey,
    schemaType,
    value
  } = useDocumentPane();
  const {
    features
  } = useDeskTool();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  const zOffsets = useZIndex();
  const [rootElement, setRootElement] = useState(null);
  const [footerElement, setFooterElement] = useState(null);
  const [actionsBoxElement, setActionsBoxElement] = useState(null);
  const [documentPanelPortalElement, setDocumentPanelPortalElement] = useState(null);
  const footerRect = useElementRect(footerElement);
  const footerH = footerRect == null ? void 0 : footerRect.height;
  const documentPanel = useMemo(() => /* @__PURE__ */jsx(DocumentPanel, {
    footerHeight: footerH || null,
    isInspectOpen: inspectOpen,
    rootElement,
    setDocumentPanelPortalElement
  }), [footerH, rootElement, inspectOpen]);
  const footer = useMemo(() => /* @__PURE__ */jsx(PortalProvider, {
    __unstable_elements: {
      [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement
    },
    children: /* @__PURE__ */jsx(DialogProvider, {
      position: DIALOG_PROVIDER_POSITION,
      zOffset: zOffsets.portal,
      children: /* @__PURE__ */jsx(PaneFooter, {
        ref: setFooterElement,
        children: /* @__PURE__ */jsx(DocumentStatusBar, {
          actionsBoxRef: setActionsBoxElement
        })
      })
    })
  }), [documentPanelPortalElement, zOffsets.portal]);
  const changesPanel = useMemo(() => {
    if (!features.reviewChanges) return null;
    if (!changesOpen) return null;
    return /* @__PURE__ */jsx(BoundaryElementProvider, {
      element: rootElement,
      children: /* @__PURE__ */jsx(ChangesPanel, {})
    });
  }, [changesOpen, features.reviewChanges, rootElement]);
  const onConnectorSetFocus = useCallback(path => {
    onPathOpen(path);
    onFocus(path);
  }, [onPathOpen, onFocus]);
  const children = useMemo(() => {
    if (!schemaType) {
      return /* @__PURE__ */jsx(ErrorPane, {
        flex: 2.5,
        minWidth: 320,
        paneKey,
        title: /* @__PURE__ */jsxs(Fragment, {
          children: ["Unknown document type: ", /* @__PURE__ */jsx("code", {
            children: documentType
          })]
        }),
        tone: "caution",
        children: /* @__PURE__ */jsxs(Stack, {
          space: 4,
          children: [documentType && /* @__PURE__ */jsxs(Text, {
            as: "p",
            children: ["This document has the schema type ", /* @__PURE__ */jsx("code", {
              children: documentType
            }), ", which is not defined as a type in the local content studio schema."]
          }), !documentType && /* @__PURE__ */jsx(Text, {
            as: "p",
            children: "This document does not exist, and no schema type was specified for it."
          }), isDev && value && /* @__PURE__ */jsxs(Fragment, {
            children: [/* @__PURE__ */jsx(Text, {
              as: "p",
              children: "Here is the JSON representation of the document:"
            }), /* @__PURE__ */jsx(Card, {
              padding: 3,
              overflow: "auto",
              radius: 2,
              shadow: 1,
              tone: "inherit",
              children: /* @__PURE__ */jsx(Code, {
                language: "json",
                size: [1, 1, 2],
                children: JSON.stringify(value, null, 2)
              })
            })]
          })]
        })
      });
    }
    return /* @__PURE__ */jsxs(Fragment, {
      children: [/* @__PURE__ */jsx(DialogProvider, {
        position: DIALOG_PROVIDER_POSITION,
        zOffset: zOffsets.portal,
        children: /* @__PURE__ */jsx(Flex, {
          direction: "column",
          flex: 1,
          height: layoutCollapsed ? void 0 : "fill",
          children: /* @__PURE__ */jsxs(StyledChangeConnectorRoot, {
            "data-testid": "change-connector-root",
            isReviewChangesOpen: changesOpen,
            onOpenReviewChanges: onHistoryOpen,
            onSetFocus: onConnectorSetFocus,
            children: [documentPanel, changesPanel]
          })
        })
      }), footer, /* @__PURE__ */jsx(DocumentOperationResults, {})]
    });
  }, [schemaType, zOffsets.portal, layoutCollapsed, changesOpen, onHistoryOpen, onConnectorSetFocus, documentPanel, changesPanel, footer, paneKey, documentType, value]);
  const currentMinWidth = changesOpen ? DOCUMENT_PANEL_INITIAL_MIN_WIDTH + CHANGES_PANEL_MIN_WIDTH : DOCUMENT_PANEL_INITIAL_MIN_WIDTH;
  const minWidth = changesOpen ? DOCUMENT_PANEL_MIN_WIDTH + CHANGES_PANEL_MIN_WIDTH : DOCUMENT_PANEL_MIN_WIDTH;
  return /* @__PURE__ */jsx(DocumentActionShortcuts, {
    actionsBoxElement,
    currentMinWidth,
    "data-testid": "document-pane",
    flex: 2.5,
    id: paneKey,
    minWidth,
    onKeyUp,
    rootRef: setRootElement,
    children
  });
}
function NoDocumentTypesScreen() {
  return /* @__PURE__ */jsx(Card, {
    height: "fill",
    children: /* @__PURE__ */jsx(Flex, {
      align: "center",
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */jsx(Container, {
        width: 0,
        children: /* @__PURE__ */jsx(Card, {
          padding: 4,
          radius: 2,
          shadow: 1,
          tone: "caution",
          children: /* @__PURE__ */jsxs(Flex, {
            children: [/* @__PURE__ */jsx(Box, {
              children: /* @__PURE__ */jsx(Text, {
                size: 1,
                children: /* @__PURE__ */jsx(WarningOutlineIcon, {})
              })
            }), /* @__PURE__ */jsxs(Stack, {
              flex: 1,
              marginLeft: 3,
              space: 3,
              children: [/* @__PURE__ */jsx(Text, {
                as: "h1",
                size: 1,
                weight: "bold",
                children: "No document types"
              }), /* @__PURE__ */jsx(Text, {
                as: "p",
                muted: true,
                size: 1,
                children: "Please define at least one document type in your schema."
              }), /* @__PURE__ */jsx(Text, {
                as: "p",
                muted: true,
                size: 1,
                children: /* @__PURE__ */jsx("a", {
                  href: "https://www.sanity.io/docs/create-a-schema-and-configure-sanity-studio",
                  target: "_blank",
                  rel: "noreferrer",
                  children: "Learn how to add a document type \u2192"
                })
              })]
            })]
          })
        })
      })
    })
  });
}
const StyledPaneLayout = styled(PaneLayout)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral(["\n  min-height: 100%;\n  min-width: 320px;\n"])));
const isSaveHotkey = isHotkey("mod+s");
const DeskTool = memo(function DeskTool2(_ref36) {
  let {
    onPaneChange
  } = _ref36;
  var _a;
  const {
    push: pushToast
  } = useToast();
  const schema = useSchema();
  const {
    layoutCollapsed,
    setLayoutCollapsed
  } = useDeskTool();
  const {
    paneDataItems,
    resolvedPanes
  } = useResolvedPanes();
  const isResolvingIntent = useRouterState(useCallback(routerState => typeof routerState.intent === "string", []));
  const [portalElement, setPortalElement] = useState(null);
  const handleRootCollapse = useCallback(() => setLayoutCollapsed(true), [setLayoutCollapsed]);
  const handleRootExpand = useCallback(() => setLayoutCollapsed(false), [setLayoutCollapsed]);
  useEffect(() => {
    if (resolvedPanes.length) {
      onPaneChange(resolvedPanes);
    }
  }, [onPaneChange, resolvedPanes]);
  useEffect(() => {
    const handleGlobalKeyDown = event => {
      if (isSaveHotkey(event)) {
        event.preventDefault();
        pushToast({
          closable: true,
          id: "auto-save-message",
          status: "info",
          title: "Your work is automatically saved!",
          duration: 4e3
        });
      }
    };
    window.addEventListener("keydown", handleGlobalKeyDown);
    return () => window.removeEventListener("keydown", handleGlobalKeyDown);
  }, [pushToast]);
  const hasDefinedDocumentTypes = (_a = schema._original) == null ? void 0 : _a.types.some(_isCustomDocumentTypeDefinition);
  if (!hasDefinedDocumentTypes) {
    return /* @__PURE__ */jsx(NoDocumentTypesScreen, {});
  }
  return /* @__PURE__ */jsxs(PortalProvider, {
    element: portalElement || null,
    children: [/* @__PURE__ */jsxs(StyledPaneLayout, {
      flex: 1,
      height: layoutCollapsed ? void 0 : "fill",
      minWidth: 512,
      onCollapse: handleRootCollapse,
      onExpand: handleRootExpand,
      children: [paneDataItems.map(_ref37 => {
        let {
          active,
          childItemId,
          groupIndex,
          itemId,
          key: paneKey,
          pane,
          index: paneIndex,
          params: paneParams,
          path,
          payload,
          siblingIndex,
          selected
        } = _ref37;
        return /* @__PURE__ */jsx(Fragment$1, {
          children: pane === LOADING_PANE ? /* @__PURE__ */jsx(LoadingPane, {
            paneKey,
            path,
            selected
          }) : /* @__PURE__ */jsx(DeskToolPane, {
            active,
            groupIndex,
            index: paneIndex,
            pane,
            childItemId,
            itemId,
            paneKey,
            params: paneParams,
            payload,
            path,
            selected,
            siblingIndex
          })
        }, "".concat(pane === LOADING_PANE ? "loading" : pane.type, "-").concat(paneIndex));
      }), paneDataItems.length <= 1 && isResolvingIntent && /* @__PURE__ */jsx(LoadingPane, {
        paneKey: "intent-resolver"
      })]
    }), /* @__PURE__ */jsx("div", {
      "data-portal": "",
      ref: setPortalElement
    })]
  });
});
function DeskToolBoundary(_ref38) {
  let {
    tool: {
      options
    }
  } = _ref38;
  const {
    unstable_sources: sources
  } = useWorkspace();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  useEffect(() => {
    setActivePanes([]);
    return () => setActivePanes([]);
  }, []);
  const [{
    error
  }, setError] = useState({
    error: null
  });
  if (error) return /* @__PURE__ */jsx(StructureError, {
    error
  });
  return /* @__PURE__ */jsx(ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsx(SourceProvider, {
      name: source || firstSource.name,
      children: /* @__PURE__ */jsxs(DeskToolProvider, {
        defaultDocumentNode,
        structure,
        children: [/* @__PURE__ */jsx(DeskTool, {
          onPaneChange: setActivePanes
        }), /* @__PURE__ */jsx(IntentResolver, {})]
      })
    })
  });
}
var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: DeskToolBoundary
});
export { Delay, DocumentPane, DocumentPaneProvider, index, useDeskTool, useDeskToolSetting };
//# sourceMappingURL=index-37eb7c2e.js.map
