/// <reference types="react" />

import {ArraySchemaType} from '@sanity/types'
import {AssetMetadataType} from '@sanity/types'
import type {AssetSource} from '@sanity/types'
import {AssetSourceSpec} from '@sanity/types'
import type {BifurClient} from '@sanity/bifur-client'
import {BooleanSchemaType} from '@sanity/types'
import {ButtonTone} from '@sanity/ui'
import type {ClientConfig} from '@sanity/client'
import {ComponentType} from 'react'
import {CrossDatasetReferenceValue} from '@sanity/types'
import {CSSProperties} from 'react'
import {CurrentUser} from '@sanity/types'
import {Diff} from '@sanity/diff'
import {FileValue} from '@sanity/types'
import {FocusEventHandler} from 'react'
import {FormEventHandler} from 'react'
import {FormNodeValidation} from '@sanity/types'
import {GeopointValue} from '@sanity/types'
import {HotkeyOptions} from '@sanity/portable-text-editor'
import {ImageUrlFitMode} from '@sanity/types'
import {ImageValue} from '@sanity/types'
import {InitialValueProperty} from '@sanity/types'
import {InitialValueResolverContext} from '@sanity/types'
import {IntrinsicTypeName} from '@sanity/types'
import {KeyedSegment} from '@sanity/types'
import type {MendozaEffectPair} from '@sanity/types'
import {NumberSchemaType} from '@sanity/types'
import {ObjectDiff} from '@sanity/diff'
import {ObjectSchemaType} from '@sanity/types'
import {Observable} from 'rxjs'
import {OnCopyFn} from '@sanity/portable-text-editor'
import {OnPasteFn} from '@sanity/portable-text-editor'
import {Path} from '@sanity/types'
import {PathSegment} from '@sanity/types'
import {PortableTextBlock} from '@sanity/types'
import {PortableTextObject} from '@sanity/types'
import {default as React_2} from 'react'
import {ReactElement} from 'react'
import {ReactNode} from 'react'
import {ReferenceValue} from '@sanity/types'
import type {RootTheme} from '@sanity/ui'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/types'
import {SanityDocumentLike} from '@sanity/types'
import type {Schema} from '@sanity/types'
import {SchemaType} from '@sanity/types'
import type {SchemaTypeDefinition} from '@sanity/types'
import {SlugValue} from '@sanity/types'
import {SortOrdering} from '@sanity/types'
import {SortOrderingItem} from '@sanity/types'
import {StringSchemaType} from '@sanity/types'
import type {TransactionLogEventWithEffects} from '@sanity/types'
import {User} from '@sanity/types'
import {ValidationMarker} from '@sanity/types'

/**
 * @hidden
 * @beta */
declare interface ActionComponent<ActionProps> {
  (props: ActionProps): DocumentActionDescription | null
}

/**
 * The timeline consists of data from (1) the history, (2) live draft mutations, and
 * (3) live published mutations. It's critical for us that the chain of transactions
 * is complete and without holes. The following class can be used as a layer in front
 * of Timeline to ensure this:
 *
 * - Invoke `appendRemoteSnapshotEvent` when there's an incoming remote mutation.
 *   These mutations are buffered internally and _not_ passed to the timeline quite yet.
 *
 * - Once we've received snapshots for both draft and published, then `acceptsHistory`
 *   becomes true and the caller can fetch a chunk of the translog. The flag
 *   `earliestTransactionId` can be used to figure out where to fetch transactions from.
 *
 * - The caller invokes `prependHistoryEvent` for each of the events. These history events
 *   are always pushed to the timeline and it will become available immediately.
 *
 * - Internally this class will then try to align the history event to the received
 *   mutations and then dispatch to the timeline.
 *
 * - The aligner also maintains the latest version for both the draft and the published version.
 *
 *
 */
declare class Aligner {
  timeline: Timeline
  earliestTransactionId: string | null = null

  constructor(timeline: Timeline) {
    this.timeline = timeline
    this._states = {
      draft: emptyVersionState(timeline.draftId),
      published: emptyVersionState(timeline.publishedId),
    }
  }

  private _states: {
    draft: VersionState
    published: VersionState
  }

  appendRemoteSnapshotEvent(evt: RemoteSnapshotVersionEvent): void {
    const state = this._states[evt.version]

    if (evt.type === 'snapshot') {
      this._maybeInvalidateHistory()

      startFromSnapshot(state, evt.document)
      return
    }

    if (evt.type === 'remoteMutation') {
      if (state.aligned) {
        this._apply(state, evt)
        this.timeline.addRemoteMutation(evt)
      } else if (state.hasAttrs) {
        state.events.push(evt)
      } else {
        startFromSnapshot(state, evt.head)
      }
    }
  }

  prependHistoryEvent(evt: TransactionLogEventWithEffects): void {
    if (!this.acceptsHistory) throw new Error('cannot prepend history at this point')

    for (const state of Object.values(this._states)) {
      if (!state.aligned) {
        const idx = align(evt, state)

        if (idx >= 0) {
          this._alignAtIndex(state, idx)
        }
      }
    }

    this.timeline.addTranslogEntry(evt)
    this.earliestTransactionId = evt.id
  }

  didReachEarliestEntry(): void {
    for (const state of Object.values(this._states)) {
      if (!state.aligned) {
        if (state.attrs !== null) throw new Error('unable to find translog entry to align to')
        this._alignAtIndex(state, 0)
      }
    }
    this.timeline.didReachEarliestEntry()
  }

  get isAligned(): boolean {
    return Object.values(this._states).every((state) => state.aligned)
  }

  get acceptsHistory(): boolean {
    return this._isComplete
  }

  get currentDocument(): CombinedDocument {
    return {draft: this._states.draft.attrs, published: this._states.published.attrs}
  }

  private _alignAtIndex(state: VersionState, idx: number) {
    // These we must only apply locally since they are present in the fetched translog.
    for (const mutEvt of state.events.slice(0, idx)) {
      this._apply(state, mutEvt)
    }

    // ... while these must also be pushed to the timeline:
    for (const mutEvt of state.events.slice(idx)) {
      this._apply(state, mutEvt)
      this.timeline.addRemoteMutation(mutEvt)
    }

    state.events = []
    state.aligned = true
  }

  private get _isComplete(): boolean {
    return Object.values(this._states).every((state) => state.hasAttrs)
  }

  // eslint-disable-next-line class-methods-use-this
  private _apply(state: VersionState, evt: DocumentRemoteMutationVersionEvent) {
    state.attrs = applyPatch(state.attrs, evt.effects.apply as any)
    state.rev = evt.transactionId
  }

  private _maybeInvalidateHistory() {
    if (this._isComplete) {
      for (const state of Object.values(this._states)) {
        state.aligned = false
      }
      this.earliestTransactionId = null
      this.timeline.reset()
    }
  }
}

/**
 * @hidden
 * @beta */
declare type Annotation = AnnotationDetails | null

/**
 * Annotation connected to a change
 *
 *
 * @hidden
 * @beta
 */
declare type AnnotationDetails = {
  chunk: Chunk
  timestamp: string
  author: string
}

/**
 * @hidden
 * @beta */
declare interface ArrayFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfObjectsInputProps
}

/**
 * These are the props an implementation of the ArrayFunctions component will receive
 *
 *
 * @hidden
 * @beta
 */
declare interface ArrayInputFunctionsProps<Item, SchemaType extends ArraySchemaType> {
  children?: React_2.ReactNode
  onItemAppend: (itemValue: Item) => void
  onChange: (event: PatchEvent) => void
  onValueCreate: (type: SchemaType) => Item
  onItemPrepend: (itemValue: Item) => void
  readOnly?: boolean
  schemaType: SchemaType
  value?: Item[]
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputInsertEvent<Item> {
  items: Item[]
  position: 'before' | 'after'
  referenceItem: KeyedSegment | number
  skipInitialValue?: boolean
  open?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputMoveItemEvent {
  fromIndex: number
  toIndex: number
}

/**
 * @hidden
 * @beta */
declare interface ArrayItemError {
  kind: 'error'
  key: string
  index: number
  error: InvalidItemTypeError
}

/** @public */
declare interface ArrayOfObjectsFormNode<
  T extends any[] = unknown[],
  S extends ArraySchemaType = ArraySchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfObjectsMember[]
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfObjectsInputProps<
  T extends {_key: string} = {_key: string},
  S extends ArraySchemaType = ArraySchemaType
> extends BaseInputProps,
    ArrayOfObjectsFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>

  /**
   * @hidden
   * @beta */
  // Data manipulation callbacks special for array inputs
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void

  /**
   * @hidden
   * @beta */
  onItemAppend: (item: T) => void

  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: T) => void

  /**
   * @hidden
   * @beta */
  onItemRemove: (itemKey: string) => void

  /**
   * @hidden
   * @beta */
  onItemMove: (event: ArrayInputMoveItemEvent) => void

  /**
   * @hidden
   * @beta */
  onInsert: (event: ArrayInputInsertEvent<T>) => void

  /**
   * @hidden
   * @beta */
  resolveInitialValue: (type: SchemaType, params: Record<string, unknown>) => Promise<T>

  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver

  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void

  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void

  /**
   * for array inputs using expand/collapse semantics for items
   *
   * @hidden
   * @beta
   */
  onItemCollapse: (itemKey: string) => void

  /**
   * @hidden
   * @beta */
  onItemExpand: (itemKey: string) => void

  /**
   * for array inputs using modal open/close semantics for items
   *
   * @hidden
   * @beta
   */
  onItemOpen: (path: Path) => void

  /**
   * @hidden
   * @beta */
  onItemClose: () => void

  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback

  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback

  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback

  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback

  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback

  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback

  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback

  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfObjectsItemMember<Node extends ObjectArrayFormNode = ObjectArrayFormNode> {
  kind: 'item'
  key: string
  index: number

  collapsed: boolean | undefined
  collapsible: boolean | undefined

  open: boolean

  parentSchemaType: ArraySchemaType

  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare type ArrayOfObjectsMember = ArrayOfObjectsItemMember | ArrayItemError

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesElementType<T extends any[]> = T extends (infer K)[] ? K : unknown

/** @public */
declare interface ArrayOfPrimitivesFormNode<
  T extends (string | number | boolean)[] = (string | number | boolean)[],
  S extends ArraySchemaType = ArraySchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfPrimitivesMember[]
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfPrimitivesInputProps<
  T extends string | boolean | number = string | boolean | number,
  S extends ArraySchemaType = ArraySchemaType
> extends BaseInputProps,
    ArrayOfPrimitivesFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>

  // note: not a priority to support collapsible arrays right now
  onSetCollapsed: (collapsed: boolean) => void

  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void

  /**
   * @hidden
   * @beta */
  onItemAppend: (item: ArrayOfPrimitivesElementType<T[]>) => void

  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: ArrayOfPrimitivesElementType<T[]>) => void

  /**
   * @hidden
   * @beta */
  onItemRemove: (index: number) => void

  /**
   * @hidden
   * @beta */
  onMoveItem: (event: ArrayInputMoveItemEvent) => void

  /**
   * @hidden
   * @beta */
  onInsert: (event: {items: T[]; position: 'before' | 'after'; referenceIndex: number}) => void

  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<NumberSchemaType | BooleanSchemaType | StringSchemaType>

  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void

  /**
   * @hidden
   * @beta */
  onIndexFocus: (index: number) => void

  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback

  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback

  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback

  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback

  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfPrimitivesItemCallback

  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback

  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfPrimitivesItemMember<Node extends PrimitiveFormNode = PrimitiveFormNode> {
  kind: 'item'
  // note: there's no persistent handle on primitive items, so our only option is to use the index as key here
  key: string
  index: number
  // the state resolver should make sure this
  // gets collapsible: false and collapsed by default

  open: boolean

  parentSchemaType: ArraySchemaType

  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesMember = ArrayOfPrimitivesItemMember | ArrayItemError

/**
 * @hidden
 * @beta */
declare type AssetSourceResolver = ComposableOption<AssetSource[], ConfigContext>

/**
 * @hidden
 * @beta */
declare type AsyncComposableOption<TValue, TContext> = (
  prev: TValue,
  context: TContext
) => Promise<TValue>

/**
 * The unit an `AuthStore` emits to determine the user's authentication state.
 *
 * @internal
 */
declare interface AuthState {
  /**
   * Similar to a logged-in flag. This state is used in places like the
   * `AuthBoundary` to determine whether or not it should render the
   * `NotAuthenticatedComponent`. Implementers may choose to set this to `true`
   * while also also emitting a `currentUser` of `null` if a `null` user is
   * accepted (e.g. a project that doesn't require a login)
   */
  authenticated: boolean
  /**
   * The value of the user logged in or `null` if none is provided
   */
  currentUser: CurrentUser | null
  /**
   * A client that is expected to be pre-configured to allow for any downstream
   * requests in the Studio
   */
  client: SanityClient
}

/**
 * The interface used by the Studio that produces a `SanityClient` and
 * `CurrentUser` that gets passed to the resulting `Workspace`s and `Source`s.
 *
 * NOTE: This interface is primarily for internal use. Refer to
 * `createAuthStore` instead.
 *
 * @internal
 */
declare interface AuthStore {
  /**
   * Emits `AuthState`s. This should update when the user's auth state changes.
   * E.g. After a login, a new `AuthState` could be emitted with a non-null
   * `currentUser` and `authenticated: true`
   *
   * NOTE: all auth store implementations should emit on subscribe using
   * something like shareReplay(1) to ensure all new subscribers get an
   * `AuthState` value on subscribe
   */
  state: Observable<AuthState>
  /**
   * Emits auth tokens, or `null` if not configured to use them or they do not exist
   */
  token?: Observable<string | null>
  /**
   * Custom auth stores are expected to implement a UI that initiates the user's
   * authentication. For the typical case in `createAuthStore`, this means
   * loading the providers and showing them as options to the user.
   */
  LoginComponent?: React.ComponentType<LoginComponentProps>
  /**
   * Custom auth stores can implement a function that runs when the user logs
   * out. The implementation is expected to remove all credentials both locally
   * and on the server.
   */
  logout?: () => void
  /**
   * Custom auth stores can implement a function that is designated to run when
   * the Studio loads (e.g. to trade a session ID for a token in cookie-less
   * mode). Within the Studio, this is called within the `AuthBoundary`.
   */
  handleCallbackUrl?: () => Promise<void>
}

/**
 * @hidden
 * @beta */
export declare interface BackLinkProps {
  children?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
declare interface BaseFieldProps {
  schemaType: SchemaType
  title: string | undefined
  description: string | undefined
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  level: number
  inputId: string
  value: unknown | undefined
  path: Path
  name: string
  index: number
  changed: boolean
  children: ReactNode
  renderDefault: (props: FieldProps) => ReactElement
}

/** @public */
declare interface BaseFormNode<T = unknown, S extends SchemaType = SchemaType> {
  // constants
  id: string
  schemaType: S
  level: number
  path: Path

  // state
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  value: T | undefined
  readOnly?: boolean
  focused?: boolean
  changed: boolean
}

/**
 * @hidden
 * @beta */
export declare interface BaseGenericList extends StructureNode {
  defaultLayout?: PreviewLayoutKey
  canHandleIntent?: IntentChecker
  displayOptions?: ListDisplayOptions
  child: Child
  initialValueTemplates?: (InitialValueTemplateItem | InitialValueTemplateItemBuilder)[]
}

/**
 * @hidden
 * @beta */
declare interface BaseInputProps {
  renderDefault: (props: InputProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta */
export declare type BaseIntentParams = {
  type?: string
  id?: string
  template?: string
}

/** @public */
declare interface BaseItemProps<T> {
  schemaType: SchemaType
  key: string
  index: number
  level: number
  value: unknown
  path: Path
  title: string | undefined
  description: string | undefined
  inputId: string
  onFocus: (event: React_2.FocusEvent) => void
  onBlur: (event: React_2.FocusEvent) => void
  readOnly?: boolean
  focused?: boolean
  onRemove: () => void

  // --- todo, potentially
  // onMoveTo: (event: {ref: number|string, position: 'before'|'after'}) => void
  // onDuplicate: () => void
  // ---
  /**
   * @hidden
   * @beta */
  onInsert: (event: Omit<ArrayInputInsertEvent<T>, 'referenceItem'>) => void

  children: React_2.ReactNode

  validation: FormNodeValidation[]

  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]

  renderDefault: (props: ItemProps) => React_2.ReactElement
}

/** @internal */
export declare interface BaseResolvedPaneNode<T extends PaneNode['type']> {
  id: string
  type: T
  title: string
  menuItems?: PaneMenuItem[]
  menuItemGroups?: PaneMenuItemGroup[]
  canHandleIntent?: (
    intentName: string,
    params: Record<string, string | undefined>,
    options: {
      pane: PaneNode
      index: number
    }
  ) => boolean
  child?: UnresolvedPaneNode
}

/**
 * @hidden
 * @beta */
export declare interface BaseView {
  id: string
  title: string
  icon?: React.ComponentType | React.ReactNode
}

/**
 * @hidden
 * @beta */
declare interface BlockAnnotationProps {
  __unstable_boundaryElement?: HTMLElement // Boundary element for the annotation, typically a scroll container
  __unstable_referenceElement?: HTMLElement // Reference element representing the annotation in the DOM
  __unstable_textElementFocus?: boolean // Wether the related text element (in the editor) has selection focus. Differs from form state focus.
  children: ReactNode
  focused: boolean // Whether the annotation data object has form focus
  markers: PortableTextMarker[]
  onClose: () => void
  onOpen: () => void
  onPathFocus: (path: Path) => void
  onRemove: () => void
  open: boolean
  parentSchemaType: SchemaType
  path: Path
  presence: FormNodePresence[]
  readOnly: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderDefault: (props: BlockAnnotationProps) => ReactElement
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
  selected: boolean // Whether the object is selected in the editor
  textElement: ReactElement
  validation: FormNodeValidation[]
  value: PortableTextObject
}

/**
 * @hidden
 * @beta */
declare interface BlockProps {
  __unstable_boundaryElement?: HTMLElement // Boundary element for the block, typically a scroll container
  __unstable_referenceElement?: HTMLElement // Reference element representing the block in the DOM
  children: ReactNode
  focused: boolean // Whether the object has form focus
  markers: PortableTextMarker[]
  onClose: () => void
  onOpen: () => void
  onPathFocus: (path: Path) => void
  onRemove: () => void
  open: boolean
  parentSchemaType: ArraySchemaType | ObjectSchemaType
  path: Path
  presence: FormNodePresence[]
  readOnly: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderDefault: (props: BlockProps) => ReactElement
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
  selected: boolean // Whether the object is selected in the editor
  validation: FormNodeValidation[]
  value: PortableTextBlock
}

/**
 * @hidden
 * @beta */
declare interface BooleanFieldProps extends BaseFieldProps {
  schemaType: BooleanSchemaType
  value: boolean | undefined
  inputProps: BooleanInputProps
}

/** @public */
declare type BooleanFormNode<S extends BooleanSchemaType = BooleanSchemaType> = BaseFormNode<
  boolean,
  S
>

/**
 * @hidden
 * @beta */
declare interface BooleanInputProps<S extends BooleanSchemaType = BooleanSchemaType>
  extends BaseInputProps,
    BooleanFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void

  /**
   * A shorthand aggregation of any validation errors the input currently have
   * Will be falsey if no error.
   * In the case of multiple errors it will be a newline delimited string of each error message
   * For advanced use cases use the ´validation´ prop which contains more levels and details
   */
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @beta */
declare type BufferedDocumentEvent =
  | SnapshotEvent
  | DocumentRebaseEvent
  | DocumentMutationEvent
  | CommittedEvent

/**
 * @hidden
 * @beta */
export declare interface BuildableComponent extends Partial<StructureNode> {
  component?: UserComponent
  child?: Child
  options?: {
    [key: string]: unknown
  }
  menuItems?: (MenuItem | MenuItemBuilder)[]
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
}

/**
 * @hidden
 * @beta */
export declare interface BuildableGenericList extends Partial<BaseGenericList> {
  menuItems?: (MenuItem | MenuItemBuilder)[]
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
}

/**
 * @hidden
 * @beta */
export declare interface BuildableList extends BuildableGenericList {
  items?: (ListItem | ListItemBuilder | Divider)[]
}

/** @internal */
export declare type Builder =
  | CollectionBuilder
  | ComponentBuilder
  | DocumentBuilder
  | DocumentListBuilder
  | DocumentListItemBuilder
  | ListItemBuilder
  | MenuItemBuilder
  | MenuItemGroupBuilder
  | InitialValueTemplateItemBuilder

/**
 * @hidden
 * @beta */
export declare type Child = Collection | CollectionBuilder | ChildResolver

/**
 * @hidden
 * @beta */
export declare interface ChildLinkProps {
  childId: string
  childParameters?: Record<string, string>
  childPayload?: unknown
  children?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface ChildObservable {
  subscribe: (child: ItemChild | Promise<ItemChild>) => Record<string, unknown>
}

/**
 * @hidden
 * @beta */
export declare interface ChildResolver {
  (itemId: string, options: ChildResolverOptions):
    | ItemChild
    | Promise<ItemChild>
    | ChildObservable
    | Observable<ItemChild>
    | undefined
}

/**
 * @hidden
 * @beta */
export declare interface ChildResolverOptions {
  parent: unknown
  index: number
  splitIndex: number
  path: string[]
  params: Record<string, string | undefined>
  structureContext: StructureContext
  serializeOptions?: SerializeOptions
}

/**
 * @hidden
 * @beta */
declare type Chunk = {
  index: number

  id: string
  type: ChunkType
  start: number
  end: number
  startTimestamp: string
  endTimestamp: string
  authors: Set<string>
  draftState: 'present' | 'missing' | 'unknown'
  publishedState: 'present' | 'missing' | 'unknown'
}

/**
 * History timeline / chunking
 *
 *
 * @hidden
 * @beta
 */
declare type ChunkType =
  | 'initial'
  | 'create'
  | 'editDraft'
  | 'delete'
  | 'publish'
  | 'unpublish'
  | 'discardDraft'
  | 'editLive'

/**
 * @hidden
 * @beta */
export declare type Collection = List | DocumentList | EditorNode | DocumentNode | Component

/**
 * @hidden
 * @beta */
export declare type CollectionBuilder =
  | ListBuilder
  | DocumentListBuilder
  | DocumentTypeListBuilder
  | DocumentBuilder
  | ComponentBuilder

/**
 * @hidden
 * @beta */
declare interface CombinedDocument {
  draft: Record<string, unknown> | null
  published: Record<string, unknown> | null
}

/**
 * @hidden
 * @beta */
declare interface CommittedEvent {
  type: 'committed'
}

/**
 * @hidden
 * @beta */
declare interface ComplexElementProps {
  id: string
  onFocus: FocusEventHandler
  onBlur: FocusEventHandler
  ref: React_2.MutableRefObject<any>
}

/**
 * @hidden
 * @beta */
export declare interface Component extends StructureNode {
  component: UserComponent
  child?: Child
  menuItems: MenuItem[]
  menuItemGroups: MenuItemGroup[]
  options: {
    [key: string]: unknown
  }
}

/** @internal */
export declare const component: (
  componentOrSpec?: UserViewComponent | Partial<ComponentView>
) => ComponentViewBuilder

/**
 * @hidden
 * @beta */
export declare class ComponentBuilder implements Serializable<Component> {
  protected spec: BuildableComponent
  constructor(spec?: ComponentInput)
  id(id: string): ComponentBuilder
  getId(): BuildableComponent['id']
  title(title: string): ComponentBuilder
  getTitle(): BuildableComponent['title']
  child(child: Child): ComponentBuilder
  getChild(): BuildableComponent['child']
  component(component: UserComponent): ComponentBuilder
  getComponent(): BuildableComponent['component']
  options(options: {[key: string]: unknown}): ComponentBuilder
  getOptions(): NonNullable<BuildableComponent['options']>
  menuItems(menuItems: (MenuItem | MenuItemBuilder)[]): ComponentBuilder
  getMenuItems(): BuildableComponent['menuItems']
  menuItemGroups(menuItemGroups: (MenuItemGroup | MenuItemGroupBuilder)[]): ComponentBuilder
  getMenuItemGroups(): BuildableComponent['menuItemGroups']
  serialize(options?: SerializeOptions): Component
  clone(withSpec?: BuildableComponent): ComponentBuilder
}

/**
 * @hidden
 * @beta */
export declare interface ComponentInput extends StructureNode {
  component: UserComponent
  child?: Child
  options?: {
    [key: string]: unknown
  }
  menuItems?: (MenuItem | MenuItemBuilder)[]
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
}

/**
 * @hidden
 * @beta */
export declare interface ComponentView<TOptions = Record<string, any>> extends BaseView {
  type: 'component'
  component: UserViewComponent
  options: TOptions
}

/**
 * @hidden
 * @beta */
export declare class ComponentViewBuilder extends GenericViewBuilder<
  Partial<ComponentView>,
  ComponentViewBuilder
> {
  protected spec: Partial<ComponentView>
  constructor(componentOrSpec?: UserViewComponent | Partial<ComponentView>)
  component(component: UserViewComponent): ComponentViewBuilder
  getComponent(): Partial<ComponentView>['component']
  options(options: {[key: string]: any}): ComponentViewBuilder
  getOptions(): ComponentView['options']
  serialize(options?: SerializeOptions): ComponentView
  clone(withSpec?: Partial<ComponentView>): ComponentViewBuilder
}

/** @public */
declare type ComposableOption<TValue, TContext> = (prev: TValue, context: TContext) => TValue

/** @public */
declare interface ConfigContext {
  projectId: string
  dataset: string
  schema: Schema
  currentUser: CurrentUser | null
  getClient: (options: SourceClientOptions) => SanityClient
}

/** @internal */
export declare function ConfirmDeleteDialog(props: ConfirmDeleteDialogProps): JSX.Element

/** @internal */
export declare interface ConfirmDeleteDialogProps {
  /**
   * Incoming document ID used to find other referencing documents. This
   * field respects draft IDs (e.g. if you pass in a published ID when one
   * doesn't exist the document title may not show up).
   */
  id: string
  /**
   * The schema typename of the incoming document
   */
  type: string
  /**
   * The name of the action being done. (e.g. the `'unpublish'` action requires
   * the same document deletion confirmation).
   */
  action?: string
  onCancel: () => void
  onConfirm: () => void
}

/** @internal */
export declare function createStructureBuilder({
  defaultDocumentNode,
  source,
}: StructureBuilderOptions): StructureBuilder

/** @internal */
export declare interface CustomComponentPaneNode extends BaseResolvedPaneNode<'component'> {
  component: UserComponent
  options?: Record<string, unknown>
}

/** @internal */
export declare const DEFAULT_INTENT_HANDLER: unique symbol

/**
 * @hidden
 * @beta */
export declare interface DefaultDocumentNodeContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta */
export declare type DefaultDocumentNodeResolver = (
  S: StructureBuilder,
  options: DefaultDocumentNodeContext
) => DocumentBuilder | null | undefined

/** @internal */
export declare function defaultInitialValueTemplateItems(
  context: StructureContext
): InitialValueTemplateItemBuilder[]

/** @internal */
export declare const defaultIntentChecker: IntentChecker

/**
 * @hidden
 * @beta */
export declare const deskTool: Plugin_2<void | DeskToolOptions>

/** @internal */
export declare interface DeskToolContextValue {
  features: DeskToolFeatures
  layoutCollapsed: boolean
  setLayoutCollapsed: (layoutCollapsed: boolean) => void
  rootPaneNode: UnresolvedPaneNode
  structureContext: StructureContext
}

/** @internal */
export declare interface DeskToolFeatures {
  /**
   *
   * @hidden
   * @beta
   */
  backButton: boolean
  reviewChanges: boolean
  splitPanes: boolean
  splitViews: boolean
}

/** @internal */
export declare type DeskToolMenuItem = ReturnType<
  ReturnType<StructureBuilder['menuItem']>['serialize']
>

/**
 * @hidden
 * @beta */
export declare interface DeskToolOptions {
  icon?: React.ComponentType
  name?: string
  source?: string
  structure?: StructureResolver
  defaultDocumentNode?: DefaultDocumentNodeResolver
  title?: string
}

/** @internal */
export declare type DeskToolPaneActionHandler = (params: any, scope?: unknown) => void

/** @internal */
export declare function DeskToolProvider({
  defaultDocumentNode,
  structure: resolveStructure,
  children,
}: DeskToolProviderProps): React_2.ReactElement

/** @internal */
export declare interface DeskToolProviderProps {
  structure?: StructureResolver
  defaultDocumentNode?: DefaultDocumentNodeResolver
  children: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface Divider {
  id: string
  type: 'divider'
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionComponent extends ActionComponent<DocumentActionProps> {
  /**
   * An optional meta property that can used to replace this document action
   * with another. E.g.:
   *
   * ```js
   * import {defineConfig} from 'sanity'
   * import {MyPublishAction} from '...'
   *
   * export default defineConfig({
   *   document: {
   *     actions: (prev) =>
   *       prev.map((previousAction) =>
   *         previousAction.action === 'publish' ? MyPublishAction : previousAction
   *       ),
   *   },
   * })
   * ```
   */
  action?: 'delete' | 'discardChanges' | 'duplicate' | 'restore' | 'publish' | 'unpublish'
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionConfirmDialogProps {
  type: 'confirm'
  tone?: ButtonTone
  message: React_2.ReactNode
  onConfirm: () => void
  onCancel: () => void
  cancelButtonIcon?: React_2.ComponentType | React_2.ReactNode
  cancelButtonText?: React_2.ReactNode
  confirmButtonIcon?: React_2.ComponentType | React_2.ReactNode
  confirmButtonText?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionCustomDialogComponentProps {
  type: 'custom'
  component: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionDescription {
  tone?: ButtonTone
  dialog?: DocumentActionDialogProps | false | null
  disabled?: boolean
  icon?: React_2.ReactNode | React_2.ComponentType
  label: string
  onHandle?: () => void
  shortcut?: string | null
  title?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
declare type DocumentActionDialogProps =
  | DocumentActionConfirmDialogProps
  | DocumentActionPopoverDialogProps
  | DocumentActionModalDialogProps
  | DocumentActionCustomDialogComponentProps

/**
 * @hidden
 * @beta */
declare interface DocumentActionModalDialogProps {
  type?: 'dialog'
  content: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  footer?: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  header?: React_2.ReactNode
  onClose: () => void
  showCloseButton?: boolean
  /**
   *
   * @hidden
   * @beta
   */
  width?: 'small' | 'medium' | 'large' | 'full'
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionPopoverDialogProps {
  type: 'popover'
  content: React_2.ReactNode
  onClose: () => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionProps extends EditStateFor {
  revision?: string
  onComplete: () => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionsContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta */
declare type DocumentActionsResolver = ComposableOption<
  DocumentActionComponent[],
  DocumentActionsContext
>

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeComponent {
  (props: DocumentBadgeProps): DocumentBadgeDescription | null
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeDescription {
  title?: string
  label?: string | undefined
  color?: 'primary' | 'success' | 'warning' | 'danger'
  icon?: React.ReactNode | React.ComponentType
}

/**
 * @hidden
 * @beta */
// eslint-disable-next-line @typescript-eslint/no-empty-interface
declare interface DocumentBadgeProps extends EditStateFor {}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgesContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta */
declare type DocumentBadgesResolver = ComposableOption<
  DocumentBadgeComponent[],
  DocumentBadgesContext
>

/**
 * @hidden
 * @beta */
export declare class DocumentBuilder implements Serializable<DocumentNode> {
  protected _context: StructureContext
  protected spec: PartialDocumentNode
  constructor(_context: StructureContext, spec?: PartialDocumentNode)
  id(id: string): DocumentBuilder
  getId(): PartialDocumentNode['id']
  title(title: string): DocumentBuilder
  getTitle(): PartialDocumentNode['title']
  child(child: Child): DocumentBuilder
  getChild(): PartialDocumentNode['child']
  documentId(documentId: string): DocumentBuilder
  getDocumentId(): Partial<DocumentOptions>['id']
  schemaType(documentType: SchemaType | string): DocumentBuilder
  getSchemaType(): Partial<DocumentOptions>['type']
  initialValueTemplate(templateId: string, parameters?: Record<string, unknown>): DocumentBuilder
  getInitialValueTemplate(): Partial<DocumentOptions>['template']
  getInitialValueTemplateParameters(): Partial<DocumentOptions>['templateParameters']
  views(views: (View | ViewBuilder)[]): DocumentBuilder
  getViews(): (View | ViewBuilder)[]
  serialize({path, index, hint}?: SerializeOptions): DocumentNode
  clone(withSpec?: PartialDocumentNode): DocumentBuilder
}

/** @internal */
declare type DocumentFormNode<
  T extends {[key in string]: unknown} = {[key in string]: unknown},
  S extends ObjectSchemaType = ObjectSchemaType
> = ObjectFormNode<T, S>

/** @internal */
export declare function documentFromEditor(
  context: StructureContext,
  spec?: EditorNode
): DocumentBuilder

/** @internal */
export declare function documentFromEditorWithInitialValue(
  {resolveDocumentNode, templates}: StructureContext,
  templateId: string,
  parameters?: Record<string, unknown>
): DocumentBuilder

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterComponent = ComponentType<{schemaType: ObjectSchemaType}>

/**
 *
 * @hidden
 * @beta
 */
declare interface DocumentLanguageFilterContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterResolver = ComposableOption<
  DocumentLanguageFilterComponent[],
  DocumentLanguageFilterContext
>

/**
 * @hidden
 * @beta */
export declare interface DocumentList extends GenericList {
  type: 'documentList'
  options: DocumentListOptions
  child: Child
  schemaTypeName?: string
}

/**
 * @hidden
 * @beta */
export declare class DocumentListBuilder extends GenericListBuilder<
  PartialDocumentList,
  DocumentListBuilder
> {
  protected _context: StructureContext
  protected spec: PartialDocumentList
  constructor(_context: StructureContext, spec?: DocumentListInput)
  apiVersion(apiVersion: string): DocumentListBuilder
  getApiVersion(): string | undefined
  filter(filter: string): DocumentListBuilder
  getFilter(): string | undefined
  schemaType(type: SchemaType | string): DocumentListBuilder
  getSchemaType(): string | undefined
  params(params: Record<string, unknown>): DocumentListBuilder
  getParams(): Record<string, unknown> | undefined
  defaultOrdering(ordering: SortOrderingItem[]): DocumentListBuilder
  getDefaultOrdering(): SortOrderingItem[] | undefined
  serialize(options?: SerializeOptions): DocumentList
  clone(withSpec?: PartialDocumentList): DocumentListBuilder
  getSpec(): PartialDocumentList
}

/**
 * @hidden
 * @beta */
export declare interface DocumentListInput extends GenericListInput {
  options: DocumentListOptions
}

/**
 * @hidden
 * @beta */
export declare interface DocumentListItem extends ListItem {
  schemaType: SchemaType
  _id: string
}

/**
 * @hidden
 * @beta */
export declare class DocumentListItemBuilder extends ListItemBuilder {
  protected _context: StructureContext
  protected spec: PartialDocumentListItem
  constructor(_context: StructureContext, spec?: DocumentListItemInput)
  serialize(options?: SerializeOptions): DocumentListItem
  clone(withSpec?: PartialDocumentListItem): DocumentListItemBuilder
}

/**
 * @hidden
 * @beta */
export declare interface DocumentListItemInput extends ListItemInput {
  schemaType: SchemaType | string
}

/**
 * @hidden
 * @beta */
export declare interface DocumentListOptions {
  filter: string
  params?: Record<string, unknown>
  apiVersion?: string
  defaultOrdering?: SortOrderingItem[]
}

/** @internal */
export declare interface DocumentListPaneNode extends BaseResolvedPaneNode<'documentList'> {
  defaultLayout?: GeneralPreviewLayoutKey
  displayOptions?: {
    showIcons?: boolean
  }
  initialValueTemplates?: InitialValueTemplateItem[]
  options: {
    filter: string
    defaultOrdering?: Array<{
      field: string
      direction: 'asc' | 'desc'
    }>
    params?: Record<string, unknown>
    apiVersion?: string
  }
  schemaTypeName: string
  source?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentMutationEvent {
  type: 'mutation'
  document: SanityDocument
  mutations: MutationPayload[]
  origin: 'local' | 'remote'
}

/**
 * @hidden
 * @beta */
export declare interface DocumentNode extends StructureNode {
  child?: Child
  options: {
    id: string
    type?: string
    template?: string
    templateParameters?: {
      [key: string]: any
    }
  }
  views: View[]
}

/**
 * @hidden
 * @beta */
export declare interface DocumentOptions {
  id: string
  type: string
  template?: string
  templateParameters?: Record<string, unknown>
}

/** @internal */
declare interface DocumentPaneContextValue {
  actions: DocumentActionComponent[] | null
  activeViewId: string | null
  badges: DocumentBadgeComponent[] | null
  changesOpen: boolean
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  compareValue: Partial<SanityDocument> | null
  connectionState: 'connecting' | 'reconnecting' | 'connected'
  displayed: Partial<SanityDocument> | null
  documentId: string
  documentIdRaw: string
  documentType: string
  editState: EditStateFor | null
  focusPath: Path
  index: number
  inspectOpen: boolean
  menuItemGroups: PaneMenuItemGroup[]
  menuItems: PaneMenuItem[]
  onBlur: (blurredPath: Path) => void
  onChange: (event: PatchEvent) => void
  onFocus: (pathOrEvent: Path) => void
  onHistoryClose: () => void
  onHistoryOpen: () => void
  onInspectClose: () => void
  onKeyUp: (event: React.KeyboardEvent<HTMLDivElement>) => void
  onMenuAction: (item: PaneMenuItem) => void
  onPaneClose: () => void
  onPaneSplit?: () => void
  onPathOpen: (path: Path) => void
  onSetActiveFieldGroup: (path: Path, groupName: string) => void
  onSetCollapsedPath: (path: Path, expanded: boolean) => void
  onSetCollapsedFieldSet: (path: Path, expanded: boolean) => void
  paneKey: string
  previewUrl?: string | null
  ready: boolean
  schemaType: ObjectSchemaType
  setTimelineMode: (mode: TimelineMode) => void
  setTimelineRange(since: string | null, rev: string | null): void
  source?: string
  timelineError: Error | null
  timelineMode: TimelineMode
  timelineStore: TimelineStore
  title: string | null
  validation: ValidationMarker[]
  value: SanityDocumentLike
  views: View[]
  formState: DocumentFormNode | null
  permissions?: PermissionCheckResult | null
  isPermissionsLoading: boolean
  unstable_languageFilter: DocumentLanguageFilterComponent[]
}

/** @internal */
export declare interface DocumentPaneNode extends BaseResolvedPaneNode<'document'> {
  options: {
    id: string
    type: string
    template?: string
    templateParameters?: Record<string, unknown>
  }
  source?: string
  views?: View[]
}

/**
 * @hidden
 * @beta */
declare interface DocumentPluginOptions {
  badges?: DocumentBadgeComponent[] | DocumentBadgesResolver
  actions?: DocumentActionComponent[] | DocumentActionsResolver
  /**
   * @hidden
   * @beta */
  productionUrl?: AsyncComposableOption<string | undefined, ResolveProductionUrlContext>
  /**
   * @hidden
   * @beta */
  unstable_languageFilter?: DocumentLanguageFilterResolver
  /**
   * @hidden
   * @beta */
  newDocumentOptions?: NewDocumentOptionsResolver
}

/**
 * @hidden
 * @beta */
declare interface DocumentRebaseEvent {
  type: 'rebase'
  document: SanityDocument
  remoteMutations: MutationPayload[]
  localMutations: MutationPayload[]
}

/**
 * @hidden
 * @beta */
declare interface DocumentRemoteMutationEvent {
  type: 'remoteMutation'
  head: SanityDocument
  transactionId: string
  author: string
  timestamp: Date
  effects: {
    apply: unknown
    revert: unknown
  }
}

/**
 * @hidden
 * @beta */
declare type DocumentRemoteMutationVersionEvent = Exclude<
  RemoteSnapshotVersionEvent,
  {type: 'snapshot'}
>

/**
 * @hidden
 * @beta */
declare interface DocumentStore {
  /** @internal */
  checkoutPair: (idPair: IdPair) => Pair
  initialValue: (
    opts: InitialValueOptions,
    context: InitialValueResolverContext
  ) => Observable<InitialValueMsg>
  listenQuery: (
    query: string | {fetch: string; listen: string},
    params: QueryParams,
    options: ListenQueryOptions
  ) => Observable<any>
  resolveTypeForDocument: (id: string, specifiedType?: string) => Observable<string>

  pair: {
    consistencyStatus: (publishedId: string, type: string) => Observable<boolean>
    /** @internal */
    documentEvents: (publishedId: string, type: string) => Observable<DocumentVersionEvent>
    /** @internal */
    editOperations: (publishedId: string, type: string) => Observable<OperationsAPI>
    editState: (publishedId: string, type: string) => Observable<EditStateFor>
    operationEvents: (
      publishedId: string,
      type: string
    ) => Observable<OperationSuccess | OperationError>
    validation: (publishedId: string, type: string) => Observable<ValidationStatus>
  }
}

/**
 * @hidden
 * @beta */
export declare class DocumentTypeListBuilder extends DocumentListBuilder {
  protected _context: StructureContext
  protected spec: PartialDocumentList
  constructor(_context: StructureContext, spec?: DocumentListInput)
  child(child: Child): DocumentTypeListBuilder
  clone(withSpec?: PartialDocumentList): DocumentTypeListBuilder
  cloneWithoutDefaultIntentHandler(withSpec?: PartialDocumentList): DocumentTypeListBuilder
}

/**
 * @hidden
 * @beta */
export declare interface DocumentTypeListInput extends Partial<GenericListInput> {
  schemaType: SchemaType | string
}

/**
 * @hidden
 * @beta */
declare interface DocumentVersion {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotVersionEvent>
  events: Observable<DocumentVersionEvent>

  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload

  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @hidden
 * @beta */
declare type DocumentVersionEvent = WithVersion<ReconnectEvent | BufferedDocumentEvent>

/**
 * This error may happen for arrays of objects where one or more of the members are having duplicate keys
 *
 * @public
 */
declare type DuplicateKeysError = {
  type: 'DUPLICATE_KEYS'
  schemaType: ArraySchemaType
  duplicates: [index: number, key: string][]
}

/**
 * @hidden
 * @beta */
export declare interface EditorNode extends StructureNode {
  child?: Child
  options: {
    id: string
    type?: string
    template?: string
    templateParameters?: {
      [key: string]: any
    }
  }
}

/**
 * @hidden
 * @beta */
export declare interface EditReferenceOptions {
  parentRefPath: Path
  id: string
  type: string
  template: {
    id: string
    params?: Record<string, string | number | boolean>
  }
}

/**
 * @hidden
 * @beta */
declare interface EditStateFor {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState | null
  draft: SanityDocument | null
  published: SanityDocument | null
  liveEdit: boolean
  ready: boolean
}

/** @public */
declare interface FieldError {
  kind: 'error'
  key: string
  fieldName: string
  error:
    | IncompatibleTypeError
    | TypeAnnotationMismatchError
    | MissingKeysError
    | DuplicateKeysError
    | UndeclaredMembersError
    | MixedArrayError
}

/** @public */
declare interface FieldMember<Node extends BaseFormNode = BaseFormNode> {
  kind: 'field'
  key: string
  name: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean

  /**
   * @internal
   * Whether this field is in the selected group
   */
  inSelectedGroup: boolean

  /**
   * @internal
   * Names of the field groups this field is part of
   */
  groups: string[]

  /**
   * @hidden
   * @beta */
  field: Node
}

/**
 * @hidden
 * @beta */
declare type FieldProps =
  | ObjectFieldProps
  | ObjectFieldProps<CrossDatasetReferenceValue>
  | ObjectFieldProps<FileValue>
  | ObjectFieldProps<GeopointValue>
  | ObjectFieldProps<ImageValue>
  | ObjectFieldProps<ReferenceValue>
  | ObjectFieldProps<SlugValue>
  | ArrayFieldProps
  | NumberFieldProps
  | BooleanFieldProps
  | StringFieldProps

/** @public */
declare interface FieldSetMember {
  kind: 'fieldSet'
  key: string

  // if it's hidden and in the currently selected group, it should still be excluded from its group
  _inSelectedGroup: boolean
  groups: string[]

  /**
   * @hidden
   * @beta */
  fieldSet: FieldsetState
}

/**
 * @hidden
 * @beta */
declare interface FieldsetState {
  path: Path
  name: string
  level: number
  title?: string
  description?: string
  hidden?: boolean
  collapsible?: boolean
  collapsed?: boolean
  columns?: number | number[]
  members: (FieldMember | FieldError)[]
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FileLike {
  // mime type
  type: string
  // file name (e.g. somefile.jpg)
  name?: string
}

/** @internal */
export declare const form: (spec?: Partial<FormView>) => FormViewBuilder

/**
 *
 * @hidden
 * @beta
 */
declare type FormBuilderCustomMarkersComponent = React_2.ComponentType<{
  markers: PortableTextMarker[]
}>

/**
 *
 * @hidden
 * @beta
 */
declare type FormBuilderMarkersComponent = React_2.ComponentType<{
  markers: PortableTextMarker[]
  renderCustomMarkers?: RenderCustomMarkers
  validation: FormNodeValidation[]
}>

/**
 *
 * @hidden
 * @beta
 */
declare interface FormDiffMatchPatch extends FormPatchBase {
  path: Path
  type: 'diffMatchPatch'
  origin?: FormPatchOrigin
  value: string
}

/**
 * @hidden
 * @beta */
declare interface FormFieldGroup {
  name: string
  selected?: boolean
  disabled?: boolean
  title?: string
  icon?: React_2.ComponentType
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormInsertPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'insert'
  position: FormInsertPatchPosition
  items: FormPatchJSONValue[]
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormInsertPatchPosition = 'before' | 'after'

/**
 * @hidden
 * @beta */
declare interface FormNodePresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatch =
  | FormSetPatch
  | FormSetIfMissingPatch
  | FormUnsetPatch
  | FormInsertPatch
  | FormDiffMatchPatch

/**
 * @hidden
 * @beta */
declare interface FormPatchBase {
  /**
   * A property used to identify this as a Sanity patch type, eg "set", "unset", "insert", etc.
   * This allows us to potentially introduce new patch types in the future without breaking
   * existing code. This is an internal property/implementation detail and should not be used by
   * consumers.
   *
   * @internal
   */
  patchType: symbol
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchJSONValue =
  | number
  | string
  | boolean
  | {[key: string]: FormPatchJSONValue}
  | FormPatchJSONValue[]

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchOrigin = 'remote' | 'local' | 'internal'

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetIfMissingPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'setIfMissing'
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetPatch extends FormPatchBase {
  path: Path
  type: 'set'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormUnsetPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'unset'
}

/**
 * @hidden
 * @beta */
export declare interface FormView extends BaseView {
  type: 'form'
}

/**
 * @hidden
 * @beta */
export declare class FormViewBuilder extends GenericViewBuilder<
  Partial<BaseView>,
  FormViewBuilder
> {
  protected spec: Partial<FormView>
  constructor(spec?: Partial<FormView>)
  serialize(options?: SerializeOptions): FormView
  clone(withSpec?: Partial<FormView>): FormViewBuilder
}

/**
 * @hidden
 * @beta */
declare type GeneralPreviewLayoutKey = 'default' | 'media' | 'detail'

/**
 * @hidden
 * @beta */
export declare interface GenericList extends BaseGenericList {
  type: string
  menuItems: MenuItem[]
  menuItemGroups: MenuItemGroup[]
}

/**
 * @hidden
 * @beta */
export declare abstract class GenericListBuilder<TList extends BuildableGenericList, ConcreteImpl>
  implements Serializable<GenericList>
{
  protected initialValueTemplatesSpecified: boolean
  protected spec: TList
  id(id: string): ConcreteImpl
  getId(): TList['id']
  title(title: string): ConcreteImpl
  getTitle(): TList['title']
  defaultLayout(defaultLayout: PreviewLayoutKey): ConcreteImpl
  getDefaultLayout(): TList['defaultLayout']
  menuItems(menuItems: (MenuItem | MenuItemBuilder)[] | undefined): ConcreteImpl
  getMenuItems(): TList['menuItems']
  menuItemGroups(menuItemGroups: (MenuItemGroup | MenuItemGroupBuilder)[]): ConcreteImpl
  getMenuItemGroups(): TList['menuItemGroups']
  child(child: Child): ConcreteImpl
  getChild(): TList['child']
  canHandleIntent(canHandleIntent: IntentChecker): ConcreteImpl
  getCanHandleIntent(): TList['canHandleIntent']
  showIcons(enabled?: boolean): ConcreteImpl
  getShowIcons(): boolean | undefined
  initialValueTemplates(
    templates:
      | InitialValueTemplateItem
      | InitialValueTemplateItemBuilder
      | Array<InitialValueTemplateItem | InitialValueTemplateItemBuilder>
  ): ConcreteImpl
  getInitialValueTemplates(): TList['initialValueTemplates']
  serialize(options?: SerializeOptions): GenericList
  abstract clone(_withSpec?: object): ConcreteImpl
}

/**
 * @hidden
 * @beta */
export declare interface GenericListInput extends StructureNode {
  id: string
  title: string
  menuItems?: (MenuItem | MenuItemBuilder)[]
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
  initialValueTemplates?: (InitialValueTemplateItem | InitialValueTemplateItemBuilder)[]
  defaultLayout?: PreviewLayoutKey
  canHandleIntent?: IntentChecker
  child?: Child
}

/**
 * @hidden
 * @beta */
export declare abstract class GenericViewBuilder<TView extends Partial<BaseView>, ConcreteImpl>
  implements Serializable<BaseView>
{
  protected spec: TView
  id(id: string): ConcreteImpl
  getId(): TView['id']
  title(title: string): ConcreteImpl
  getTitle(): TView['title']
  icon(icon: React.ComponentType | React.ReactNode): ConcreteImpl
  getIcon(): TView['icon']
  serialize(options?: SerializeOptions): BaseView
  abstract clone(withSpec?: Partial<BaseView>): ConcreteImpl
}

/** @internal */
export declare function getOrderingMenuItem(
  context: StructureContext,
  ordering: SortOrdering,
  extendedProjection?: string
): MenuItemBuilder

/** @internal */
export declare function getOrderingMenuItemsForSchemaType(
  context: StructureContext,
  typeName: SchemaType | string
): MenuItemBuilder[]

/** @internal */
export declare function getTypeNamesFromFilter(
  filter: string,
  params?: Record<string, unknown>
): string[]

declare type GuardedOperation = Operation<any[], 'NOT_READY'>

/** @internal */
export declare enum HELP_URL {
  ID_REQUIRED = 'structure-node-id-required',
  TITLE_REQUIRED = 'structure-title-required',
  FILTER_REQUIRED = 'structure-filter-required',
  INVALID_LIST_ITEM = 'structure-invalid-list-item',
  COMPONENT_REQUIRED = 'structure-view-component-required',
  DOCUMENT_ID_REQUIRED = 'structure-document-id-required',
  DOCUMENT_TYPE_REQUIRED = 'structure-document-type-required',
  SCHEMA_TYPE_REQUIRED = 'structure-schema-type-required',
  SCHEMA_TYPE_NOT_FOUND = 'structure-schema-type-not-found',
  LIST_ITEMS_MUST_BE_ARRAY = 'structure-list-items-must-be-array',
  QUERY_PROVIDED_FOR_FILTER = 'structure-query-provided-for-filter',
  ACTION_OR_INTENT_REQUIRED = 'structure-action-or-intent-required',
  LIST_ITEM_IDS_MUST_BE_UNIQUE = 'structure-list-item-ids-must-be-unique',
  ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE = 'structure-action-and-intent-mutually-exclusive',
}

/** @internal */
declare interface HiddenField {
  kind: 'hidden'
  key: string
  name: string
  index: number
}

/** @internal */
declare interface IdPair {
  draftId: string
  publishedId: string
}

/**
 * This error may happen if the member type is structurally incompatible with the defined schema type.
 * Some examples:
 *   - the schema type defines an array, but the actual value is an object (or vice versa)
 *   - the schema type defines a number, but the actual value is a string (or vice versa)
 *   - the schema type defines an object, but the actual value is a string (or vice versa)
 *
 * @public
 */
declare type IncompatibleTypeError = {
  type: 'INCOMPATIBLE_TYPE'
  expectedSchemaType: SchemaType
  resolvedValueType: string
  value: unknown
}

/**
 * @hidden
 * @beta */
declare interface InitialValueErrorMsg {
  type: 'error'
  error: Error
}

/**
 * @hidden
 * @beta */
declare interface InitialValueLoadingMsg {
  type: 'loading'
}

/**
 * @hidden
 * @beta */
declare type InitialValueMsg =
  | InitialValueLoadingMsg
  | InitialValueSuccessMsg
  | InitialValueErrorMsg

/**
 * @hidden
 * @beta */
declare interface InitialValueOptions {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, any>
}

/**
 * @hidden
 * @beta */
declare interface InitialValueSuccessMsg {
  type: 'success'
  value: SanityDocumentLike | null
}

/**
 * @hidden
 * @beta */
declare interface InitialValueTemplateItem extends TemplateResponse {
  id: string
  type: 'initialValueTemplateItem'
  schemaType: string
}

/**
 * @hidden
 * @beta */
export declare class InitialValueTemplateItemBuilder
  implements Serializable<InitialValueTemplateItem>
{
  protected _context: StructureContext
  protected spec: Partial<InitialValueTemplateItem>
  constructor(_context: StructureContext, spec?: Partial<InitialValueTemplateItem>)
  id(id: string): InitialValueTemplateItemBuilder
  getId(): Partial<InitialValueTemplateItem>['id']
  title(title: string): InitialValueTemplateItemBuilder
  getTitle(): Partial<InitialValueTemplateItem>['title']
  description(description: string): InitialValueTemplateItemBuilder
  getDescription(): Partial<InitialValueTemplateItem>['description']
  templateId(templateId: string): InitialValueTemplateItemBuilder
  getTemplateId(): Partial<InitialValueTemplateItem>['templateId']
  parameters(parameters: {[key: string]: any}): InitialValueTemplateItemBuilder
  getParameters(): Partial<InitialValueTemplateItem>['parameters']
  serialize({path, index, hint}?: SerializeOptions): InitialValueTemplateItem
  clone(withSpec?: Partial<InitialValueTemplateItem>): InitialValueTemplateItemBuilder
}

/**
 * @hidden
 * @beta */
declare type InputProps =
  | ArrayOfObjectsInputProps
  | ArrayOfPrimitivesInputProps
  | BooleanInputProps
  | NumberInputProps
  | ObjectInputProps
  | ObjectInputProps<CrossDatasetReferenceValue>
  | ObjectInputProps<FileValue>
  | ObjectInputProps<GeopointValue>
  | ObjectInputProps<ImageValue>
  | ObjectInputProps<ReferenceValue>
  | ObjectInputProps<SlugValue>
  | PortableTextInputProps
  | StringInputProps

/**
 * @hidden
 * @beta */
export declare interface Intent {
  type: string
  params?: IntentParams
}

/**
 * @hidden
 * @beta */
export declare interface IntentChecker {
  (
    intentName: string,
    params: {
      [key: string]: any
    },
    context: {
      pane: StructureNode
      index: number
    }
  ): boolean
  identity?: symbol
}

/**
 * @hidden
 * @beta */
export declare type IntentJsonParams = {
  [key: string]: any
}

/**
 * @hidden
 * @beta */
export declare type IntentParams = BaseIntentParams | [BaseIntentParams, IntentJsonParams]

/**
 * This error may happen for arrays (of both objects and primitive values) if we encounter items that are not valid according to the schema definition
 *
 *
 * @hidden
 * @beta
 */
declare type InvalidItemTypeError = {
  type: 'INVALID_ITEM_TYPE'
  validTypes: SchemaType[]
  resolvedValueType: string
  value: unknown
}

/** @internal */
export declare function isDocumentListItem(item: unknown): item is DocumentListItem

/**
 * @hidden
 * @beta */
export declare type ItemChild = CollectionBuilder | Collection | undefined

/** @public */
declare type ItemProps =
  | ObjectItemProps
  | ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>
  | ObjectItemProps<FileValue & ObjectItem>
  | ObjectItemProps<GeopointValue & ObjectItem>
  | ObjectItemProps<ImageValue & ObjectItem>
  | ObjectItemProps<ReferenceValue & ObjectItem>
  | ObjectItemProps<SlugValue & ObjectItem>
  | PrimitiveItemProps

/**
 * @hidden
 * @beta */
// Components
declare interface LayoutProps {
  renderDefault: (props: LayoutProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta */
export declare interface List extends GenericList {
  type: 'list'
  items: (ListItem | Divider)[]
}

/**
 * @hidden
 * @beta */
export declare class ListBuilder extends GenericListBuilder<BuildableList, ListBuilder> {
  protected _context: StructureContext
  protected spec: BuildableList
  constructor(_context: StructureContext, spec?: ListInput)
  items(items: (ListItemBuilder | ListItem | Divider)[]): ListBuilder
  getItems(): BuildableList['items']
  serialize(options?: SerializeOptions): List
  clone(withSpec?: BuildableList): ListBuilder
}

/**
 * @hidden
 * @beta */
export declare interface ListDisplayOptions {
  showIcons?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ListenQueryOptions {
  tag?: string
  apiVersion?: string
  throttleTime?: number
  transitions?: ('update' | 'appear' | 'disappear')[]
}

/**
 * @hidden
 * @beta */
export declare interface ListInput extends GenericListInput {
  items?: (ListItem | ListItemBuilder | Divider)[]
}

/**
 * @hidden
 * @beta */
export declare interface ListItem {
  id: string
  type: string
  title?: string
  icon?: React.ComponentType | React.ReactNode
  child?: ListItemChild
  displayOptions?: ListItemDisplayOptions
  schemaType?: SchemaType
}

/**
 * @hidden
 * @beta */
export declare class ListItemBuilder implements Serializable<ListItem> {
  protected _context: StructureContext
  protected spec: PartialListItem
  constructor(_context: StructureContext, spec?: ListItemInput)
  id(id: string): ListItemBuilder
  getId(): PartialListItem['id']
  title(title: string): ListItemBuilder
  getTitle(): PartialListItem['title']
  icon(icon: React.ComponentType | React.ReactNode): ListItemBuilder
  showIcon(enabled?: boolean): ListItemBuilder
  getShowIcon(): boolean | undefined
  getIcon(): PartialListItem['icon']
  child(child: UnserializedListItemChild): ListItemBuilder
  getChild(): PartialListItem['child']
  schemaType(schemaType: SchemaType | string): ListItemBuilder
  getSchemaType(): PartialListItem['schemaType']
  serialize(options?: ListItemSerializeOptions): ListItem
  clone(withSpec?: PartialListItem): ListItemBuilder
}

/**
 * @hidden
 * @beta */
export declare type ListItemChild = Collection | ChildResolver | Observable<ItemChild> | undefined

/**
 * @hidden
 * @beta */
export declare interface ListItemDisplayOptions {
  showIcon?: boolean
}

/**
 * @hidden
 * @beta */
export declare interface ListItemInput {
  id: string
  title?: string
  icon?: React.ComponentType | React.ReactNode
  child?: ListItemChild
  displayOptions?: ListItemDisplayOptions
  schemaType?: SchemaType | string
}

/**
 * @hidden
 * @beta */
export declare interface ListItemSerializeOptions extends SerializeOptions {
  titleIsOptional?: boolean
}

/** @internal */
export declare interface ListPaneNode extends BaseResolvedPaneNode<'list'> {
  defaultLayout?: GeneralPreviewLayoutKey
  displayOptions?: {
    showIcons?: boolean
  }
  items?: Array<PaneListItem | PaneListItemDivider>
  source?: string
}

/** @internal */
declare type LoginComponentProps = Omit<WorkspaceSummary, 'type' | '__internal'>

/**
 * @hidden
 * @beta */
declare interface LogoProps {
  title: string
  renderDefault: (props: LogoProps) => React_2.ReactElement
}

/** @internal */
export declare function maybeSerializeInitialValueTemplateItem(
  item: InitialValueTemplateItem | InitialValueTemplateItemBuilder,
  index: number,
  path: SerializePath
): InitialValueTemplateItem

/** @internal */
export declare function maybeSerializeMenuItem(
  item: MenuItem | MenuItemBuilder,
  index: number,
  path: SerializePath
): MenuItem

/** @internal */
export declare function maybeSerializeMenuItemGroup(
  item: MenuItemGroup | MenuItemGroupBuilder,
  index: number,
  path: SerializePath
): MenuItemGroup

/** @internal */
export declare function maybeSerializeView(
  item: View | Serializable<View>,
  index: number,
  path: SerializePath
): View

/**
 * @hidden
 * @beta */
export declare interface MenuItem {
  title: string
  action?: MenuItemActionType
  intent?: Intent
  group?: string
  icon?: React.ComponentType | React.ReactNode
  params?: MenuItemParamsType
  showAsAction?: boolean
}

/**
 * @hidden
 * @beta */
export declare type MenuItemActionType =
  | string
  | ((params: Record<string, string> | undefined, scope?: any) => void)

/**
 * @hidden
 * @beta */
export declare class MenuItemBuilder implements Serializable<MenuItem> {
  protected _context: StructureContext
  protected spec: PartialMenuItem
  constructor(_context: StructureContext, spec?: MenuItem)
  action(action: MenuItemActionType): MenuItemBuilder
  getAction(): PartialMenuItem['action']
  intent(intent: Intent): MenuItemBuilder
  getIntent(): PartialMenuItem['intent']
  title(title: string): MenuItemBuilder
  getTitle(): string | undefined
  group(group: string): MenuItemBuilder
  getGroup(): PartialMenuItem['group']
  icon(icon: React.ComponentType | React.ReactNode): MenuItemBuilder
  getIcon(): PartialMenuItem['icon']
  params(params: MenuItemParamsType): MenuItemBuilder
  getParams(): PartialMenuItem['params']
  showAsAction(showAsAction?: boolean): MenuItemBuilder
  getShowAsAction(): PartialMenuItem['showAsAction']
  serialize(options?: SerializeOptions): MenuItem
  clone(withSpec?: PartialMenuItem): MenuItemBuilder
}

/**
 * @hidden
 * @beta */
export declare interface MenuItemGroup {
  id: string
  title: string
}

/**
 * @hidden
 * @beta */
export declare class MenuItemGroupBuilder implements Serializable<MenuItemGroup> {
  protected _context: StructureContext
  protected _id: string
  protected _title: string
  constructor(_context: StructureContext, spec?: MenuItemGroup)
  id(id: string): MenuItemGroupBuilder
  getId(): string
  title(title: string): MenuItemGroupBuilder
  getTitle(): string
  serialize(options?: SerializeOptions): MenuItemGroup
}

/**
 * @hidden
 * @beta */
export declare type MenuItemParamsType = Record<string, string | unknown | undefined>

/** @internal */
export declare function menuItemsFromInitialValueTemplateItems(
  context: StructureContext,
  templateItems: InitialValueTemplateItem[]
): MenuItem[]

declare type Meta = {chunk: Chunk; transactionIndex: number} | null

/**
 * This error may happen for arrays of objects where one or more of the members are missing a _key
 *
 * @public
 */
declare type MissingKeysError = {
  type: 'MISSING_KEYS'
  schemaType: ArraySchemaType
  value: {_key?: string}[]
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type MixedArrayError = {type: 'MIXED_ARRAY'; schemaType: ArraySchemaType; value: unknown[]}

/**
 * @hidden
 * @beta */
// HTTP API Mutation payloads
// Note: this is *not* the same as the Mutation helper class exported by @sanity/mutator
declare interface MutationPayload {
  create?: any
  createIfNotExists?: any
  createOrReplace?: any
  delete?: any
  patch?: any
}

/**
 * @hidden
 * @beta */
declare interface NavbarProps {
  renderDefault: (props: NavbarProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta */
declare type NewDocumentCreationContext =
  | {type: 'global'; documentId?: undefined; schemaType?: undefined}
  | {type: 'document'; documentId: string; schemaType: string}
  | {type: 'structure'; documentId?: undefined; schemaType: string}

/**
 * @hidden
 * @beta */
declare interface NewDocumentOptionsContext extends ConfigContext {
  creationContext: NewDocumentCreationContext
}

/**
 * @hidden
 * @beta */
declare type NewDocumentOptionsResolver = ComposableOption<
  TemplateResponse[],
  NewDocumentOptionsContext
>

/**
 * @hidden
 * @beta */
declare interface NumberFieldProps extends BaseFieldProps {
  schemaType: NumberSchemaType
  value: number | undefined
  inputProps: NumberInputProps
}

/** @public */
declare type NumberFormNode<S extends NumberSchemaType = NumberSchemaType> = BaseFormNode<number, S>

/**
 * @hidden
 * @beta */
declare interface NumberInputProps<S extends NumberSchemaType = NumberSchemaType>
  extends BaseInputProps,
    NumberFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/** @public */
declare interface ObjectArrayFormNode<
  T extends ObjectItem = ObjectItem,
  S extends ObjectSchemaType = ObjectSchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  value: T

  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]

  /** @internal */
  _allMembers: ObjectMember[]
  changesOpen?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ObjectFieldProps<T = Record<string, any>> extends BaseFieldProps {
  schemaType: ObjectSchemaType
  value: {[field in string]: unknown} | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  inputProps: ObjectInputProps<T>
}

/** @public */
declare interface ObjectFormNode<
  T = {[key in string]: unknown},
  S extends ObjectSchemaType = ObjectSchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  /** @internal */
  _allMembers: (ObjectMember | HiddenField)[]
}

/**
 * @hidden
 * @beta */
declare interface ObjectInputProps<
  T = Record<string, any>,
  S extends ObjectSchemaType = ObjectSchemaType
> extends BaseInputProps,
    Omit<ObjectFormNode<T, S>, '_allMembers'> {
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]

  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void

  /**
   * @hidden
   * @beta */
  onFieldCollapse: (fieldName: string) => void

  /**
   * @hidden
   * @beta */
  onFieldExpand: (fieldName: string) => void

  /**
   * @hidden
   * @beta */
  onFieldSetCollapse: (fieldSetName: string) => void

  /**
   * @hidden
   * @beta */
  onFieldSetExpand: (fieldSetName: string) => void

  /**
   * @hidden
   * @beta */
  onFieldGroupSelect: (groupName: string) => void

  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void

  /**
   * @hidden
   * @beta */
  onFieldOpen: (fieldName: string) => void

  /**
   * @hidden
   * @beta */
  onFieldClose: (fieldName: string) => void

  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback

  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback

  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback

  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback

  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback

  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback

  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback

  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/** @public */
declare type ObjectItem = {
  _type?: string
  _key: string
}

/** @public */
declare interface ObjectItemProps<Item extends ObjectItem = ObjectItem>
  extends BaseItemProps<Item> {
  changed: boolean
  schemaType: ObjectSchemaType
  parentSchemaType: ArraySchemaType
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  value: Item
  /**
   * @hidden
   * @beta */
  inputProps: Omit<ObjectInputProps, 'renderDefault'>
}

/** @public */
declare type ObjectMember = FieldMember | FieldSetMember | FieldError

/** @internal */
declare interface Operation<ExtraArgs extends any[] = [], ErrorStrings extends string = string> {
  disabled: false | ErrorStrings | 'NOT_READY'
  execute(...extra: ExtraArgs): void
}

/**
 * @hidden
 * @beta */
declare interface OperationError {
  type: 'error'
  /** @internal */
  op: keyof OperationsAPI
  id: string
  error: Error
}

/** @internal */
// Note: Changing this interface in a backwards incompatible manner will be a breaking change
declare interface OperationsAPI {
  commit: Operation | GuardedOperation
  delete: Operation<[], 'NOTHING_TO_DELETE' | 'NOT_READY'>
  del: Operation<[], 'NOTHING_TO_DELETE'> | GuardedOperation
  publish:
    | Operation<[], 'LIVE_EDIT_ENABLED' | 'ALREADY_PUBLISHED' | 'NO_CHANGES'>
    | GuardedOperation
  patch: Operation<[patches: Patch[], initialDocument?: Record<string, any>]> | GuardedOperation
  discardChanges: Operation<[], 'NO_CHANGES' | 'NOT_PUBLISHED'> | GuardedOperation
  unpublish: Operation<[], 'LIVE_EDIT_ENABLED' | 'NOT_PUBLISHED'> | GuardedOperation
  duplicate: Operation<[documentId: string], 'NOTHING_TO_DUPLICATE'> | GuardedOperation
  restore: Operation<[revision: string]> | GuardedOperation
}

/**
 * @hidden
 * @beta */
declare interface OperationSuccess {
  type: 'success'
  /** @internal */
  op: keyof OperationsAPI
  id: string
}

declare type Operator<TOperators = string> = OperatorDivider | OperatorItem<TOperators>

/**
 * @alpha
 */
declare interface OperatorButtonValueComponentProps<T> {
  value: T
}

declare type OperatorDivider = {
  type: 'divider'
}

/**
 * @alpha
 */
declare interface OperatorInputComponentProps<T> {
  fieldDefinition?: SearchFieldDefinition
  onChange: (value: T | null) => void
  value: T | null
}

declare type OperatorItem<TOperators = string> = {
  name: TOperators
  type: 'item'
}

/**
 * @hidden
 * @beta */
declare interface Pair {
  /** @internal */
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  published: DocumentVersion
  draft: DocumentVersion
}

/** @internal */
export declare interface PaneListItem<TParams = unknown> {
  type: 'listItem'
  id: string
  _id?: string
  schemaType?: SchemaType
  title: string
  icon?: React.ComponentType | false
  displayOptions?: {
    showIcon?: boolean
  }
  action?: (t: TParams) => unknown
  params?: TParams
}

/** @internal */
export declare interface PaneListItemDivider {
  type: 'divider'
}

/**
 * Represents what can be passed into `menuItems` inside of desk-tool panes
 *
 * @see BaseResolvedPaneNode
 *
 * @internal
 */
export declare interface PaneMenuItem extends DeskToolMenuItem {
  isDisabled?: boolean
  shortcut?: string
  selected?: boolean
}

/** @internal */
export declare interface PaneMenuItemGroup {
  id: string
  title?: string
}

/** @internal */
export declare type PaneNode =
  | CustomComponentPaneNode
  | DocumentPaneNode
  | DocumentListPaneNode
  | ListPaneNode

/** @internal */
export declare type PaneNodeResolver = (
  id: string,
  context: RouterPaneSiblingContext
) => UnresolvedPaneNode

/**
 * @hidden
 * @beta */
export declare interface PaneRouterContextValue {
  /**
   * Zero-based index (position) of pane, visually
   */
  index: number
  /**
   * Zero-based index of pane group (within URL structure)
   */
  groupIndex: number
  /**
   * Zero-based index of pane within sibling group
   */
  siblingIndex: number
  /**
   * Payload of the current pane
   */
  payload?: unknown
  /**
   * Params of the current pane
   */
  params?: RouterPaneSibling['params']
  /**
   * Whether or not the pane has any siblings (within the same group)
   */
  hasGroupSiblings: boolean
  /**
   * The length of the current group
   */
  groupLength: number
  /**
   * Current router state for the "panes" property
   */
  routerPanesState: RouterPanes
  /**
   * Curried StateLink that passes the correct state automatically
   */
  ChildLink: React_2.ComponentType<ChildLinkProps>
  /**
   * Curried StateLink that pops off the last pane group
   */
  BackLink: React_2.ComponentType<BackLinkProps>
  /**
   * A specialized `ChildLink` that takes in the needed props to open a
   * referenced document to the right
   */
  ReferenceChildLink: React_2.ComponentType<ReferenceChildLinkProps>
  /**
   * Similar to `ReferenceChildLink` expect without the wrapping component
   */
  handleEditReference: (options: EditReferenceOptions) => void
  /**
   * Curried StateLink that passed the correct state, but merges params/payload
   */
  ParameterizedLink: React_2.ComponentType<ParameterizedLinkProps>
  /**
   * Replaces the current pane with a new one
   */
  replaceCurrent: (pane: {id?: string; payload?: unknown; params?: Record<string, string>}) => void
  /**
   * Removes the current pane from the group
   */
  closeCurrent: () => void
  /**
   * Duplicate the current pane, with optional overrides for item ID and parameters
   */
  duplicateCurrent: (pane?: {payload?: unknown; params?: Record<string, string>}) => void
  /**
   * Set the current "view" for the pane
   */
  setView: (viewId: string | null) => void
  /**
   * Set the parameters for the current pane
   */
  setParams: (params: Record<string, string | undefined>) => void
  /**
   * Set the payload for the current pane
   */
  setPayload: (payload: unknown) => void
  /**
   * Proxied navigation to a given intent. Consider just exposing `router` instead?
   */
  navigateIntent: (
    intentName: string,
    params: Record<string, string>,
    options?: {
      replace?: boolean
    }
  ) => void
}

/**
 * @hidden
 * @beta */
export declare interface ParameterizedLinkProps {
  params?: Record<string, string>
  payload?: unknown
}

/**
 * @hidden
 * @beta */
declare type ParsedTimeRef = Chunk | 'loading' | 'invalid'

/**
 * @hidden
 * @beta */
declare type PartialContext<TContext extends ConfigContext> = Pick<
  TContext,
  Exclude<keyof TContext, keyof ConfigContext>
>

/**
 * @hidden
 * @beta */
export declare interface PartialDocumentList extends BuildableGenericList {
  options?: DocumentListOptions
  schemaTypeName?: string
}

/**
 * @hidden
 * @beta */
export declare type PartialDocumentListItem = Partial<UnserializedListItem>

/**
 * @hidden
 * @beta */
export declare type PartialDocumentNode = {
  id?: string
  title?: string
  child?: Child
  views?: (View | ViewBuilder)[]
  options?: Partial<DocumentOptions>
}

/**
 * @hidden
 * @beta */
export declare type PartialListItem = Partial<UnserializedListItem>

/**
 * @hidden
 * @beta */
export declare type PartialMenuItem = Partial<MenuItem>

declare type Patch = any

/**
 *
 * @hidden
 * @beta
 */
declare type PatchArg = FormPatch | FormPatch[]

/**
 *
 * @hidden
 * @beta
 */
declare class PatchEvent {
  static from(input: PatchArg | PatchEvent): PatchEvent {
    if (input instanceof PatchEvent) {
      return input
    }
    return new PatchEvent(Array.isArray(input) ? flatten(input) : [input])
  }

  patches: Array<FormPatch>

  constructor(patches: Array<FormPatch>) {
    this.patches = patches
  }

  prepend(...patches: PatchArg[]): PatchEvent {
    return PatchEvent.from([...flatten(patches), ...this.patches])
  }

  append(...patches: PatchArg[]): PatchEvent {
    return PatchEvent.from([...this.patches, ...flatten(patches)])
  }

  prefixAll(segment: PathSegment): PatchEvent {
    return PatchEvent.from(this.patches.map((patch) => prefixPath(patch, segment)))
  }
}

/** @internal */
declare interface PendingMutationsEvent {
  type: 'pending'
  phase: 'begin' | 'end'
}

/**
 * @hidden
 * @beta */
declare interface PermissionCheckResult {
  granted: boolean
  reason: string
}

/**
 * @hidden
 * @beta */
declare type Plugin_2<TOptions = void> = (options: TOptions) => PluginOptions

/**
 * @hidden
 * @beta */
declare interface PluginOptions {
  name: string
  plugins?: PluginOptions[]
  schema?: SchemaPluginOptions
  // TODO:
  // components?: ComponentPluginOptions
  document?: DocumentPluginOptions
  tools?: Tool[] | ComposableOption<Tool[], ConfigContext>
  form?: SanityFormConfig
  studio?: {
    components?: StudioComponentsPluginOptions
  }
}

/**
 * @hidden
 * @beta */
declare interface PortableTextInputProps
  extends ArrayOfObjectsInputProps<PortableTextBlock, ArraySchemaType<PortableTextBlock>> {
  hotkeys?: HotkeyOptions
  markers?: PortableTextMarker[]
  onCopy?: OnCopyFn
  onPaste?: OnPasteFn
  renderBlockActions?: RenderBlockActionsCallback
  renderCustomMarkers?: RenderCustomMarkers
}

/**
 * A generic marker for attaching metadata to specific nodes of the Portable Text input.
 *
 *
 * @hidden
 * @beta
 */
declare interface PortableTextMarker {
  type: string
  data?: unknown
  path: Path
}

/**
 * @hidden
 * @beta */
declare type PortableTextPreviewLayoutKey = 'block' | 'blockImage' | 'inline'

/**
 * @hidden
 * @beta */
declare type PreviewLayoutKey = GeneralPreviewLayoutKey | PortableTextPreviewLayoutKey

/**
 * @hidden
 * @beta */
declare type PreviewMediaDimensions = {
  aspect?: number
  dpr?: number
  fit?: ImageUrlFitMode
  height?: number
  width?: number
}

/**
 *
 * @hidden
 * @beta
 */
declare interface PreviewProps<TLayoutKey = PreviewLayoutKey> {
  actions?: ReactNode | ComponentType<{layout: TLayoutKey}>
  children?: ReactNode
  description?: ReactNode | ComponentType<{layout: TLayoutKey}>
  error?: Error | null
  fallbackTitle?: ReactNode
  imageUrl?: string
  isPlaceholder?: boolean
  layout?: TLayoutKey
  media?: ReactNode | ComponentType<{dimensions: PreviewMediaDimensions; layout: TLayoutKey}>
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?: ReactNode | ComponentType<{layout: TLayoutKey}>
  subtitle?: ReactNode | ComponentType<{layout: TLayoutKey}>
  title?: ReactNode | ComponentType<{layout: TLayoutKey}>
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType?: SchemaType
  renderDefault: (props: PreviewProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta */
declare type PrimitiveFormNode = BooleanFormNode | NumberFormNode | StringFormNode

/**
 * @hidden
 * @beta */
declare interface PrimitiveInputElementProps {
  value?: string
  id: string
  readOnly: boolean
  placeholder?: string
  onChange: FormEventHandler
  onFocus: FocusEventHandler
  onBlur: FocusEventHandler
  ref: React_2.MutableRefObject<any>
}

/** @public */
declare interface PrimitiveItemProps extends BaseItemProps<string | number | boolean> {
  value: string | number | boolean
  schemaType: NumberSchemaType | BooleanSchemaType | StringSchemaType
  parentSchemaType: ArraySchemaType
}

/**
 * @hidden
 * @beta */
declare type QueryParams = Record<string, string | number | boolean | string[]>

/**
 * @hidden
 * @beta */
declare interface ReconnectEvent {
  type: 'reconnect'
}

/**
 * A reconstruction represents a single reconstruction of a
 */
declare class Reconstruction {
  timeline: Timeline
  start: Chunk | null
  end: Chunk
  doc: CombinedDocument

  constructor(timeline: Timeline, doc: CombinedDocument, start: Chunk | null, end: Chunk) {
    this.timeline = timeline
    this.start = start
    this.end = end
    this.doc = doc
  }

  same(start: Chunk | null, end: Chunk): boolean {
    return this.start === start && this.end === end
  }

  private _startDocument?: CombinedDocument
  private _endDocument?: CombinedDocument
  private _diff?: Diff<Annotation>

  /** Returns the attributes as seen at the end of the range. */
  endAttributes(): Record<string, unknown> | null {
    return getAttrs(this.endDocument())
  }

  endDocument(): CombinedDocument {
    if (!this._endDocument) {
      this._endDocument = this.timeline.replayBackwardsUntil(this.end.end, this.doc)
    }

    return this._endDocument
  }

  /** Returns the attributes as seen at the end of the range. */
  startAttributes(): Record<string, unknown> | null {
    return getAttrs(this.startDocument())
  }

  startDocument(): CombinedDocument {
    if (!this.start) throw new Error('start required')

    if (!this._startDocument) {
      this._startDocument = this.timeline.replayBackwardsBetween(
        this.start.end,
        this.end.end - 1,
        this.endDocument()
      )
    }

    return this._startDocument
  }

  diff(): Diff<Annotation> {
    if (!this._diff) {
      if (!this.start) throw new Error('start required')

      this._diff = this.timeline.calculateDiff(
        this.startDocument(),
        this.endDocument(),
        this.start.index + 1,
        this.end.index
      )
    }

    return this._diff
  }
}

/**
 * @hidden
 * @beta */
export declare interface ReferenceChildLinkProps {
  documentId: string
  documentType: string
  parentRefPath: Path
  template?: {
    id: string
    params?: Record<string, string | number | boolean>
  }
  children: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotEvent = DocumentRemoteMutationEvent | SnapshotEvent

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotVersionEvent = WithVersion<RemoteSnapshotEvent>

/**
 * @hidden
 * @beta */
declare type RenderAnnotationCallback<T extends BlockAnnotationProps = BlockAnnotationProps> = (
  annotationProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta  */
declare type RenderArrayOfObjectsItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
declare type RenderArrayOfPrimitivesItemCallback = (
  itemProps: Omit<PrimitiveItemProps, 'renderDefault'>
) => ReactNode

/**
 *
 * @hidden
 * @beta
 */
declare type RenderBlockActionsCallback = (props: RenderBlockActionsProps) => React.ReactNode

/**
 *
 * @hidden
 * @beta
 */
declare interface RenderBlockActionsProps {
  block: PortableTextBlock
  value: PortableTextBlock[] | undefined
  set: (block: PortableTextBlock) => void
  unset: () => void
  insert: (block: PortableTextBlock | PortableTextBlock[]) => void
}

/**
 * @hidden
 * @beta */
declare type RenderBlockCallback<T extends BlockProps = BlockProps> = (
  blockProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * Export `PortableTextMarker` so it can be used to build custom Portable Text markers.
 *
 *
 * @hidden
 * @beta
 */
declare type RenderCustomMarkers = (markers: PortableTextMarker[]) => React_2.ReactNode

/**
 * @hidden
 * @beta */
declare type RenderFieldCallback<T extends FieldProps = FieldProps> = (
  fieldProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
declare type RenderInputCallback<T extends InputProps = InputProps> = (
  inputProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
declare type RenderPreviewCallback = (props: RenderPreviewCallbackProps) => ReactNode

/**
 *
 * @hidden
 * @beta
 */
declare interface RenderPreviewCallbackProps<TLayoutKey = PreviewLayoutKey> {
  actions?: ReactNode | ComponentType<{layout: TLayoutKey}>
  children?: ReactNode
  error?: Error | null
  fallbackTitle?: ReactNode
  isPlaceholder?: boolean
  layout?: TLayoutKey
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?: ReactNode | ComponentType<{layout: TLayoutKey}>
  value: unknown
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType: SchemaType
  skipVisibilityCheck?: boolean
  style?: CSSProperties
}

/**
 * @hidden
 * @beta */
declare interface ResolveProductionUrlContext extends ConfigContext {
  document: SanityDocumentLike
}

/**
 * @public
 */
declare interface Route {
  raw: string
  segments: RouteSegment[]
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
}

/**
 * @public
 */
declare type RouteChildren =
  | RouterNode[]
  | ((state: RouterState) => Router | RouterNode | RouterNode[] | undefined | false)

/**
 * @public
 */
declare interface Router extends RouterNode {
  _isRoute: boolean
  encode: (state: RouterState) => string
  decode: (path: string) => RouterState | null
  isNotFound: (path: string) => boolean
  getBasePath: () => string
  getRedirectBase: (pathname: string) => string | null
  isRoot: (path: string) => boolean
}

/**
 * @public
 */
declare interface RouterNode {
  route: Route
  scope?: string
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
  children: RouteChildren
}

/**
 * Represents a "pane group" in the router.
 *
 * @see RouterPanes
 *
 *
 * @hidden
 * @beta
 */
export declare type RouterPaneGroup = RouterPaneSibling[]

/**
 * Represents the state of the `panes` inside the desk-tool router
 *
 * - The desk tool stores the state of the current panes inside of the router.
 * - The panes are stored in groups delimited in the URL by `;`.
 * - In each group, there can be one or more sibling (aka split) panes delimited
 *   by `|`.
 * - Each item pane can contain it's own parameters and payloads
 * - Per item pane in each group, if not specified separately, the ID, params,
 *   and payload will be inherited from the first item pane in the pane group
 *   (unless it's an `exclusiveParam`)
 *
 * E.g. `/desk/books;book-123|,view=preview` will parse to:
 *
 * ```js
 * [
 *   // first pane group
 *   [{id: 'book'}],
 *
 *   // second pane group
 *   [
 *     [
 *       // first pane item
 *       {id: 'book-123'},
 *       // second pane item
 *       {id: 'book-123', params: {view: 'preview'}},
 *     ],
 *   ],
 * ]
 * ```
 *
 * see [`packages/@sanity/desk-tool/src/utils/parsePanesSegment.ts`][0]
 *
 * [0]: https://github.com/sanity-io/sanity/blob/287d308442938c98cbec4608d159401631792d7a/packages/%40sanity/desk-tool/src/utils/parsePanesSegment.ts#L71-L88
 *
 *
 * @hidden
 * @beta
 */
export declare type RouterPanes = RouterPaneGroup[]

/**
 * Represents a "sibling pane" or "split pane" in the router.
 *
 * @see RouterPanes
 *
 *
 * @hidden
 * @beta
 */
export declare interface RouterPaneSibling {
  id: string
  params?: Record<string, string | undefined>
  payload?: unknown
}

/**
 * Passed as the second argument to the item of resolving pane children
 *
 * @see RouterPanes
 *
 * @internal
 */
export declare interface RouterPaneSiblingContext {
  id: string
  parent: PaneNode | null
  index: number
  splitIndex: number
  path: string[]
  params: Record<string, string | undefined>
  payload: unknown
  structureContext: StructureContext
  serializeOptions?: {
    path: (string | number)[]
    index?: number
    hint?: string
  }
}

/**
 * @public
 */
declare type RouterState = Record<string, unknown>

/**
 * @public
 */
declare interface RouteSegment {
  name: string
  type: 'dir' | 'param'
}

/**
 * @public
 */
declare interface RouteTransform<T> {
  toState: (value: string) => T
  toPath: (value: T) => string
}

/**
 * @public
 */
declare interface SanityFormConfig {
  /**
   * these have not been migrated over
   *
   *
   * @hidden
   * @beta
   */
  unstable?: {
    CustomMarkers?: FormBuilderCustomMarkersComponent
    Markers?: FormBuilderMarkersComponent
  }
  /**
   * @hidden
   * @beta */
  components?: {
    input?: ComponentType<InputProps>
    field?: ComponentType<FieldProps>
    item?: ComponentType<ItemProps>
    preview?: ComponentType<PreviewProps>
    block?: ComponentType<BlockProps>
    inlineBlock?: ComponentType<BlockProps>
    annotation?: ComponentType<BlockAnnotationProps>
  }
  file?: {
    /**
     * @hidden
     * @beta */
    assetSources?: AssetSource[] | AssetSourceResolver
    // TODO: this option needs more thought on composition and availability
    directUploads?: boolean
  }
  /**
   * @hidden
   * @beta */
  image?: {
    assetSources?: AssetSource[] | AssetSourceResolver
    // TODO: this option needs more thought on composition and availability
    directUploads?: boolean
  }
}

/**
 * @hidden
 * @beta */
declare interface SchemaPluginOptions {
  name?: string
  types?:
    | SchemaTypeDefinition[]
    | ComposableOption<
        SchemaTypeDefinition[],
        Omit<ConfigContext, 'schema' | 'currentUser' | 'getClient' | 'client'>
      >
  templates?: Template[] | TemplateResolver
}

/**
 * @internal
 */
declare interface SearchFieldDefinition {
  documentTypes: string[]
  fieldPath: string
  filterName: string
  id: string
  name: string
  title: string
  titlePath: string[]
  type: string
}

declare interface SearchFilterBaseDefinition<TOperators> {
  description?: string
  icon: ComponentType
  name: string
  operators: Operator<TOperators>[]
}

/**
 * @alpha
 */
declare type SearchFilterDefinition<TOperators = string> =
  | SearchFilterFieldDefinition<TOperators>
  | SearchFilterPinnedDefinition<TOperators>

declare interface SearchFilterFieldDefinition<TOperators = string>
  extends SearchFilterBaseDefinition<TOperators> {
  fieldType: IntrinsicTypeName
  type: 'field'
}

declare interface SearchFilterPinnedDefinition<TOperators = string>
  extends SearchFilterBaseDefinition<TOperators> {
  fieldPath?: string
  group?: string
  title: string
  type: 'pinned'
}

/**
 * @alpha
 */
declare interface SearchOperatorBase {
  buttonLabel?: string
  label: string
  icon?: ComponentType
  type: string
}

/**
 * @alpha
 */
declare type SearchOperatorButtonValue<TValue> = ComponentType<
  OperatorButtonValueComponentProps<TValue>
>

/** @internal */
declare interface SearchOperatorDefinition<TValue = any> extends SearchOperatorBase {
  buttonValueComponent?: SearchOperatorButtonValue<TValue>
  groqFilter: (params: SearchOperatorParams<TValue>) => string | null
  initialValue?: TValue
  inputComponent?: SearchOperatorInput<TValue>
  type: string
}

/**
 * @alpha
 */
declare type SearchOperatorInput<TValue> = ComponentType<OperatorInputComponentProps<TValue>>

/**
 * @alpha
 */
declare type SearchOperatorParams<TValue> = {fieldPath?: string; value?: TValue}

/**
 * @hidden
 * @beta */
declare type SelectionState = 'inactive' | 'rev' | 'range' | 'loading' | 'invalid'

/**
 * @hidden
 * @beta */
export declare interface Serializable<T> {
  serialize(options: SerializeOptions): T
}

/** @internal */
export declare type SerializablePaneNode = {
  serialize(context: RouterPaneSiblingContext): UnresolvedPaneNode
}

/** @internal */
export declare class SerializeError extends Error {
  readonly path: SerializePath
  helpId?: HELP_URL
  constructor(
    message: string,
    parentPath: SerializePath,
    pathSegment: string | number | undefined,
    hint?: string
  )
  withHelpUrl(id: HELP_URL): SerializeError
}

/**
 * @hidden
 * @beta */
export declare interface SerializeOptions {
  path: SerializePath
  index?: number
  hint?: string
}

/**
 * @hidden
 * @beta */
export declare type SerializePath = (string | number)[]

/** @internal */
export declare const shallowIntentChecker: IntentChecker

/**
 * @hidden
 * @beta */
declare interface SnapshotEvent {
  type: 'snapshot'
  document: SanityDocument
}

/** @internal */
export declare interface SortMenuItem extends MenuItem {
  params: {
    by: SortOrderingItem[]
  }
}

/** @public */
declare interface Source {
  type: 'source'
  name: string
  title: string
  projectId: string
  dataset: string
  schema: Schema
  templates: Template[]
  tools: Tool[]
  currentUser: CurrentUser | null
  authenticated: boolean

  /** @internal */
  auth: AuthStore

  getClient: (clientOptions: SourceClientOptions) => SanityClient

  document: {
    /**
     * @hidden
     * @beta */
    actions: (props: PartialContext<DocumentActionsContext>) => DocumentActionComponent[]

    /**
     * @hidden
     * @beta */
    badges: (props: PartialContext<DocumentActionsContext>) => DocumentBadgeComponent[]

    /**
     * @hidden
     * @beta */
    resolveProductionUrl: (
      context: PartialContext<ResolveProductionUrlContext>
    ) => Promise<string | undefined>

    /**
     * @hidden
     * @beta */
    resolveNewDocumentOptions: (context: NewDocumentCreationContext) => InitialValueTemplateItem[]

    /** @alpha */
    unstable_languageFilter: (
      props: PartialContext<DocumentLanguageFilterContext>
    ) => DocumentLanguageFilterComponent[]
  }
  form: {
    /**
     * @hidden
     * @beta */
    file: {
      assetSources: AssetSource[]
      directUploads: boolean
    }

    /**
     * @hidden
     * @beta */
    image: {
      assetSources: AssetSource[]
      directUploads: boolean
    }

    /**
     * @hidden
     * @beta */
    components?: {
      input?: ComponentType<Omit<InputProps, 'renderDefault'>>
      field?: ComponentType<Omit<FieldProps, 'renderDefault'>>
      item?: ComponentType<Omit<ItemProps, 'renderDefault'>>
      preview?: ComponentType<Omit<PreviewProps, 'renderDefault'>>
    }

    /**
     * these have not been migrated over and are not merged by the form builder
     *
     *
     * @hidden
     * @beta
     */
    unstable?: {
      CustomMarkers?: FormBuilderCustomMarkersComponent
      Markers?: FormBuilderMarkersComponent
    }
  }

  studio?: {
    /**
     * @hidden
     * @beta */
    components?: StudioComponents
  }

  /** @alpha */
  search: {
    filters: SearchFilterDefinition[]
    operators: SearchOperatorDefinition[]
  }

  /** @internal */
  __internal: {
    bifur: BifurClient
    staticInitialValueTemplateItems: InitialValueTemplateItem[]
    options: SourceOptions
  }
}

/** @public */
declare interface SourceClientOptions {
  apiVersion: string
}

/**
 * @hidden
 * @beta */
declare interface SourceOptions extends PluginOptions {
  title?: string

  /**
   * Project ID for this source
   */
  projectId: string

  /**
   * Dataset name for this source
   */
  dataset: string

  /**
   * API hostname used for requests. Generally used for custom CNAMEs, allowing businesses to use
   * their own domain for API requests. Must include protocol:
   * eg `https://sanityapi.mycompany.com`
   *
   * Note that (currently) the project ID will be prepended to the passed URL, so the above
   * example would end up as: `https://<projectId>.sanityapi.mycompany.com`
   */
  apiHost?: string

  /** @internal */
  auth?: AuthStore

  /**
   * @hidden
   * @beta */
  unstable_clientFactory?: (options: ClientConfig) => SanityClient
}

/**
 * @hidden
 * @beta */
declare interface StateTree<T> {
  value: T | undefined
  children?: {
    [key: string]: StateTree<T>
  }
}

/**
 * @hidden
 * @beta */
declare interface StringFieldProps extends BaseFieldProps {
  schemaType: StringSchemaType
  value: string | undefined
  inputProps: StringInputProps
}

/** @public */
declare type StringFormNode<S extends StringSchemaType = StringSchemaType> = BaseFormNode<string, S>

/**
 * @hidden
 * @beta */
declare interface StringInputProps<S extends StringSchemaType = StringSchemaType>
  extends BaseInputProps,
    StringFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @beta */
export declare interface StructureBuilder {
  /**
   * @internal
   */
  component: (spec?: ComponentInput | UserComponent) => ComponentBuilder
  defaultDocument: (options: {documentId?: string; schemaType: string}) => DocumentBuilder
  defaultInitialValueTemplateItems: () => InitialValueTemplateItemBuilder[]
  defaults: () => ListBuilder
  divider: () => Divider
  document: (spec?: PartialDocumentNode) => DocumentBuilder
  documentList: (spec?: DocumentListInput) => DocumentListBuilder
  documentListItem: (spec?: DocumentListItemInput) => DocumentListItemBuilder
  documentTypeList: (typeNameOrSpec: string | DocumentTypeListInput) => DocumentListBuilder
  documentTypeListItem: (typeName: string) => ListItemBuilder
  documentTypeListItems: () => ListItemBuilder[]
  documentWithInitialValueTemplate: (
    templateId: string,
    parameters?: Record<string, unknown>
  ) => DocumentBuilder
  editor: (spec?: EditorNode) => DocumentBuilder
  initialValueTemplateItem: (
    templateId: string,
    parameters?: Record<string, any>
  ) => InitialValueTemplateItemBuilder
  list: (spec?: ListInput) => ListBuilder
  listItem: (spec?: ListItemInput) => ListItemBuilder
  menuItem: (spec?: MenuItem) => MenuItemBuilder
  menuItemGroup: (spec?: MenuItemGroup) => MenuItemGroupBuilder
  menuItemsFromInitialValueTemplateItems: (templateItems: InitialValueTemplateItem[]) => MenuItem[]
  orderingMenuItem: (ordering: SortOrdering) => MenuItemBuilder
  orderingMenuItemsForType: (type: string) => MenuItemBuilder[]
  view: {
    form: (spec?: Partial<FormView>) => FormViewBuilder
    component: (
      componentOrSpec?: Partial<ComponentView> | React.ComponentType<any>
    ) => ComponentViewBuilder
  }
  context: StructureContext
}

/** @internal */
export declare interface StructureBuilderOptions {
  source: Source
  defaultDocumentNode?: DefaultDocumentNodeResolver
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface StructureContext extends Source {
  resolveDocumentNode: (options: {documentId?: string; schemaType: string}) => DocumentBuilder
  getStructureBuilder: () => StructureBuilder
}

/**
 * @hidden
 * @beta */
export declare interface StructureNode {
  id: string
  title?: string
  type?: string
}

/**
 * @hidden
 * @beta */
export declare type StructureResolver = (
  S: StructureBuilder,
  context: StructureResolverContext
) => unknown

/** @public */
export declare interface StructureResolverContext extends ConfigContext {
  /**
   * This can be replaced by a different API in the future.
   * It is provided as-is to support common structure patterns found in V2 in V3.
   * @alpha
   * */
  documentStore: DocumentStore
}

/**
 * @hidden
 * @beta */
// Config
declare interface StudioComponents {
  layout: React_2.ComponentType<Omit<LayoutProps, 'renderDefault'>>
  logo: React_2.ComponentType<Omit<LogoProps, 'renderDefault'>>
  navbar: React_2.ComponentType<Omit<NavbarProps, 'renderDefault'>>
  toolMenu: React_2.ComponentType<Omit<ToolMenuProps, 'renderDefault'>>
}

/**
 * @hidden
 * @beta */
declare interface StudioComponentsPluginOptions {
  layout?: React_2.ComponentType<LayoutProps>
  logo?: React_2.ComponentType<LogoProps>
  navbar?: React_2.ComponentType<NavbarProps>
  toolMenu?: React_2.ComponentType<ToolMenuProps>
}

/** @public */
declare interface StudioTheme extends RootTheme {
  /** @internal */
  __dark?: boolean
  /** @internal */
  __legacy?: boolean
}

/** @public */
declare interface Template<Params = any, Value = any> {
  id: string
  title: string
  description?: string
  schemaType: string
  icon?: SchemaType['icon']
  value: InitialValueProperty<Params, Value>
  parameters?: TemplateParameter[]
}

/** @public */
declare type TemplateArrayFieldDefinition = TemplateFieldDefinition & {
  type: 'array'
  of: (TemplateReferenceTarget | TypeTarget)[]
}

/** @public */
declare interface TemplateFieldDefinition {
  name: string
  type: string
  title?: string
  description?: string
  options?: {[key: string]: any}
}

/** @public */
declare type TemplateParameter = TemplateFieldDefinition | TemplateArrayFieldDefinition

/** @public */
declare interface TemplateReferenceTarget {
  type: 'reference'
  to: TypeTarget | TypeTarget[]
}

/** @public */
declare type TemplateResolver = ComposableOption<Template[], ConfigContext>

/**
 * @hidden
 * @beta */
declare type TemplateResponse = {
  templateId: string
  title?: string
  subtitle?: string
  description?: string
  parameters?: {[key: string]: any}
  icon?: React.ElementType | React.ReactElement
  /**
   * @experimental
   */
  initialDocumentId?: string
}

/**
 * Timeline maintains information about the history of a document:
 * Grouping raw translog entries into sensible groups, replaying and
 * reconstructing different versions and abstract other details.
 *
 * Note that this class by itself is not capable of _fetching_ information,
 * but will only organize and structure the incoming translog entries.
 *
 *
 * @hidden
 * @beta
 */
declare class Timeline {
  reachedEarliestEntry = false

  publishedId: string
  draftId: string
  private _transactions = new TwoEndedArray<Transaction>()
  private _chunks = new TwoEndedArray<Chunk>()

  // These two properties are here to handle the case
  private _possiblePendingTransactions = new Map<
    string,
    {
      transaction: Transaction
      idx: number
    }
  >()
  private _recreateTransactionsFrom?: number
  private _trace?: TraceEvent[]

  constructor(opts: TimelineOptions) {
    this.publishedId = opts.publishedId
    this.draftId = `drafts.${opts.publishedId}`

    if (opts.enableTrace) {
      this._trace = []
      this._trace.push({
        type: 'initial',
        publishedId: opts.publishedId,
      })
      ;(window as any).__sanityTimelineTrace = this._trace
    }
  }

  get chunkCount(): number {
    return this._chunks.length
  }

  /** Maps over the chunk from newest to oldest. */
  mapChunks<T>(mapper: (chunk: Chunk, idx: number) => T): T[] {
    const result: T[] = []

    const firstIdx = this._chunks.firstIdx
    const lastIdx = this._chunks.lastIdx

    for (let idx = lastIdx; idx >= firstIdx; idx--) {
      result.push(mapper(this._chunks.get(idx), idx))
    }

    return result
  }

  reset(): void {
    this._transactions = new TwoEndedArray()
    this._chunks = new TwoEndedArray()
    this._possiblePendingTransactions = new Map()
    this._recreateTransactionsFrom = undefined
    this.reachedEarliestEntry = false
  }

  /**
   * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
   * come in correct order for their respective version, but has no ordering requirements
   * across draft/published.
   *
   * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
   * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
   * the mutation for the draft is out of order.
   */
  addRemoteMutation(entry: DocumentRemoteMutationVersionEvent): void {
    if (this._trace) this._trace.push({type: 'addRemoteMutation', event: entry})

    const pending = this._possiblePendingTransactions.get(entry.transactionId)

    const transaction: Transaction = pending
      ? pending.transaction
      : {
          index: 0,
          id: entry.transactionId,
          timestamp: entry.timestamp.toISOString(),
          author: entry.author,
        }

    if (entry.version === 'draft') {
      transaction.draftEffect = entry.effects as any
    } else {
      transaction.publishedEffect = entry.effects as any
    }

    if (pending) {
      this._possiblePendingTransactions.delete(entry.transactionId)
      this._invalidateTransactionFrom(pending.idx)
    } else {
      this._transactions.addToEnd(transaction)
      this._possiblePendingTransactions.set(entry.transactionId, {
        transaction,
        idx: this._transactions.lastIdx,
      })
    }
  }

  addTranslogEntry(event: TransactionLogEventWithEffects): void {
    if (this._trace) this._trace.push({type: 'addTranslogEntry', event})

    this._transactions.addToBeginning({
      index: 0,
      id: event.id,
      author: event.author,
      timestamp: event.timestamp,
      draftEffect: event.effects[this.draftId],
      publishedEffect: event.effects[this.publishedId],
    })
  }

  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry(): void {
    if (this._trace) this._trace.push({type: 'didReachEarliestEntry'})

    this.reachedEarliestEntry = true
  }

  /**
   * updateChunks synchronizes the chunks to match the current state
   * of the transactions array. After calling this method you need
   * to invalidate all Chunks.
   */
  updateChunks(): void {
    if (this._trace) this._trace.push({type: 'updateChunks'})

    this._removeInvalidatedChunks()
    this._addChunksFromTransactions()
    this._createInitialChunk()
  }

  private _removeInvalidatedChunks() {
    if (this._recreateTransactionsFrom) {
      while (this._chunks.length > 0) {
        const chunk = this._chunks.last
        if (this._recreateTransactionsFrom < chunk.end) {
          this._chunks.removeFromEnd()
        } else {
          break
        }
      }
      this._recreateTransactionsFrom = undefined
    }
  }

  private _addChunksFromTransactions() {
    const firstIdx = this._transactions.firstIdx
    const lastIdx = this._transactions.lastIdx

    // Add transactions at the end:
    const nextTransactionToChunk = this._chunks.length > 0 ? this._chunks.last.end : firstIdx
    for (let idx = nextTransactionToChunk; idx <= lastIdx; idx++) {
      const transaction = this._transactions.get(idx)
      this._chunks.mergeAtEnd(chunkFromTransaction(transaction), mergeChunk)
    }

    // Add transactions at the beginning:
    if (this._chunks.length == 0) return

    const firstTransactionChunked = this._chunks.first.start

    for (let idx = firstTransactionChunked - 1; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx)
      this._chunks.mergeAtBeginning(chunkFromTransaction(transaction), mergeChunk)
    }
  }

  private _invalidateTransactionFrom(idx: number) {
    if (this._recreateTransactionsFrom === undefined || idx < this._recreateTransactionsFrom) {
      this._recreateTransactionsFrom = idx
    }
  }

  private _createInitialChunk() {
    if (this.reachedEarliestEntry) {
      if (this._chunks.first?.type === 'initial') return

      const firstTx = this._transactions.first
      if (!firstTx) return
      const initialChunk = chunkFromTransaction(firstTx)
      initialChunk.type = 'initial'
      initialChunk.id = '@initial'
      initialChunk.end = initialChunk.start
      this._chunks.addToBeginning(initialChunk)
    }
  }

  /**
   * Resolves a time reference.
   *
   * Note that the chunk returned is only valid if the timeline stays constant.
   * Once the timeline is updated, you must re-parse all references.
   */
  parseTimeId(id: string): ParsedTimeRef {
    if (this._chunks.length === 0) {
      return this.reachedEarliestEntry ? 'invalid' : 'loading'
    }

    // NOTE:
    // This was refactored from
    // ```
    // const [timestampStr, chunkId] = id.split('/', 3)
    // ```
    // in order to avoid issues with `@microsoft/api-extractor`.
    const idSegments = id.split('/', 3)
    const timestampStr = idSegments.shift()
    const chunkId = idSegments.shift()
    const timestamp = Number(timestampStr)

    for (let idx = this._chunks.lastIdx; idx >= this._chunks.firstIdx; idx--) {
      const chunk = this._chunks.get(idx)
      if (chunk.id === chunkId) {
        return chunk
      }

      if (Date.parse(chunk.endTimestamp) + 60 * 60 * 1000 < timestamp) {
        // The chunk ended _before_ the timestamp we're asking for. This means that there
        // is no point in looking further and the chunk is invalid.

        // We add 1 hour to allow some slack since transactions are not guaranteed to be in order.
        return 'invalid'
      }
    }

    return this.reachedEarliestEntry ? 'invalid' : 'loading'
  }

  findLastPublishedBefore(chunk: Chunk | null): ParsedTimeRef {
    for (
      let chunkIdx = chunk ? chunk.index - 1 : this._chunks.lastIdx;
      chunkIdx >= this._chunks.firstIdx;
      chunkIdx--
    ) {
      const currentChunk = this._chunks.get(chunkIdx)
      if (currentChunk.type === 'publish' || currentChunk.type === 'initial') {
        return currentChunk
      }
    }

    if (!this.reachedEarliestEntry) return 'loading'

    return this._chunks.first
  }

  isLatestChunk(chunk: Chunk): boolean {
    return chunk === this._chunks.last
  }

  // eslint-disable-next-line class-methods-use-this
  createTimeId(chunk: Chunk): string {
    return `${chunk.endTimestamp.valueOf()}/${chunk.id}`
  }

  lastChunk(): Chunk {
    return this._chunks.last
  }

  transactionByIndex(idx: number): Transaction | null {
    if (!this._transactions.has(idx)) return null
    return this._transactions.get(idx)
  }

  chunkByTransactionIndex(idx: number, startChunkIdx = 0): Chunk {
    let chunkIdx = startChunkIdx
    for (;;) {
      const chunk = this._chunks.get(chunkIdx)
      if (!chunk) throw new Error('transaction does not belong in any chunk')

      if (idx >= chunk.end) {
        chunkIdx++
      } else if (idx < chunk.start) {
        chunkIdx--
      } else {
        return chunk
      }
    }
  }

  replayBackwardsBetween(
    firstIdx: number,
    lastIdx: number,
    doc: CombinedDocument
  ): CombinedDocument {
    let draft = doc.draft
    let published = doc.published

    for (let idx = lastIdx; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx)

      if (transaction.draftEffect) {
        draft = applyPatch(draft, transaction.draftEffect.revert)
      }

      if (transaction.publishedEffect) {
        published = applyPatch(published, transaction.publishedEffect.revert)
      }
    }

    return {draft, published}
  }

  replayBackwardsUntil(firstIdx: number, doc: CombinedDocument): CombinedDocument {
    return this.replayBackwardsBetween(firstIdx, this._transactions.lastIdx, doc)
  }

  calculateDiff(
    initialDoc: CombinedDocument,
    finalDoc: CombinedDocument,
    firstIdx: number,
    lastIdx: number
  ): Diff<Annotation> {
    let draftValue = incremental.wrap<Meta>(initialDoc.draft, null)
    let publishedValue = incremental.wrap<Meta>(initialDoc.published, null)

    const initialValue = getValue(draftValue, publishedValue)
    const initialAttributes = getAttrs(initialDoc)
    let firstChunk: Chunk | null = null

    // Loop over all of the chunks:
    for (let chunkIdx = firstIdx; chunkIdx <= lastIdx; chunkIdx++) {
      const chunk = this._chunks.get(chunkIdx)
      if (!firstChunk) firstChunk = chunk

      for (let idx = chunk.start; idx < chunk.end; idx++) {
        const transaction = this._transactions.get(idx)

        const meta = {
          chunk,
          transactionIndex: idx,
        }

        const preDraftValue = draftValue
        const prePublishedValue = publishedValue

        if (transaction.draftEffect) {
          draftValue = incremental.applyPatch(draftValue, transaction.draftEffect.apply, meta)
        }

        if (transaction.publishedEffect) {
          publishedValue = incremental.applyPatch(
            publishedValue,
            transaction.publishedEffect.apply,
            meta
          )
        }

        const didHaveDriaft = incremental.getType(preDraftValue) !== 'null'
        const haveDraft = incremental.getType(draftValue) !== 'null'
        const havePublished = incremental.getType(publishedValue) !== 'null'

        if (havePublished && !haveDraft) {
          publishedValue = incremental.rebaseValue(preDraftValue, publishedValue)
        }

        if (haveDraft && !didHaveDriaft) {
          draftValue = incremental.rebaseValue(prePublishedValue, draftValue)
        }
      }
    }

    const finalValue = incremental.getType(draftValue) === 'null' ? publishedValue : draftValue
    const finalAttributes = getAttrs(finalDoc)

    return diffValue(this, firstChunk, initialValue, initialAttributes, finalValue, finalAttributes)
  }
}

/**
 * The controller is responsible for fetching information
 * about a document and maintaining a Timeline.
 *
 *
 * @hidden
 * @beta
 */
declare class TimelineController {
  timeline: Timeline
  client: SanityClient
  handler: TimelineControllerOptions['handler']

  version = 0

  /**
   * The selection state represents the  different states of the current selection:
   * - inactive: No selection is active.
   * - rev: A selection is active for a single revision.
   * - range: A selection is active for a range and we have all the data needed to render it.
   * - loading: A selection is active, but we don't have the entries yet.
   * - invalid: The selection picked is invalid.
   */
  selectionState: SelectionState = 'inactive'

  constructor(options: TimelineControllerOptions) {
    this.timeline = options.timeline
    this.client = options.client
    this.handler = options.handler
    this._aligner = new Aligner(this.timeline)

    this.markChange()
  }

  private _aligner: Aligner

  private _fetchMore = false
  private _fetchAtLeast = 0
  private _isRunning = false
  private _isSuspended = false
  private _didErr = false

  private _since: string | null = null
  private _sinceTime: ParsedTimeRef | null = null
  private _rev: string | null = null
  private _revTime: ParsedTimeRef | null = null

  private _reconstruction?: Reconstruction

  clearRange(): void {
    this.setRange(null, null)
  }

  setRange(since: string | null, rev: string | null): void {
    if (rev !== this._rev) this.setRevTime(rev)
    if (since !== this._since) this.setSinceTime(since)

    let _fetchAtLeast = 10

    if (this._sinceTime === 'loading' || this._revTime === 'loading' || !this._aligner.isAligned) {
      this.selectionState = 'loading'
    } else if (this._sinceTime === 'invalid' || this._revTime === 'invalid') {
      this.selectionState = 'invalid'
    } else if (this._sinceTime) {
      this.selectionState = 'range'

      const targetRev = this._revTime || this.timeline.lastChunk()

      if (this._sinceTime.index > targetRev.index) {
        this._revTime = 'invalid'
        this.selectionState = 'invalid'
      } else {
        this.setReconstruction(this._sinceTime, targetRev)
      }
    } else if (this._revTime) {
      this.selectionState = 'rev'
      this.setReconstruction(null, this._revTime)
    } else {
      this.selectionState = 'inactive'
      _fetchAtLeast = 0
    }

    this._fetchAtLeast = _fetchAtLeast

    this.start()
  }

  setLoadMore(flag: boolean): void {
    this._fetchMore = flag
    this.start()
  }

  get sinceTime(): Chunk | null {
    return this._sinceTime && typeof this._sinceTime === 'object' ? this._sinceTime : null
  }

  get revTime(): Chunk | null {
    return this._revTime && typeof this._revTime === 'object' ? this._revTime : null
  }

  get realRevChunk(): Chunk {
    return this.revTime || this.timeline.lastChunk()
  }

  /** Returns true when there's an older revision we want to render. */
  onOlderRevision(): boolean {
    return Boolean(this._rev) && (this.selectionState === 'range' || this.selectionState === 'rev')
  }

  findRangeForNewRev(rev: Chunk): [string | null, string | null] {
    const revTimeId = this.timeline.isLatestChunk(rev) ? null : this.timeline.createTimeId(rev)

    if (!this._since) {
      return [null, revTimeId]
    }

    const sinceChunk = this.sinceTime
    if (sinceChunk && sinceChunk.index < rev.index) {
      return [this._since, revTimeId]
    }

    return ['@lastPublished', revTimeId]
  }

  findRangeForNewSince(since: Chunk): [string, string | null] {
    const revChunk = this.revTime

    // If the the `since` timestamp is earlier than the `rev`, then we can
    // accept it. Otherwise we'll move the current revision to the current draft.

    if (revChunk && since.index < revChunk.index) {
      return [this.timeline.createTimeId(since), this._rev]
    }

    return [this.timeline.createTimeId(since), null]
  }

  setRevTime(rev: string | null): void {
    this._rev = rev
    this._revTime = rev ? this.timeline.parseTimeId(rev) : null

    if (this._since === '@lastPublished') {
      // Make sure we invalidate it since this depends on the _rev.
      this._since = null
      this._sinceTime = null
    }
  }

  setSinceTime(since: string | null): void {
    if (since === '@lastPublished') {
      if (typeof this._revTime === 'string') {
        this._sinceTime = this._revTime
      } else {
        this._sinceTime = this.timeline.findLastPublishedBefore(this._revTime)
      }
    } else {
      this._sinceTime = since ? this.timeline.parseTimeId(since) : null
    }

    this._since = since
  }

  sinceAttributes(): Record<string, unknown> | null {
    return this._sinceTime && this._reconstruction ? this._reconstruction.startAttributes() : null
  }

  displayed(): Record<string, unknown> | null {
    return this._revTime && this._reconstruction ? this._reconstruction.endAttributes() : null
  }

  setReconstruction(since: Chunk | null, rev: Chunk): void {
    if (this._reconstruction && this._reconstruction.same(since, rev)) return
    this._reconstruction = new Reconstruction(
      this.timeline,
      this._aligner.currentDocument,
      since,
      rev
    )
  }

  currentDiff(): Diff<Annotation> | null {
    return this._reconstruction ? this._reconstruction.diff() : null
  }

  currentObjectDiff(): ObjectDiff<Annotation> | null {
    const diff = this.currentDiff()
    if (diff) {
      if (diff.type === 'null') return null
      if (diff.type !== 'object') throw new Error(`ObjectDiff expected, got ${diff.type}`)
    }

    return diff as ObjectDiff<Annotation>
  }

  handleRemoteMutation(ev: RemoteSnapshotVersionEvent): void {
    this._aligner.appendRemoteSnapshotEvent(ev)
    this.markChange()

    // Make sure we fetch history as soon as possible.
    if (this._aligner.acceptsHistory) this.start()
  }

  start(): void {
    if (this._didErr) return

    if (!this._isRunning) {
      this._isRunning = true

      this.tick().then(() => {
        this._isRunning = false
      })
    }
  }

  resume(): void {
    this._isSuspended = false
  }

  suspend(): void {
    this._isSuspended = true
  }

  private async tick() {
    const shouldFetchMore =
      this._aligner.acceptsHistory &&
      !this.timeline.reachedEarliestEntry &&
      (this.selectionState === 'loading' ||
        this._fetchMore ||
        this.timeline.chunkCount <= this._fetchAtLeast) &&
      !this._isSuspended

    if (!shouldFetchMore) {
      return
    }

    try {
      await this.fetchMoreTransactions()
    } catch (err) {
      this._didErr = true
      this.handler?.(err, this)
      return
    }

    await this.tick()
  }

  private async fetchMoreTransactions() {
    const publishedId = this.timeline.publishedId
    const draftId = this.timeline.draftId
    const clientConfig = this.client.config()
    const limit = TRANSLOG_ENTRY_LIMIT

    let queryParams = `tag=sanity.studio.desk.history&effectFormat=mendoza&excludeContent=true&excludeMutations=true&includeIdentifiedDocumentsOnly=true&reverse=true&limit=${limit}`
    let tid = this._aligner.earliestTransactionId
    if (tid) {
      queryParams += `&toTransaction=${tid}`
    }

    const transactionsUrl = this.client.getUrl(
      `/data/history/${clientConfig.dataset}/transactions/${publishedId},${draftId}?${queryParams}`
    )
    const stream = await getJsonStream(transactionsUrl, clientConfig.token)
    const reader = stream.getReader()
    let count = 0

    for (;;) {
      // eslint-disable-next-line no-await-in-loop
      const result = await reader.read()
      if (result.done) break

      if ('error' in result.value) {
        throw new Error(result.value.error.description || result.value.error.type)
      }

      count++

      if (result.value.id === tid) {
        // toTransaction is inclusive so we must ignore it when we fetch the next page
        continue
      }

      // For some reason, the aligner is now interested in a different set of entries.
      // This can happen if a new snapshot comes in as we're streaming the translog.
      // In this case it's safe to abort, and the run-loop will re-schedule it correctly.
      if (this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory) {
        return
      }

      this._aligner.prependHistoryEvent(result.value)
      tid = this._aligner.earliestTransactionId
    }

    // Same consistency checking here:
    if (this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory) {
      return
    }

    if (count < limit) {
      this._aligner.didReachEarliestEntry()
    }

    this.markChange()
  }

  private markChange() {
    this.timeline.updateChunks()

    this.setRevTime(this._rev)
    this.setSinceTime(this._rev)

    this.version++
    this.handler?.(null, this)
  }
}

/**
 * @hidden
 * @beta */
declare type TimelineControllerOptions = {
  timeline: Timeline
  client: SanityClient
  documentId: string
  documentType: string
  handler?: (err: Error | null, controller: TimelineController) => void
}

/** @internal */
declare type TimelineMode = 'since' | 'rev' | 'closed'

/**
 * @hidden
 * @beta */
declare interface TimelineOptions {
  publishedId: string
  enableTrace?: boolean
}

/** @internal */
declare interface TimelineState {
  chunks: Chunk[]
  diff: ObjectDiff<Annotation, Record<string, any>> | null
  hasMoreChunks: boolean
  isLoading: boolean
  onOlderRevision: boolean
  realRevChunk: Chunk | null
  revTime: Chunk | null
  selectionState: SelectionState
  sinceAttributes: Record<string, unknown> | null
  sinceTime: Chunk | null
  timelineDisplayed: Record<string, unknown> | null
  timelineReady: boolean
}

/** @internal */
declare interface TimelineStore {
  findRangeForRev: TimelineController['findRangeForNewRev']
  findRangeForSince: TimelineController['findRangeForNewSince']
  loadMore: () => void
  getSnapshot: () => TimelineState
  subscribe: (callback: () => void) => () => void
}

/**
 * @public
 */
declare interface Tool<Options = any> {
  component: ComponentType<{tool: Tool<Options>}>
  icon?: ComponentType
  name: string
  options?: Options
  router?: Router
  title: string
  getIntentState?: (
    intent: string,
    params: Record<string, string>,
    routerState: RouterState | undefined,
    payload: unknown
  ) => unknown
  canHandleIntent?: (intent: string, params: Record<string, unknown>, payload: unknown) => boolean
}

/**
 * @hidden
 * @beta */
declare interface ToolMenuProps {
  activeToolName?: string
  closeSidebar: () => void
  context: 'sidebar' | 'topbar'
  isSidebarOpen: boolean
  tools: Tool[]
  renderDefault: (props: ToolMenuProps) => React_2.ReactElement
}

declare type TraceEvent =
  | {
      type: 'initial'
      publishedId: string
    }
  | {type: 'addRemoteMutation'; event: DocumentRemoteMutationVersionEvent}
  | {type: 'addTranslogEntry'; event: TransactionLogEventWithEffects}
  | {type: 'didReachEarliestEntry'}
  | {type: 'updateChunks'}

/**
 * @hidden
 * @beta */
declare interface Transaction {
  index: number
  id: string
  author: string
  timestamp: string
  draftEffect?: MendozaEffectPair
  publishedEffect?: MendozaEffectPair
}

declare interface TransactionSyncLockState {
  enabled: boolean
}

/**
 * This error may happen if the _type of the value is different from the declared schema type
 * It represents a case where we encounter field value that is structurally compatible with the field's defined schema type
 * (e.g. they are both json objects), but the _type name is different from what the schema type expects
 *
 * Note on compatibility: The schema of a field may be defined as an object with fields (a, b, c), but the value is an object with (d, e, f)
 * These are still structurally compatible because (d, e, f) will be considered undeclared members
 *
 * @public
 */
declare type TypeAnnotationMismatchError = {
  type: 'TYPE_ANNOTATION_MISMATCH'
  expectedSchemaType: SchemaType
  resolvedValueType: string
}

/** @public */
declare interface TypeTarget {
  type: string
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type UndeclaredMembersError = {type: 'UNDECLARED_MEMBERS'; schemaType: ArraySchemaType}

/** @internal */
export declare type UnresolvedPaneNode =
  | PaneNodeResolver
  | SerializablePaneNode
  | Observable<UnresolvedPaneNode>
  | PromiseLike<UnresolvedPaneNode>
  | PaneNode

/**
 * @hidden
 * @beta */
export declare interface UnserializedListItem {
  id: string
  title: string
  icon?: React.ComponentType | React.ReactNode
  child?: UnserializedListItemChild
  displayOptions?: ListItemDisplayOptions
  schemaType?: SchemaType | string
}

/**
 * @hidden
 * @beta */
export declare type UnserializedListItemChild =
  | Collection
  | CollectionBuilder
  | ChildResolver
  | Observable<ItemChild>

/**
 *
 * @hidden
 * @beta
 */
declare type Uploader<S extends SchemaType = SchemaType> = {
  type: string
  accepts: string
  upload: (
    client: SanityClient,
    file: File,
    type: S,
    options?: UploadOptions
  ) => Observable<UploadProgressEvent>
  priority: number
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploaderResolver<S extends SchemaType = SchemaType> = (
  type: S,
  file: FileLike
) => Uploader<S> | null

/**
 * @hidden
 * @beta */
declare interface UploadEvent {
  file: File
  schemaType: SchemaType
  uploader: Uploader
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadOptions = {
  metadata?: AssetMetadataType[]
  storeOriginalFilename?: boolean
  label?: string
  title?: string
  description?: string
  creditLine?: string
  source?: AssetSourceSpec
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadProgressEvent = {
  type: 'uploadProgress'
  patches: FormPatch[] | null
}

/** @internal */
export declare function useDocumentPane(): DocumentPaneContextValue

/**
 *
 * @hidden
 * @beta
 */
export declare function usePaneRouter(): PaneRouterContextValue

/**
 * @hidden
 * @beta */
export declare type UserComponent = React.ComponentType<{
  child?: ComponentBuilder
  childItemId?: string
  id: string
  isActive?: boolean
  isSelected?: boolean
  itemId: string
  options?: Record<string, unknown>
  paneKey: string
  urlParams: Record<string, string | undefined> | undefined
}>

/**
 * @hidden
 * @beta */
export declare type UserViewComponent<TOptions = Record<string, any>> = React.ComponentType<{
  document: {
    draft: SanityDocument | null
    displayed: Partial<SanityDocument>
    historical: Partial<SanityDocument> | null
    published: SanityDocument | null
  }
  documentId: string
  options: TOptions
  schemaType: SchemaType
}>

/**
 * @hidden
 * @beta */
declare interface ValidationStatus {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

declare type VersionState = {
  id: string
  hasAttrs: boolean
  attrs: Record<string, unknown> | null
  rev: string | null
  events: Array<DocumentRemoteMutationVersionEvent>
  aligned: boolean
}

/**
 * @hidden
 * @beta */
export declare type View = FormView | ComponentView

/**
 * @hidden
 * @beta */
export declare type ViewBuilder = ComponentViewBuilder | FormViewBuilder

/**
 * @hidden
 * @beta */
declare type WithVersion<T> = T & {version: 'published' | 'draft'}

/** @internal */
declare interface WorkspaceSummary {
  type: 'workspace-summary'
  name: string
  title: string
  icon: React_2.ReactNode
  subtitle?: string
  basePath: string
  auth: AuthStore
  projectId: string
  dataset: string
  theme: StudioTheme
  schema: Schema
  /**
   * @internal
   * @deprecated not actually deprecated but don't use or you'll be fired
   */
  __internal: {
    sources: Array<{
      name: string
      projectId: string
      dataset: string
      title: string
      auth: AuthStore
      schema: Schema
      source: Observable<Source>
    }>
  }
}

export {}
