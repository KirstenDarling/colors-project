/// <reference types="react" />

import {ComponentType} from 'react'
import {FunctionComponent} from 'react'
import {default as React_2} from 'react'

/**
 * @public
 *
 * @param props - Props to pass to the anchor element.
 *  {@link IntentLinkProps}
 * @param ref - A ref to the anchor element.
 *
 * @returns The created anchor element.
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *  return <IntentLink intent="edit" params={{id: 'abc123'}}>Edit</IntentLink>
 * }
 * ```
 */
export declare const IntentLink: React_2.ForwardRefExoticComponent<
  Omit<IntentLinkProps & React_2.HTMLProps<HTMLAnchorElement>, 'ref'> &
    React_2.RefAttributes<HTMLAnchorElement>
>

/**
 * @public
 */
export declare interface IntentLinkProps {
  /**
   * The name of the intent to link to.
   */
  intent: string
  /**
   * The parameters to include in the intent.
   * {@link IntentParameters}
   */
  params?: IntentParameters
  /**
   * Whether to replace the current URL in the browser history instead of adding a new entry.
   */
  replace?: boolean
}

/**
 * @public
 */
export declare type IntentParameters =
  | Record<string, unknown>
  | [Record<string, unknown>, Record<string, unknown>]

/**
 * A component that creates an HTML anchor element.
 *
 * @public
 *
 * @param props - Props to pass to the anchor element.
 *  {@link LinkProps}
 * @param ref - A ref to the anchor element.
 *
 * @returns The created anchor element.
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   return (
 *    <Link href="https://www.sanity.io" target="_blank" replace>
 *      Go to Sanity
 *    </Link>
 *   )
 * }
 * ```
 */
export declare const Link: React_2.ForwardRefExoticComponent<
  Omit<LinkProps & React_2.HTMLProps<HTMLAnchorElement>, 'ref'> &
    React_2.RefAttributes<HTMLAnchorElement>
>

/**
 * The props for the `Link` component that creates an HTML anchor element.
 *
 * @public
 */
export declare interface LinkProps {
  /**
   * Whether to replace the current URL in the browser history instead of adding a new entry.
   */
  replace?: boolean
}

/** @internal */
export declare interface MatchResult {
  nodes: RouterNode[]
  missing: string[]
  remaining: string[]
}

/**
 * @public
 */
export declare type NavigateOptions = {
  replace?: boolean
}

/**
 * @public
 */
export declare interface Route {
  raw: string
  segments: RouteSegment[]
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
}

/**
 * @public
 */
export declare const route: {
  create: (
    routeOrOpts: RouteNodeOptions | string,
    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,
    children?: Router | RouteChildren
  ) => Router
  intents: (base: string) => Router
  scope: (scopeName: string, ...rest: any[]) => Router
}

/**
 * @public
 */
export declare type RouteChildren =
  | RouterNode[]
  | ((state: RouterState) => Router | RouterNode | RouterNode[] | undefined | false)

/**
 * @public
 */
export declare type RouteNodeOptions = {
  path?: string
  children?: RouteChildren
  transform?: {
    [key: string]: RouteTransform<any>
  }
  scope?: string
}

/**
 * @public
 */
export declare interface Router extends RouterNode {
  _isRoute: boolean
  encode: (state: RouterState) => string
  decode: (path: string) => RouterState | null
  isNotFound: (path: string) => boolean
  getBasePath: () => string
  getRedirectBase: (pathname: string) => string | null
  isRoot: (path: string) => boolean
}

/**
 * @internal
 */
export declare const RouterContext: React_2.Context<RouterContextValue | null>

/**
 * @public
 */
export declare type RouterContextValue = {
  resolvePathFromState: (nextState: RouterState) => string
  resolveIntentLink: (intentName: string, params?: IntentParameters) => string
  navigateUrl: (opts: {path: string; replace?: boolean}) => void
  navigate: (nextState: RouterState, options?: NavigateOptions) => void
  navigateIntent: (intentName: string, params?: IntentParameters, options?: NavigateOptions) => void
  state: RouterState
}

/**
 * @public
 */
export declare interface RouterNode {
  route: Route
  scope?: string
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
  children: RouteChildren
}

/**
 * @example
 * ```tsx
 * import {
 *   NavigateOptions,
 *   route,
 *   RouterProvider,
 *   RouterState
 * } from 'sanity'
 * import {useCallback, useMemo} from 'react'
 *
 * function Root() {
 *   const router = useMemo(() => route.create('/'), [])
 *
 *   const [state, setState] = useState<RouterState>({})
 *
 *   const handleNavigate = useCallback((
 *     path: string,
 *     options?: NavigateOptions
 *   ) => {
 *     console.log('navigate', path, options)
 *
 *     setState(router.decode(path))
 *   }, [router])
 *
 *   return (
 *     <RouterProvider
 *       onNavigate={handleNavigate}
 *       router={router}
 *       state={state}
 *     >
 *       <div>This is a routed application</div>
 *     </RouterProvider>
 *   )
 * }
 * ```
 *
 * @public
 */
export declare function RouterProvider(props: RouterProviderProps): React_2.ReactElement

/**
 * @public
 */
export declare interface RouterProviderProps {
  onNavigate: (opts: {path: string; replace?: boolean}) => void
  router: Router
  state: RouterState
  children: React_2.ReactNode
}

/**
 * @public
 */
export declare type RouterState = Record<string, unknown>

/**
 * @public
 */
export declare function RouteScope(props: RouteScopeProps): React_2.ReactElement

/**
 * @public
 */
export declare interface RouteScopeProps {
  scope: string
  children: React_2.ReactNode
}

/**
 * @public
 */
export declare interface RouteSegment {
  name: string
  type: 'dir' | 'param'
}

/**
 * @public
 */
export declare interface RouteTransform<T> {
  toState: (value: string) => T
  toPath: (value: T) => string
}

/**
 * @public
 */
export declare const StateLink: React_2.ForwardRefExoticComponent<
  Omit<StateLinkProps & Omit<React_2.HTMLProps<HTMLAnchorElement>, 'href'>, 'ref'> &
    React_2.RefAttributes<HTMLAnchorElement>
>

/**
 * @public
 */
export declare interface StateLinkProps {
  replace?: boolean
  state?: Record<string, unknown>
  toIndex?: boolean
}

/**
 *
 * @example
 * ```tsx
 * import {useIntentLink} from 'sanity'
 *
 * const {onClick, href} = useIntentLink({
 *   intent: 'edit',
 *   params: {id: 'foo'}
 * })
 *
 * <a href={href} onClick={onClick}>Link to "foo" editor</a>
 * ```
 *
 * @public
 */
export declare function useIntentLink(props: {
  intent: string
  onClick?: React.MouseEventHandler<HTMLElement>
  params?: IntentParameters
  replace?: boolean
  target?: string
}): {
  onClick: React.MouseEventHandler<HTMLElement>
  href: string
}

/**
 * @public
 */
export declare function useLink(props: {
  href?: string
  onClick?: React.MouseEventHandler<HTMLElement>
  replace?: boolean
  target?: string
}): {
  onClick: React.MouseEventHandler<HTMLElement>
}

/**
 * @public
 */
export declare function useRouter(): RouterContextValue

/**
 * @public
 */
export declare function useRouterState<R = RouterState>(
  selector: (routerState: RouterState) => R
): R

/**
 * @public
 */
export declare function useRouterState(): RouterState

/**
 * @public
 */
export declare function useStateLink(props: {
  onClick?: React_2.MouseEventHandler<HTMLElement>
  replace?: boolean
  state?: Record<string, unknown>
  target?: string
  toIndex?: boolean
}): {
  onClick: React_2.MouseEventHandler<HTMLElement>
  href: string
}

/**
 * A higher-order component that injects the router object into its child component.
 *
 * @internal
 * @deprecated - Use the `useRouter` hook instead.
 *
 * @returns The rendered component.
 *
 * @example
 * ```tsx
 * function MyComponent(props: {router: Router}) {
 *   const {location} = props.router
 *   const {pathname} = location
 *   return <p>The current path is: {pathname}</p>
 * }
 *
 * function App() {
 *   return (
 *     <Router>
 *       <WithRouter>
 *         {router => <MyComponent router={router} />}
 *       </WithRouter>
 *     </Router>
 *   )
 * }
 * ```
 */
export declare const WithRouter: React_2.FunctionComponent<Omit<WithRouterProps, 'router'>>

/**
 * A higher-order component that injects the `router` object from the `useRouter` hook
 * into the props of the wrapped component.
 *
 * @internal
 * @deprecated - Use the `useRouter` hook instead.
 *
 * @param Component - The component to wrap.
 *
 * @returns The wrapped component.
 *
 * @example
 * ```tsx
 * function MyComponent(props) {
 *  return <div>{props.router.state.myParam}</div>
 * }
 *
 * export default withRouter(MyComponent)
 * ```
 */
export declare function withRouter<
  Props extends {
    router: RouterContextValue
  }
>(Component: ComponentType<Props>): FunctionComponent<Omit<Props, 'router'>>

/**
 * @internal
 * @deprecated - Use the `useRouter` hook instead.
 */
export declare interface WithRouterProps {
  /**
   * The `router` object from the `useRouter` hook.
   *  {@link RouterContextValue}
   */
  router: RouterContextValue
  /**
   * A function that renders the wrapped component with the `router` object as a parameter.
   */
  children: (router: RouterContextValue) => React_2.ReactElement
}

export {}
