/// <reference types="react" />

import {ArrayDiff as ArrayDiff_2} from '@sanity/diff'
import {ArraySchemaType} from '@sanity/types'
import {AssetMetadataType} from '@sanity/types'
import {AssetSource} from '@sanity/types'
import {AssetSourceSpec} from '@sanity/types'
import {AvatarPosition} from '@sanity/ui'
import {AvatarSize} from '@sanity/ui'
import {AvatarStatus} from '@sanity/ui'
import {BifurClient} from '@sanity/bifur-client'
import {BlockDecoratorDefinition} from '@sanity/types'
import {BlockListDefinition} from '@sanity/types'
import {BlockStyleDefinition} from '@sanity/types'
import {BooleanDiff as BooleanDiff_2} from '@sanity/diff'
import {BooleanSchemaType} from '@sanity/types'
import {BoxProps} from '@sanity/ui'
import type {BrowserHistory} from 'history'
import {ButtonProps} from '@sanity/ui'
import {ButtonTone} from '@sanity/ui'
import {CardProps} from '@sanity/ui'
import {ClientConfig} from '@sanity/client'
import {ColorHueKey} from '@sanity/color'
import {ColorTintKey} from '@sanity/color'
import {ColorTints} from '@sanity/color'
import {ComponentProps} from 'react'
import {ComponentType} from 'react'
import {ConditionalProperty} from '@sanity/types'
import {Context} from 'react'
import {CrossDatasetReferenceSchemaType} from '@sanity/types'
import {CrossDatasetReferenceValue} from '@sanity/types'
import {CSSProperties} from 'react'
import {CurrentUser} from '@sanity/types'
import {DefaultTheme} from 'styled-components'
import {Diff as Diff_2} from '@sanity/diff'
import {ElementType} from 'react'
import {File as File_2} from '@sanity/types'
import {FileAsset} from '@sanity/types'
import {FileSchemaType} from '@sanity/types'
import {FileValue} from '@sanity/types'
import {FocusEventHandler} from 'react'
import {FormEventHandler} from 'react'
import {FormNodeValidation} from '@sanity/types'
import {GeopointValue} from '@sanity/types'
import type {HashHistory} from 'history'
import type {History as History_2} from 'history'
import {HotkeyOptions} from '@sanity/portable-text-editor'
import {HTMLProps} from 'react'
import {Image as Image_2} from '@sanity/types'
import {ImageAsset} from '@sanity/types'
import {ImageSchemaType} from '@sanity/types'
import imageUrlBuilder from '@sanity/image-url'
import {ImageUrlFitMode} from '@sanity/types'
import {ImageValue} from '@sanity/types'
import {IndexTuple} from '@sanity/types'
import {InitialValueProperty} from '@sanity/types'
import {InitialValueResolverContext} from '@sanity/types'
import {IntrinsicTypeName} from '@sanity/types'
import {ItemDiff as ItemDiff_2} from '@sanity/diff'
import {JSXElementConstructor} from 'react'
import {KeyedSegment} from '@sanity/types'
import {MemoizedFunction} from 'lodash'
import type {MemoryHistory} from 'history'
import type {MendozaEffectPair} from '@sanity/types'
import {MenuButtonProps} from '@sanity/ui'
import {Mutation} from '@sanity/mutator'
import {NullDiff as NullDiff_2} from '@sanity/diff'
import {NumberDiff as NumberDiff_2} from '@sanity/diff'
import {NumberSchemaType} from '@sanity/types'
import {ObjectDiff as ObjectDiff_2} from '@sanity/diff'
import {ObjectField} from '@sanity/types'
import {ObjectFieldType} from '@sanity/types'
import {ObjectSchemaType} from '@sanity/types'
import {Observable} from 'rxjs'
import {OnCopyFn} from '@sanity/portable-text-editor'
import {OnPasteFn} from '@sanity/portable-text-editor'
import {OperatorFunction} from 'rxjs'
import {PatchOperations} from '@sanity/types'
import {Path} from '@sanity/types'
import {PathSegment} from '@sanity/types'
import {Placement} from '@sanity/ui'
import {PopoverProps} from '@sanity/ui'
import {PortableTextBlock} from '@sanity/types'
import {PortableTextObject} from '@sanity/types'
import {PortableTextTextBlock} from '@sanity/types'
import {PrepareViewOptions} from '@sanity/types'
import {PreviewConfig} from '@sanity/types'
import {PreviewValue} from '@sanity/types'
import {default as React_2} from 'react'
import {ReactElement} from 'react'
import {ReactNode} from 'react'
import {Reference} from '@sanity/types'
import {ReferenceSchemaType} from '@sanity/types'
import {ReferenceValue} from '@sanity/types'
import {ResizeObserverEntry as ResizeObserverEntry_2} from '@juggle/resize-observer'
import {ResponsivePaddingProps} from '@sanity/ui'
import {ResponsiveWidthProps} from '@sanity/ui'
import type {RootTheme} from '@sanity/ui'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/types'
import {SanityDocumentLike} from '@sanity/types'
import {Schema} from '@sanity/types'
import {SchemaType} from '@sanity/types'
import {SchemaTypeDefinition} from '@sanity/types'
import {ScrollToOptions as ScrollToOptions_2} from '@tanstack/react-virtual'
import {SlugSchemaType} from '@sanity/types'
import {SlugValue} from '@sanity/types'
import {SortOrdering} from '@sanity/types'
import {StringDiff as StringDiff_2} from '@sanity/diff'
import {StringSchemaType} from '@sanity/types'
import {StringSegmentChanged as StringSegmentChanged_2} from '@sanity/diff'
import {StringSegmentUnchanged as StringSegmentUnchanged_2} from '@sanity/diff'
import {StyledComponent} from 'styled-components'
import {Subject} from 'rxjs'
import {Subscriber} from 'nano-pubsub'
import {Text as Text_2} from '@sanity/ui'
import {TextProps} from '@sanity/ui'
import {TextSchemaType} from '@sanity/types'
import {ThemeColorSchemeKey} from '@sanity/ui'
import type {ThrottleSettings} from 'lodash'
import {TooltipProps} from '@sanity/ui'
import type {TransactionLogEventWithEffects} from '@sanity/types'
import {TransactionLogEventWithMutations} from '@sanity/types'
import {TypeChangeDiff as TypeChangeDiff_2} from '@sanity/diff'
import {UploadState} from '@sanity/types'
import {User} from '@sanity/types'
import {ValidationMarker} from '@sanity/types'

/** @internal */
export declare function __tmp_wrap_presenceStore(context: {
  bifur: BifurClient
  connectionStatusStore: ConnectionStatusStore
  userStore: UserStore
}): PresenceStore

/**
 * @hidden
 * @beta */
export declare interface ActionComponent<ActionProps> {
  (props: ActionProps): DocumentActionDescription | null
}

/** @internal */
export declare type ActionHook<T, K> = (args: T) => K | null

/** @internal */
export declare function ActiveWorkspaceMatcher({
  children,
  LoadingComponent,
  NotFoundComponent,
  unstable_history: historyProp,
}: ActiveWorkspaceMatcherProps): JSX.Element

/** @internal */
export declare const ActiveWorkspaceMatcherContext: Context<ActiveWorkspaceMatcherContextValue | null>

/** @internal */
export declare interface ActiveWorkspaceMatcherContextValue {
  activeWorkspace: WorkspaceSummary
  setActiveWorkspace: (workspaceName: string) => void
}

/** @internal */
export declare interface ActiveWorkspaceMatcherProps {
  children: React_2.ReactNode
  unstable_history?: RouterHistory
  NotFoundComponent: React_2.ComponentType<{
    onNavigateToDefaultWorkspace: () => void
  }>
  LoadingComponent: React_2.ComponentType
}

/**
 * @hidden
 * @beta */
export declare type Annotation = AnnotationDetails | null

/**
 * Annotation connected to a change
 *
 *
 * @hidden
 * @beta
 */
export declare type AnnotationDetails = {
  chunk: Chunk
  timestamp: string
  author: string
}

/**
 * @hidden
 * @beta */
export declare interface ApiConfig {
  projectId: string
  dataset: string
}

/** @internal */
export declare type ArrayDiff<V = unknown> = ArrayDiff_2<Annotation, V>

/**
 * @hidden
 * @beta */
export declare interface ArrayFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfObjectsInputProps
}

/**
 * These are the props an implementation of the ArrayFunctions component will receive
 *
 *
 * @hidden
 * @beta
 */
export declare interface ArrayInputFunctionsProps<Item, SchemaType extends ArraySchemaType> {
  children?: React_2.ReactNode
  onItemAppend: (itemValue: Item) => void
  onChange: (event: PatchEvent) => void
  onValueCreate: (type: SchemaType) => Item
  onItemPrepend: (itemValue: Item) => void
  readOnly?: boolean
  schemaType: SchemaType
  value?: Item[]
}

/**
 * @hidden
 * @beta */
export declare interface ArrayInputInsertEvent<Item> {
  items: Item[]
  position: 'before' | 'after'
  referenceItem: KeyedSegment | number
  skipInitialValue?: boolean
  open?: boolean
}

/**
 * @hidden
 * @beta */
export declare interface ArrayInputMoveItemEvent {
  fromIndex: number
  toIndex: number
}

/**
 * @hidden
 * @beta */
export declare interface ArrayItemError {
  kind: 'error'
  key: string
  index: number
  error: InvalidItemTypeError
}

/**
 * Diff extensions for presentational concerns
 *
 * @internal
 */
export declare interface ArrayItemMetadata {
  fromType?: SchemaType
  toType?: SchemaType
}

/**
 * @hidden
 * Array of predefined object options input
 * Note: this input can handle only object values
 *
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfObjectOptionsInput(props: ArrayOfObjectsInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare interface ArrayOfObjectsComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ArrayFieldProps>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ArrayOfObjectsInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @public */
export declare interface ArrayOfObjectsFormNode<
  T extends any[] = unknown[],
  S extends ArraySchemaType = ArraySchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfObjectsMember[]
}

/**
 * @hidden
 * @beta */
export declare function ArrayOfObjectsFunctions<
  Item extends ObjectItem,
  SchemaType extends ArraySchemaType
>(props: ArrayInputFunctionsProps<Item, SchemaType>): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfObjectsInput(props: ArrayOfObjectsInputProps): JSX.Element

/**
 * Convenience component for rendering an "array of objects"-item
 * @internal
 */
export declare function ArrayOfObjectsInputMember(
  props: ArrayOfObjectsMemberProps
): JSX.Element | null

/**
 * Convenience component for wrapping an array of objects
 * @internal
 */
export declare function ArrayOfObjectsInputMembers(
  props: ArrayOfObjectsInputMembersProps
): JSX.Element

/** @internal */
export declare interface ArrayOfObjectsInputMembersProps {
  members: ArrayOfObjectsMember[]
  renderAnnotation: RenderAnnotationCallback
  renderBlock: RenderBlockCallback
  renderInlineBlock: RenderBlockCallback
  renderInput: RenderInputCallback
  renderField: RenderFieldCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/**
 * @hidden
 * @beta */
export declare interface ArrayOfObjectsInputProps<
  T extends {
    _key: string
  } = {
    _key: string
  },
  S extends ArraySchemaType = ArraySchemaType
> extends BaseInputProps,
    ArrayOfObjectsFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemMove: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: ArrayInputInsertEvent<T>) => void
  /**
   * @hidden
   * @beta */
  resolveInitialValue: (type: SchemaType, params: Record<string, unknown>) => Promise<T>
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * for array inputs using expand/collapse semantics for items
   *
   * @hidden
   * @beta
   */
  onItemCollapse: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemExpand: (itemKey: string) => void
  /**
   * for array inputs using modal open/close semantics for items
   *
   * @hidden
   * @beta
   */
  onItemOpen: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onItemClose: () => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfObjectsItem(props: MemberItemProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface ArrayOfObjectsItemMember<
  Node extends ObjectArrayFormNode = ObjectArrayFormNode
> {
  kind: 'item'
  key: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
export declare type ArrayOfObjectsMember = ArrayOfObjectsItemMember | ArrayItemError

/** @internal */
export declare interface ArrayOfObjectsMemberProps {
  member: ArrayOfObjectsMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfOptionsInput(
  props: ArrayOfObjectsInputProps | ArrayOfPrimitivesInputProps
): JSX.Element

/**
 * Array of predefined primitive options input
 * Note: this input can only handle primitive values
 *
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfPrimitiveOptionsInput(
  props: ArrayOfPrimitivesInputProps
): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare interface ArrayOfPrimitivesComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ArrayOfPrimitivesFieldProps>
  input?: ComponentType<ArrayOfPrimitivesInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare type ArrayOfPrimitivesElementType<T extends any[]> = T extends (infer K)[]
  ? K
  : unknown

/**
 * @hidden
 * @beta */
export declare interface ArrayOfPrimitivesFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfPrimitivesInputProps
}

/** @public */
export declare interface ArrayOfPrimitivesFormNode<
  T extends (string | number | boolean)[] = (string | number | boolean)[],
  S extends ArraySchemaType = ArraySchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfPrimitivesMember[]
}

/**
 * @hidden
 * @beta */
export declare function ArrayOfPrimitivesFunctions<
  MemberType extends string | boolean | number,
  SchemaType extends ArraySchemaType
>(props: ArrayInputFunctionsProps<MemberType, SchemaType>): JSX.Element

/**
 * @hidden
 * @beta */
export declare class ArrayOfPrimitivesInput extends React_2.PureComponent<
  ArrayOfPrimitivesInputProps,
  State
> {
  _element: HTMLElement | null
  constructor(props: ArrayOfPrimitivesInputProps)
  handleAppend: (itemValue: PrimitiveValue) => void
  handlePrepend: (itemValue: PrimitiveValue) => void
  handleSortEnd: (event: {fromIndex: number; toIndex: number}) => void
  handleItemMoveStart: () => void
  handleItemMoveEnd: () => void
  focus(): void
  getSnapshotBeforeUpdate(prevProps: ArrayOfPrimitivesInputProps):
    | {
        prevFocusedIndex: PathSegment
        restoreSelection: {
          text: string
          start: number | null
          end: number | null
          value: string
        }
      }
    | {
        prevFocusedIndex?: undefined
        restoreSelection?: undefined
      }
    | null
  componentDidUpdate(
    prevProps: ArrayOfPrimitivesInputProps,
    prevState: Record<string, unknown>,
    snapshot?: {
      restoreSelection: {
        start: number
        end: number
      }
      prevFocusedIndex: number
    }
  ): void
  renderArrayItem: (props: Omit<PrimitiveItemProps, 'renderDefault'>) => JSX.Element
  render(): JSX.Element
}

/**
 * @hidden
 * @beta */
export declare interface ArrayOfPrimitivesInputProps<
  T extends string | boolean | number = string | boolean | number,
  S extends ArraySchemaType = ArraySchemaType
> extends BaseInputProps,
    ArrayOfPrimitivesFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  onSetCollapsed: (collapsed: boolean) => void
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (index: number) => void
  /**
   * @hidden
   * @beta */
  onMoveItem: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: {items: T[]; position: 'before' | 'after'; referenceIndex: number}) => void
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<NumberSchemaType | BooleanSchemaType | StringSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onIndexFocus: (index: number) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfPrimitivesItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfPrimitivesItem(props: PrimitiveMemberItemProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface ArrayOfPrimitivesItemMember<
  Node extends PrimitiveFormNode = PrimitiveFormNode
> {
  kind: 'item'
  key: string
  index: number
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
export declare type ArrayOfPrimitivesMember = ArrayOfPrimitivesItemMember | ArrayItemError

/** @internal */
export declare function asLoadable<T>(): OperatorFunction<T, LoadableState<T>>

/**
 * @hidden
 * @beta */
export declare type AssetSourceResolver = ComposableOption<AssetSource[], ConfigContext>

/**
 * @hidden
 * @beta */
export declare type AsyncComposableOption<TValue, TContext> = (
  prev: TValue,
  context: TContext
) => Promise<TValue>

/** @internal */
export declare type AsyncConfigPropertyReducer<TValue, TContext> = (
  prev: TValue,
  config: PluginOptions,
  context: TContext
) => TValue | Promise<TValue>

/** @internal */
export declare interface AuthProvider {
  name: string
  title: string
  url: string
  logo?: string
}

/**
 * The unit an `AuthStore` emits to determine the user's authentication state.
 *
 * @internal
 */
export declare interface AuthState {
  /**
   * Similar to a logged-in flag. This state is used in places like the
   * `AuthBoundary` to determine whether or not it should render the
   * `NotAuthenticatedComponent`. Implementers may choose to set this to `true`
   * while also also emitting a `currentUser` of `null` if a `null` user is
   * accepted (e.g. a project that doesn't require a login)
   */
  authenticated: boolean
  /**
   * The value of the user logged in or `null` if none is provided
   */
  currentUser: CurrentUser | null
  /**
   * A client that is expected to be pre-configured to allow for any downstream
   * requests in the Studio
   */
  client: SanityClient
}

/**
 * The interface used by the Studio that produces a `SanityClient` and
 * `CurrentUser` that gets passed to the resulting `Workspace`s and `Source`s.
 *
 * NOTE: This interface is primarily for internal use. Refer to
 * `createAuthStore` instead.
 *
 * @internal
 */
export declare interface AuthStore {
  /**
   * Emits `AuthState`s. This should update when the user's auth state changes.
   * E.g. After a login, a new `AuthState` could be emitted with a non-null
   * `currentUser` and `authenticated: true`
   *
   * NOTE: all auth store implementations should emit on subscribe using
   * something like shareReplay(1) to ensure all new subscribers get an
   * `AuthState` value on subscribe
   */
  state: Observable<AuthState>
  /**
   * Emits auth tokens, or `null` if not configured to use them or they do not exist
   */
  token?: Observable<string | null>
  /**
   * Custom auth stores are expected to implement a UI that initiates the user's
   * authentication. For the typical case in `createAuthStore`, this means
   * loading the providers and showing them as options to the user.
   */
  LoginComponent?: React.ComponentType<LoginComponentProps>
  /**
   * Custom auth stores can implement a function that runs when the user logs
   * out. The implementation is expected to remove all credentials both locally
   * and on the server.
   */
  logout?: () => void
  /**
   * Custom auth stores can implement a function that is designated to run when
   * the Studio loads (e.g. to trade a session ID for a token in cookie-less
   * mode). Within the Studio, this is called within the `AuthBoundary`.
   */
  handleCallbackUrl?: () => Promise<void>
}

/** @internal */
export declare interface AuthStoreOptions {
  clientFactory?: (options: ClientConfig) => SanityClient
  projectId: string
  dataset: string
  apiHost?: string
  /**
   * Login method to use for the studio the studio. Can be one of:
   * - `dual` (default) - attempt to use cookies where possible, falling back to
   *   storing authentication token in `localStorage` otherwise
   * - `cookie` - explicitly disable `localStorage` method, relying only on
   *   cookies
   */
  loginMethod?: 'dual' | 'cookie'
  /**
   * Append the custom providers to the default providers or replace them.
   */
  mode?: 'append' | 'replace'
  /**
   * If true, don't show the choose provider logo screen, automatically redirect
   * to the single provider login
   */
  redirectOnSingle?: boolean
  /**
   * The custom provider implementations
   */
  providers?: AuthProvider[]
}

/** @internal */
export declare type AvailabilityReason = 'READABLE' | 'PERMISSION_DENIED' | 'NOT_FOUND'

/** @internal */
export declare interface AvailabilityResponse {
  omitted: {
    id: string
    reason: 'existence' | 'permission'
  }[]
}

/**
 * @hidden
 * @beta */
export declare interface BaseFieldProps {
  schemaType: SchemaType
  title: string | undefined
  description: string | undefined
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  level: number
  inputId: string
  value: unknown | undefined
  path: Path
  name: string
  index: number
  changed: boolean
  children: ReactNode
  renderDefault: (props: FieldProps) => ReactElement
}

/**
 * @hidden
 * @beta */
declare interface BaseFileInputProps extends ObjectInputProps<BaseFileInputValue, FileSchemaType> {
  assetSources: AssetSource[]
  directUploads?: boolean
  observeAsset: (documentId: string) => Observable<FileAsset>
  resolveUploader: UploaderResolver
  client: SanityClient
}

/**
 * @hidden
 * @beta */
declare interface BaseFileInputValue extends Partial<File_2> {
  _upload?: UploadState
}

/** @public */
export declare interface BaseFormNode<T = unknown, S extends SchemaType = SchemaType> {
  id: string
  schemaType: S
  level: number
  path: Path
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  value: T | undefined
  readOnly?: boolean
  focused?: boolean
  changed: boolean
}

/**
 * @hidden
 * @beta */
declare interface BaseImageInputProps
  extends ObjectInputProps<BaseImageInputValue, ImageSchemaType> {
  assetSources: AssetSource[]
  directUploads?: boolean
  imageUrlBuilder: ImageUrlBuilder
  observeAsset: (documentId: string) => Observable<ImageAsset>
  resolveUploader: UploaderResolver
  client: SanityClient
}

/**
 * @hidden
 * @beta */
declare interface BaseImageInputValue extends Partial<Image_2> {
  _upload?: UploadState
}

/**
 * @hidden
 * @beta */
export declare interface BaseInputProps {
  renderDefault: (props: InputProps) => React_2.ReactElement
}

/** @public */
export declare interface BaseItemProps<T> {
  schemaType: SchemaType
  key: string
  index: number
  level: number
  value: unknown
  path: Path
  title: string | undefined
  description: string | undefined
  inputId: string
  onFocus: (event: React_2.FocusEvent) => void
  onBlur: (event: React_2.FocusEvent) => void
  readOnly?: boolean
  focused?: boolean
  onRemove: () => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: Omit<ArrayInputInsertEvent<T>, 'referenceItem'>) => void
  children: React_2.ReactNode
  validation: FormNodeValidation[]
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  renderDefault: (props: ItemProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta */
export declare interface BlockAnnotationProps {
  __unstable_boundaryElement?: HTMLElement
  __unstable_referenceElement?: HTMLElement
  __unstable_textElementFocus?: boolean
  children: ReactNode
  focused: boolean
  markers: PortableTextMarker[]
  onClose: () => void
  onOpen: () => void
  onPathFocus: (path: Path) => void
  onRemove: () => void
  open: boolean
  parentSchemaType: SchemaType
  path: Path
  presence: FormNodePresence[]
  readOnly: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderDefault: (props: BlockAnnotationProps) => ReactElement
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
  selected: boolean
  textElement: ReactElement
  validation: FormNodeValidation[]
  value: PortableTextObject
}

/**
 * @hidden
 * @beta */
export declare interface BlockDecoratorProps {
  children: React.ReactElement
  focused: boolean
  renderDefault: (props: BlockDecoratorProps) => React.ReactElement
  schemaType: BlockDecoratorDefinition
  selected: boolean
  title: string
  value: string
}

/**
 * @hidden
 * @beta */
export declare function BlockImagePreview(props: BlockImagePreviewProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type BlockImagePreviewProps = Omit<PreviewProps<'blockImage'>, 'renderDefault'>

/**
 * @hidden
 * @beta */
export declare interface BlockListItemProps {
  block: PortableTextTextBlock
  children: React.ReactElement
  focused: boolean
  level: number
  renderDefault: (props: BlockListItemProps) => React.ReactElement
  schemaType: BlockListDefinition
  selected: boolean
  title: string
  value: string
}

/**
 * @hidden
 * @beta */
export declare function BlockPreview(
  props: Omit<PreviewProps<'block'>, 'renderDefault'>
): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface BlockProps {
  __unstable_boundaryElement?: HTMLElement
  __unstable_referenceElement?: HTMLElement
  children: ReactNode
  focused: boolean
  markers: PortableTextMarker[]
  onClose: () => void
  onOpen: () => void
  onPathFocus: (path: Path) => void
  onRemove: () => void
  open: boolean
  parentSchemaType: ArraySchemaType | ObjectSchemaType
  path: Path
  presence: FormNodePresence[]
  readOnly: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderDefault: (props: BlockProps) => ReactElement
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
  selected: boolean
  validation: FormNodeValidation[]
  value: PortableTextBlock
}

/**
 * @hidden
 * @beta */
export declare interface BlockStyleProps {
  block: PortableTextTextBlock
  children: React.ReactElement
  focused: boolean
  renderDefault: (props: BlockStyleProps) => React.ReactElement
  schemaType: BlockStyleDefinition
  selected: boolean
  title: string
  value: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface BooleanComponents {
  diff?: ComponentType<any>
  field?: ComponentType<BooleanFieldProps>
  input?: ComponentType<BooleanInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type BooleanDiff = BooleanDiff_2<Annotation>

/**
 * @hidden
 * @beta */
export declare interface BooleanFieldProps extends BaseFieldProps {
  schemaType: BooleanSchemaType
  value: boolean | undefined
  inputProps: BooleanInputProps
}

/** @public */
export declare type BooleanFormNode<S extends BooleanSchemaType = BooleanSchemaType> = BaseFormNode<
  boolean,
  S
>

/**
 *
 * @hidden
 * @beta
 */
export declare function BooleanInput(props: BooleanInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface BooleanInputProps<S extends BooleanSchemaType = BooleanSchemaType>
  extends BaseInputProps,
    BooleanFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * A shorthand aggregation of any validation errors the input currently have
   * Will be falsey if no error.
   * In the case of multiple errors it will be a newline delimited string of each error message
   * For advanced use cases use the ´validation´ prop which contains more levels and details
   */
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @beta */
export declare type BufferedDocumentEvent =
  | SnapshotEvent
  | DocumentRebaseEvent
  | DocumentMutationEvent
  | CommittedEvent

/** @internal */
export declare interface BufferedDocumentWrapper {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotEvent>
  events: Observable<BufferedDocumentEvent>
  commitRequest$: Observable<CommitRequest>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * Build a Sanity UI theme from legacy CSS properties.
 *
 * @example
 * ```tsx
 * import {buildLegacyTheme, defineConfig} from 'sanity'
 *
 * export default defineConfig({
 *   // project configuration ...
 *
 *   // Customize theming
 *   theme: buildLegacyTheme({
 *     '--black': '#000',
 *     '--gray': '#777',
 *     '--focus-color': '#00f',
 *   })
 * })
 * ```
 *
 * @public
 */
export declare function buildLegacyTheme(partialLegacyTheme: Partial<LegacyThemeProps>): StudioTheme

/** @internal */
export declare function ChangeBreadcrumb(props: {
  change?: FieldChangeNode
  titlePath: ChangeTitlePath
}): JSX.Element

/** @internal */
export declare const ChangeConnectorRoot: typeof EnabledChangeConnectorRoot

/**
 * This is used to draw the bar that wraps the diff components in the changes panel
 *
 * @internal
 */
export declare const ChangeFieldWrapper: (props: {
  path: Path
  children: React_2.ReactNode
  hasHover: boolean
}) => JSX.Element

/** @internal */
export declare function ChangeIndicator(props: ChangeIndicatorProps): JSX.Element

/** @internal */
export declare const ChangeIndicatorContext: React_2.Context<ChangeIndicatorContextValue>

/** @internal */
export declare interface ChangeIndicatorContextValue {
  value?: unknown
  focusPath: Path
  path: Path
  fullPath: Path
  isChanged: boolean
}

/** @internal */
export declare interface ChangeIndicatorProps {
  children?: React_2.ReactNode
  className?: string
  disabled?: boolean
  path: Path
  hasFocus: boolean
  isChanged: boolean
  withHoverEffect?: boolean
}

/** @internal */
export declare function ChangeList({
  diff,
  fields,
  schemaType,
}: ChangeListProps): React_2.ReactElement | null

/** @internal */
export declare interface ChangeListProps {
  schemaType: ObjectSchemaType
  diff: ObjectDiff
  fields?: string[]
}

/** @internal */
export declare type ChangeNode = GroupChangeNode | FieldChangeNode

/** @internal */
export declare function ChangeResolver(props: ChangeResolverProps): JSX.Element | null

/** @internal */
export declare interface ChangeResolverProps {
  change: ChangeNode
  readOnly?: ConditionalProperty
  hidden?: ConditionalProperty
}

/** @internal */
export declare type ChangeTitlePath = (string | FromToIndex)[]

/** @internal */
export declare function ChangeTitleSegment(props: {
  change?: FieldChangeNode
  segment: string | FromToIndex
}): JSX.Element

/** @internal */
export declare function checkoutPair(client: SanityClient, idPair: IdPair): Pair

/**
 * @hidden
 * @beta */
export declare type Chunk = {
  index: number
  id: string
  type: ChunkType
  start: number
  end: number
  startTimestamp: string
  endTimestamp: string
  authors: Set<string>
  draftState: 'present' | 'missing' | 'unknown'
  publishedState: 'present' | 'missing' | 'unknown'
}

/**
 * History timeline / chunking
 *
 *
 * @hidden
 * @beta
 */
export declare type ChunkType =
  | 'initial'
  | 'create'
  | 'editDraft'
  | 'delete'
  | 'publish'
  | 'unpublish'
  | 'discardDraft'
  | 'editLive'

/**
 * @hidden
 * @beta */
export declare function CircularProgress(props: {
  /** Percentage */
  value: number
}): JSX.Element

/** @internal */
export declare const CollapseMenu: React_2.ForwardRefExoticComponent<
  CollapseMenuProps & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare const CollapseMenuButton: React_2.ForwardRefExoticComponent<
  Omit<CollapseMenuButtonProps & Omit<React_2.HTMLProps<HTMLButtonElement>, 'as'>, 'ref'> &
    React_2.RefAttributes<HTMLButtonElement>
>

/** @internal */
export declare interface CollapseMenuButtonProps extends CommonProps {
  collapsedProps?: Omit<CommonProps, 'text'>
  expandedProps?: CommonProps
  text: ButtonProps['text']
}

/** @internal */
export declare interface CollapseMenuProps {
  children: React_2.ReactNode
  collapsed?: boolean
  collapseText?: boolean
  disableRestoreFocusOnClose?: boolean
  gap?: number | number[]
  menuButtonProps?: Omit<MenuButtonProps, 'id' | 'menu' | 'button'> & {
    id?: string
    button?: React_2.ReactElement
  }
  onMenuClose?: () => void
}

/** @internal */
export declare function collate<
  T extends {
    _id: string
    _type: string
  }
>(documents: T[]): CollatedHit<T>[]

/**
 * Takes a list of documents and collates draft/published pairs into single entries
 * `{id: <published id>, draft?: <draft document>, published?: <published document>}`
 *
 * Note: because Map is ordered by insertion key the resulting array will be ordered by whichever
 * version appeared first
 *
 * @internal
 */
export declare interface CollatedHit<
  T extends {
    _id: string
  } = {
    _id: string
  }
> {
  id: string
  type: string
  draft?: T
  published?: T
}

/**
 * If the `scheme` prop is provided we don't need to setup any logic to handle localStorage
 * @internal
 */
export declare function ColorSchemeCustomProvider({
  children,
  onSchemeChange,
  scheme,
}: Pick<ColorSchemeProviderProps, 'children' | 'onSchemeChange'> & {
  scheme: StudioThemeColorSchemeKey
}): JSX.Element

/**
 * Uses useSyncExternalStore to ensure that localStorage is accessed in a SSR hydration compatible way
 * @internal
 */
export declare function ColorSchemeLocalStorageProvider({
  children,
  onSchemeChange,
}: Pick<ColorSchemeProviderProps, 'children' | 'onSchemeChange'>): JSX.Element

/** @internal */
export declare function ColorSchemeProvider({
  children,
  onSchemeChange,
  scheme: schemeProp,
}: ColorSchemeProviderProps): JSX.Element

/** @internal */
export declare interface ColorSchemeProviderProps {
  children: React_2.ReactNode
  onSchemeChange?: (nextScheme: StudioThemeColorSchemeKey) => void
  scheme?: StudioThemeColorSchemeKey
}

/**
 * The setter for ColorSchemeValueContext, in a separate context to avoid unnecessary re-renders
 * If set to false then the UI should adjust to reflect that the Studio can't change the color scheme
 * @internal
 */
export declare const ColorSchemeSetValueContext: React_2.Context<
  false | ((nextScheme: StudioThemeColorSchemeKey) => void) | null
>

/**
 * Used to keep track of the internal value, which can be "system" in addition to "light" and "dark"
 * @internal
 */
export declare const ColorSchemeValueContext: React_2.Context<StudioThemeColorSchemeKey | null>

/**
 * @hidden
 * @beta */
export declare interface CombinedDocument {
  draft: Record<string, unknown> | null
  published: Record<string, unknown> | null
}

/**
 * Renders a Command List with support for the following:
 *
 * - Keyboard navigation (↑ / ↓ / ENTER) to children with a specified container (`childContainerRef`)
 * - Focus redirection when clicking child elements
 * - Pointer blocking when navigating with arrow keys (to ensure that only one active state is visible at any given time)
 * - ARIA attributes to define a `combobox` input that controls a separate `listbox`
 *
 * @internal
 */
export declare const CommandList: React_2.ForwardRefExoticComponent<
  CommandListProps<any> & React_2.RefAttributes<CommandListHandle>
>

/** @internal */
export declare type CommandListElementType = 'input' | 'list'

/** @internal */
export declare type CommandListGetItemDisabledCallback = (virtualIndex: number) => boolean

/** @internal */
export declare type CommandListGetItemKeyCallback = (virtualIndex: number) => number | string

/** @internal */
export declare type CommandListGetItemSelectedCallback = (virtualIndex: number) => boolean

/** @internal */
export declare interface CommandListHandle {
  focusInputElement: () => void
  focusListElement: () => void
  getTopIndex: () => number
  scrollToIndex: (index: number) => void
}

/** @internal */
export declare type CommandListItemContext = {
  activeIndex: number | null
  disabled?: boolean
  selected?: boolean
  virtualIndex: number
}

/** @internal */
export declare interface CommandListProps<T = any> extends ResponsivePaddingProps {
  /** The data attribute to apply to any active virtual list items */
  activeItemDataAttr?: string
  /** `aria-label` to apply to the virtual list container element */
  ariaLabel: string
  /** Whether `aria-multiselectable` is enabled on the virtual list container element */
  ariaMultiselectable?: boolean
  /** Automatically focus the input or virtual list */
  autoFocus?: CommandListElementType
  /** Whether the virtual list can receive focus */
  canReceiveFocus?: boolean
  /** Pixel offset of the virtual list focus ring. Negative values will cause the focus ring to appear inset */
  focusRingOffset?: number
  /** Force a fixed height for all virtual list children and skip measurement (faster). */
  fixedHeight?: boolean
  /** Custom function to map disabled items */
  getItemDisabled?: CommandListGetItemDisabledCallback
  /** Custom function to map virtual list items to custom keys */
  getItemKey?: CommandListGetItemKeyCallback
  /** Custom function to map selected items */
  getItemSelected?: CommandListGetItemSelectedCallback
  /** Scroll alignment of the initial active index */
  initialScrollAlign?: ScrollToOptions_2['align']
  /** Initial active index on mount */
  initialIndex?: number
  /** Input element to associate with this virtual list. Associated inputs will receive focus and handle key events */
  inputElement?: HTMLInputElement | null
  /** Estimated height for each list item */
  itemHeight: number
  /** Virtual list item values, accessible to all rendered item components */
  items: T[]
  /** Callback fired when the virtual list is within `onEndReachedIndexThreshold` of rendered content */
  onEndReached?: () => void
  /** Number of items from the end of the virtual list before which `onEndReached` is triggered */
  onEndReachedIndexOffset?: number
  /** Only show selection state when the virtual list is active (is hovered or has focus) */
  onlyShowSelectionWhenActive?: boolean
  /** Number of items to render above and below the visible area*/
  overscan?: number
  /** Rendered component in virtual lists */
  renderItem: CommandListRenderItemCallback<T>
  /** Allow wraparound keyboard navigation between first and last items */
  wrapAround?: boolean
}

/** @internal */
export declare type CommandListRenderItemCallback<T> = (
  item: T,
  context: CommandListItemContext
) => ReactNode

/** @internal */
export declare type CommitFunction = (mutation: Mutation['params']) => Promise<unknown>

/**
 * Represents "commit requests" from the mutator.
 * These are emitted from the BufferedDocument instance's `requestHandler` callback
 *
 * @internal
 */
export declare interface CommitRequest {
  mutation: Mutation
  success: () => void
  failure: (error: Error) => void
  cancel: (error: Error) => void
}

/**
 * @hidden
 * @beta */
export declare interface CommittedEvent {
  type: 'committed'
}

/** @internal */
export declare interface CommonProps extends Omit<ButtonProps, 'text' | 'iconRight'> {
  as?: React_2.ElementType | keyof JSX.IntrinsicElements
  dividerBefore?: boolean
  focused?: boolean
  tooltipProps?: TooltipProps
  tooltipText?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface ComplexElementProps {
  id: string
  onFocus: FocusEventHandler
  onBlur: FocusEventHandler
  ref: React_2.MutableRefObject<any>
}

/** @public */
export declare type ComposableOption<TValue, TContext> = (prev: TValue, context: TContext) => TValue

/**
 * @hidden
 * @beta */
export declare type Config = SingleWorkspace | WorkspaceOptions[]

/** @public */
export declare interface ConfigContext {
  projectId: string
  dataset: string
  schema: Schema
  currentUser: CurrentUser | null
  getClient: (options: SourceClientOptions) => SanityClient
}

/** @internal */
export declare class ConfigPropertyError extends Error {
  propertyName: string
  path: string[]
  cause: unknown
  constructor({propertyName, path, cause}: ConfigPropertyErrorOptions)
}

/** @internal */
export declare interface ConfigPropertyErrorOptions {
  propertyName: string
  path: string[]
  cause: unknown
}

/** @internal */
export declare type ConfigPropertyReducer<TValue, TContext> = (
  prev: TValue,
  config: PluginOptions,
  context: TContext
) => TValue

/** @internal */
export declare class ConfigResolutionError extends Error {
  name: string
  type: string
  causes: unknown[]
  constructor({causes, name, type}: ConfigResolutionErrorOptions)
}

/** @internal */
export declare interface ConfigResolutionErrorOptions {
  name: string
  type: string
  causes: Array<ConfigResolutionError | Error | unknown>
}

/** @internal */
export declare type ConnectedStatus = {
  type: 'connected'
  lastHeartbeat: Date
}

/** @internal */
export declare const CONNECTING: ConnectingStatus

/** @internal */
export declare type ConnectingStatus = {
  type: 'connecting'
}

/** @internal */
export declare type ConnectionState = 'connecting' | 'reconnecting' | 'connected'

/** @internal */
export declare type ConnectionStatus =
  | ConnectingStatus
  | ErrorStatus
  | ConnectedStatus
  | RetryingStatus

/** @internal */
export declare interface ConnectionStatusStore {
  connectionStatus$: Observable<ConnectionStatus>
}

/** @internal */
export declare interface ConnectionStatusStoreOptions {
  bifur: BifurClient
}

/** @internal */
export declare const ConnectorContext: Context<ConnectorContextValue>

/** @internal */
export declare interface ConnectorContextValue {
  isReviewChangesOpen: boolean
  onOpenReviewChanges: () => void | undefined
  onSetFocus: (nextPath: Path) => void | undefined
}

/** @internal */
export declare class CorsOriginError extends Error {
  projectId?: string
  constructor({projectId}: CorsOriginErrorOptions)
}

/** @internal */
export declare interface CorsOriginErrorOptions {
  projectId?: string
}

/**
 * @internal
 */
export declare const createAuthStore: typeof _createAuthStore & MemoizedFunction

/**
 * @internal
 */
export declare function _createAuthStore({
  clientFactory: clientFactoryOption,
  projectId,
  dataset,
  apiHost,
  loginMethod,
  ...providerOptions
}: AuthStoreOptions): AuthStore

/** @internal */
export declare const createBufferedDocument: (
  documentId: string,
  listenerEvent$: Observable<ListenerEvent>
) => BufferedDocumentWrapper

/**
 * @deprecated Use `defineConfig` instead
 *
 * @hidden
 * @beta
 */
export declare function createConfig<T extends Config>(config: T): T

/**
 * This is the beginning of what should be the data store tracking connection status in the Sanity studio.
 *
 * @internal
 */
export declare function createConnectionStatusStore({
  bifur,
}: ConnectionStatusStoreOptions): ConnectionStatusStore

/** @internal */
export declare function createDocumentPreviewStore({
  client,
}: DocumentPreviewStoreOptions): DocumentPreviewStore

/** @internal */
export declare function createDocumentStore({
  getClient,
  documentPreviewStore,
  historyStore,
  initialValueTemplates,
  schema,
}: DocumentStoreOptions): DocumentStore

/** @internal */
export declare function createDraftFrom(document: SanityDocument): SanityDocument

/** @internal */
export declare function createGrantsStore({client, currentUser}: GrantsStoreOptions): GrantsStore

/** @internal */
export declare function createHistoryStore({client}: HistoryStoreOptions): HistoryStore

/** @internal */
export declare function createHookFromObservableFactory<T, TArg = void>(
  observableFactory: (arg: TArg) => Observable<T>,
  initialValue: T
): ReactHook<TArg, LoadingTuple<T>>

/** @internal */
export declare function createHookFromObservableFactory<T, TArg = void>(
  observableFactory: (arg: TArg) => Observable<T>,
  initialValue?: T
): ReactHook<TArg, LoadingTuple<T | undefined>>

/**
 * Creates a mock `AuthStore` (for testing) that emits an `AuthState` derived
 * from the `client` and `currentUser` given.
 *
 * @internal
 */
export declare function createMockAuthStore({client, currentUser}: MockAuthStoreOptions): AuthStore

/** @internal */
export declare function createNoopTrackerScope<T>(): {
  useReportedValues: () => Reported<T>[]
  Tracker: typeof NoopTracker
  useReporter: (id: string | null, value: T | (() => T)) => void
}

/** @internal */
export declare const createObservableBufferedDocument: (
  listenerEvent$: Observable<ListenerEvent>
) => {
  updates$: Observable<SnapshotEvent | DocumentRebaseEvent | DocumentMutationEvent>
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotEvent>
  commitRequest$: Subject<CommitRequest>
  addMutation: (mutation: MutationPayload) => void
  addMutations: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @internal
 */
export declare function createPatchChannel(): PatchChannel

/**
 * @deprecated Use `definePlugin` instead
 *
 * @hidden
 * @beta
 */
export declare function createPlugin<TOptions = void>(
  arg: PluginFactory<TOptions> | PluginOptions
): Plugin_2<TOptions>

/** @internal */
export declare function createProjectStore(context: {client: SanityClient}): ProjectStore

/** @internal */
export declare function createPublishedFrom(document: SanityDocument): SanityDocument

/**
 * @hidden
 * @beta */
export declare function createSchema(schemaDef: {name: string; types: any[]}): Schema

/**
 * @internal
 */
export declare function createSearchQuery(
  searchTerms: SearchTerms,
  searchOpts?: SearchOptions & WeightedSearchOptions
): SearchQuery

/** @internal */
export declare function createSettingsStore(): SettingsStore

/** @internal */
export declare const createSharedResizeObserver: () => SharedResizeObserver

/**
 * PRIMARILY FOR TESTING PURPOSES.
 *
 * This will create a fully resolved source from a config and optionally
 * allows a `client` and `currentUser` override. This exists primarily for
 * testing purposes. If you need to use a source, we recommend using the
 * `useSource` hook to grab the fully resolved source from the `StudioProvider`
 *
 * @internal
 */
export declare function createSourceFromConfig(
  options: CreateWorkspaceFromConfigOptions
): Promise<Source>

/** @internal */
export declare function createTrackerScope<Value>(): {
  Tracker: (props: {children: React_2.ReactNode}) => JSX.Element
  useReportedValues: () => Reported<Value>[]
  useReporter: ReporterHook<Value>
  useAutoIdReporter: (value: Value | (() => Value), isEqual?: IsEqualFunction<Value>) => void
}

/** @internal */
export declare function createUserColorManager(options: UserColorManagerOptions): UserColorManager

/** @internal */
export declare function createUseReporter<Value>(
  Context: React_2.Context<TrackerContext<Value>>
): ReporterHook<Value>

/**
 * Given a `client` and a `currentUser` creates a datastore that handles
 * fetching, batch fetching, and caching users.
 *
 * @internal
 */
export declare function createUserStore({client: _client, currentUser}: UserStoreOptions): UserStore

/**
 * PRIMARILY FOR TESTING PURPOSES.
 *
 * This will create a fully resolved workspace from a config and optionally
 * allows a `client` and `currentUser` override. This exists primarily for
 * testing purposes. If you need to use a workspace, we recommend using the
 * `useWorkspace` hook to grab the fully resolved workspace from the
 * `StudioProvider`
 *
 * @internal
 */
export declare function createWorkspaceFromConfig(
  options: CreateWorkspaceFromConfigOptions
): Promise<Workspace>

/** @internal */
export declare type CreateWorkspaceFromConfigOptions =
  | SingleWorkspace
  | (SingleWorkspace & {
      currentUser: CurrentUser
      getClient: (options: {apiVersion: string}) => SanityClient
      schema?: SchemaPluginOptions
    })

/**
 *
 * @hidden
 * @beta
 */
export declare interface CrossDatasetReferenceComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<CrossDatasetReferenceValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<CrossDatasetReferenceInputProps>
  item?: ComponentType<ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function CrossDatasetReferenceInput(
  props: CrossDatasetReferenceInputProps
): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type CrossDatasetReferenceInputProps = ObjectInputProps<
  CrossDatasetReferenceValue,
  CrossDatasetReferenceSchemaType
>

/**
 *
 * @hidden
 * @beta
 */
export declare interface DateComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function DateInput(props: DateInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type DateInputProps = StringInputProps

/**
 *
 * @hidden
 * @beta
 */
export declare interface DatetimeComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function DateTimeInput(props: DateTimeInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type DateTimeInputProps = StringInputProps

/**
 * @hidden
 * @beta */
export declare function dec(amount?: number, path?: Path): FormDecPatch

/**
 * @internal
 */
export declare function decodePath(gradientPath: string): Path

/** @internal */
export declare const DEFAULT_MAX_RECURSION_DEPTH = 10

/**
 * Unless otherwise specified, this is the API version we use for controlled
 * requests on internal studio APIs. The user should always ask for a specific
 * API version when using the client - this way we can upgrade which version we
 * use internally without having the users code break unexpectedly. It also
 * means the user can easily upgrade to newer versions of GROQ when it arrives.
 *
 * @internal
 */
export declare const DEFAULT_STUDIO_CLIENT_OPTIONS: SourceClientOptions

/**
 * @hidden
 * @beta */
export declare function DefaultDocument(props: DefaultDocumentProps): React_2.ReactElement

/**
 * @hidden
 * @beta */
export declare interface DefaultDocumentProps {
  entryPath: string
  css?: string[]
  basePath?: string
}

declare type DefaultOperators = typeof searchOperators

/**
 * @hidden
 * @beta */
export declare function DefaultPreview(props: DefaultPreviewProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface DefaultPreviewProps
  extends Omit<PreviewProps<'default'>, 'renderDefault'> {
  styles?: {
    root?: string
    placeholder?: string
    media?: string
    heading?: string
    title?: string
    subtitle?: string
    hasSubtitle?: string
    mediaString?: string
    status?: string
    children?: string
  }
}

/** @internal */
export declare const defaultRenderAnnotation: RenderAnnotationCallback

/** @internal */
export declare const defaultRenderBlock: RenderBlockCallback

/** @internal */
export declare const defaultRenderField: RenderFieldCallback

/** @internal */
export declare const defaultRenderInlineBlock: RenderBlockCallback

/** @internal */
export declare const defaultRenderInput: RenderInputCallback

/** @internal */
export declare const defaultRenderItem: RenderItemCallback

/** @internal */
export declare const defaultRenderPreview: RenderPreviewCallback

/** @internal */
export declare function defaultTemplateForType(schemaType: SchemaType): Template

/** @internal */
export declare function defaultTemplatesForSchema(schema: Schema): Template[]

/** @internal */
export declare const defaultTheme: StudioTheme

/**
 * @hidden
 * @beta */
export declare function defineConfig<T extends Config>(config: T): T

/**
 * @hidden
 * @beta */
export declare function definePlugin<TOptions = void>(
  arg: PluginFactory<TOptions> | PluginOptions
): Plugin_2<TOptions>

/**
 * @alpha
 */
export declare function defineSearchFilter<TOperators = SearchOperatorType>(
  filterDef: SearchFilterDefinition<TOperators>
): typeof filterDef

/**
 * @alpha
 */
export declare function defineSearchFilterOperators<TOperators = SearchOperatorType>(
  operators: Operator<TOperators>[]
): typeof operators

/**
 * @alpha
 */
export declare function defineSearchOperator<
  TType extends string,
  TValue extends unknown | never,
  TOperatorSnippet extends
    | {
        type: TType
        inputComponent?: never
      }
    | {
        type: TType
        inputComponent: SearchOperatorInput<TValue>
      }
>(
  definition: (TOperatorSnippet extends {
    type: TType
    inputComponent: SearchOperatorInput<TValue>
  }
    ? SearchOperatorBuilder<TType, TValue>
    : ValuelessSearchOperatorBuilder<TType>) &
    TOperatorSnippet
): typeof definition

/**
 * @hidden
 * @beta */
export declare function DetailPreview(props: DetailPreviewProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type DetailPreviewProps = PreviewProps<'detail'>

/** @internal */
export declare type Diff<A = unknown, O extends object = Record<string, any>> =
  | ArrayDiff<A>
  | BooleanDiff
  | NullDiff
  | NumberDiff
  | ObjectDiff<O>
  | StringDiff
  | TypeChangeDiff

/** @internal */
export declare const DiffCard: React_2.ForwardRefExoticComponent<
  Omit<DiffCardProps & Omit<React_2.HTMLProps<HTMLElement>, 'height' | 'as'>, 'ref'> &
    React_2.RefAttributes<unknown>
>

/** @internal */
export declare interface DiffCardProps {
  annotation?: Annotation
  as?: React_2.ElementType | keyof JSX.IntrinsicElements
  diff?: Diff
  disableHoverEffect?: boolean
  path?: Path | string
  tooltip?:
    | {
        description?: React_2.ReactNode
      }
    | boolean
}

/**
 * Diff components
 *
 * @internal
 */
export declare type DiffComponent<T extends Diff = Diff> = ComponentType<DiffProps<T>>

/** @internal */
export declare type DiffComponentOptions<T extends Diff = Diff> = {
  component: DiffComponent<T>
  showHeader?: boolean
}

/**
 * Resolvers
 *
 * @internal
 */
export declare type DiffComponentResolver = (options: {
  schemaType: SchemaType
  parentSchemaType?: ArraySchemaType | ObjectSchemaType
}) => React.ComponentType<any> | DiffComponentOptions<any> | undefined

/** @internal */
export declare const DiffContext: Context<{
  path: Path
}>

/** @internal */
export declare class DiffErrorBoundary extends React_2.Component<
  DiffErrorBoundaryProps,
  DiffErrorBoundaryState
> {
  static getDerivedStateFromError(error: Error): {
    error: Error
  }
  state: DiffErrorBoundaryState
  componentDidCatch(error: Error): void
  render(): string | number | boolean | React_2.ReactFragment | JSX.Element | null | undefined
}

/** @internal */
export declare interface DiffErrorBoundaryProps {
  children: React_2.ReactNode
}

/** @internal */
export declare interface DiffErrorBoundaryState {
  error?: Error
}

/** @internal */
export declare function DiffFromTo(props: DiffFromToProps): JSX.Element

/** @internal */
export declare interface DiffFromToProps {
  align?: 'top' | 'center' | 'bottom'
  cardClassName?: string
  diff: Diff
  layout?: 'grid' | 'inline'
  path?: Path | string
  previewComponent: FieldPreviewComponent
  schemaType: SchemaType
}

/** @internal */
export declare function DiffInspectWrapper(
  props: DiffInspectWrapperProps & BoxProps
): React_2.ReactElement

/** @internal */
export declare interface DiffInspectWrapperProps {
  children: React_2.ReactNode
  change: FieldChangeNode
  as?: StyledComponent<'div', DefaultTheme>
}

/**
 * @hidden
 * @beta */
export declare function diffMatchPatch(value: string, path?: Path): FormDiffMatchPatch

/** @internal */
export declare type DiffPatch = SetDiffPatch | UnsetDiffPatch | InsertDiffPatch

/** @internal */
export declare type DiffProps<T extends Diff = Diff> = {
  diff: T
  schemaType: T extends ObjectDiff
    ? ObjectSchemaType
    : T extends ArrayDiff
    ? ArraySchemaType
    : T extends BooleanDiff
    ? BooleanSchemaType
    : T extends StringDiff
    ? StringSchemaType
    : T extends NumberDiff
    ? NumberSchemaType
    : SchemaType
}

/** @internal */
export declare const diffResolver: DiffComponentResolver

/** @internal */
export declare function DiffString(props: {diff: StringDiff}): JSX.Element

/** @internal */
export declare function DiffStringSegment(props: {segment: StringDiffSegment}): React_2.ReactElement

/** @internal */
export declare function DiffTooltip(
  props: DiffTooltipProps | DiffTooltipWithAnnotationsProps
): JSX.Element

/** @internal */
export declare interface DiffTooltipProps extends TooltipProps {
  children: React_2.ReactElement
  description?: React_2.ReactNode
  diff: Diff
  path?: Path | string
}

/** @internal */
export declare interface DiffTooltipWithAnnotationsProps extends TooltipProps {
  annotations: AnnotationDetails[]
  children: React_2.ReactElement
  description?: React_2.ReactNode
}

/** @internal */
export declare type DiffVisitor = (diff: Diff | StringDiffSegment, path: Path) => boolean

/** @internal */
export declare function DisabledChangeConnectorRoot({
  children,
  className,
}: DisabledChangeConnectorRootProps): JSX.Element

/** @internal */
export declare interface DisabledChangeConnectorRootProps {
  className?: string
  children: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionComponent extends ActionComponent<DocumentActionProps> {
  /**
   * An optional meta property that can used to replace this document action
   * with another. E.g.:
   *
   * ```js
   * import {defineConfig} from 'sanity'
   * import {MyPublishAction} from '...'
   *
   * export default defineConfig({
   *   document: {
   *     actions: (prev) =>
   *       prev.map((previousAction) =>
   *         previousAction.action === 'publish' ? MyPublishAction : previousAction
   *       ),
   *   },
   * })
   * ```
   */
  action?: 'delete' | 'discardChanges' | 'duplicate' | 'restore' | 'publish' | 'unpublish'
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionConfirmDialogProps {
  type: 'confirm'
  tone?: ButtonTone
  message: React_2.ReactNode
  onConfirm: () => void
  onCancel: () => void
  cancelButtonIcon?: React_2.ComponentType | React_2.ReactNode
  cancelButtonText?: React_2.ReactNode
  confirmButtonIcon?: React_2.ComponentType | React_2.ReactNode
  confirmButtonText?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionCustomDialogComponentProps {
  type: 'custom'
  component: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionDescription {
  tone?: ButtonTone
  dialog?: DocumentActionDialogProps | false | null
  disabled?: boolean
  icon?: React_2.ReactNode | React_2.ComponentType
  label: string
  onHandle?: () => void
  shortcut?: string | null
  title?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare type DocumentActionDialogProps =
  | DocumentActionConfirmDialogProps
  | DocumentActionPopoverDialogProps
  | DocumentActionModalDialogProps
  | DocumentActionCustomDialogComponentProps

/**
 * @hidden
 * @beta */
export declare interface DocumentActionModalDialogProps {
  type?: 'dialog'
  content: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  footer?: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  header?: React_2.ReactNode
  onClose: () => void
  showCloseButton?: boolean
  /**
   *
   * @hidden
   * @beta
   */
  width?: 'small' | 'medium' | 'large' | 'full'
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionPopoverDialogProps {
  type: 'popover'
  content: React_2.ReactNode
  onClose: () => void
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionProps extends EditStateFor {
  revision?: string
  onComplete: () => void
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionsContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta */
export declare type DocumentActionsResolver = ComposableOption<
  DocumentActionComponent[],
  DocumentActionsContext
>

/**
 * @hidden
 * @beta */
export declare type DocumentAvailability =
  | {
      available: true
      reason: 'READABLE'
    }
  | {
      available: false
      reason: 'PERMISSION_DENIED' | 'NOT_FOUND'
    }

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgeComponent {
  (props: DocumentBadgeProps): DocumentBadgeDescription | null
}

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgeDescription {
  title?: string
  label?: string | undefined
  color?: 'primary' | 'success' | 'warning' | 'danger'
  icon?: React.ReactNode | React.ComponentType
}

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgeProps extends EditStateFor {}

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgesContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta */
export declare type DocumentBadgesResolver = ComposableOption<
  DocumentBadgeComponent[],
  DocumentBadgesContext
>

/** @internal */
export declare const DocumentChangeContext: Context<DocumentChangeContextInstance | null>

/** @internal */
export declare type DocumentChangeContextInstance = {
  documentId: string
  schemaType: SchemaType
  rootDiff: ObjectDiff | null
  isComparingCurrent: boolean
  FieldWrapper: React.ComponentType<{
    path: Path
    children: React.ReactNode
    hasHover: boolean
  }>
  value: Partial<SanityDocument>
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface DocumentComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps>
  input?: ComponentType<ObjectInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type DocumentFormNode<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType
> = ObjectFormNode<T, S>

/**
 * Checks if the document ID `documentId` has the same ID as `equalsDocumentId`,
 * if you discard the draft status of the given IDs. Examples:
 *
 * @example
 * Draft vs published document ID, but representing the same document:
 * ```
 * // Prints "true":
 * console.log(documentIdEquals('drafts.agot', 'agot'));
 * ```
 * @example
 * Different documents:
 * ```
 * // Prints "false":
 * console.log(documentIdEquals('hp-tcos', 'hp-hbp'));
 * ```
 *
 * @public
 */
export declare function documentIdEquals(documentId: string, equalsDocumentId: string): boolean

/**
 *
 * @hidden
 * @beta
 */
export declare type DocumentLanguageFilterComponent = ComponentType<{
  schemaType: ObjectSchemaType
}>

/**
 *
 * @hidden
 * @beta
 */
export declare interface DocumentLanguageFilterContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare type DocumentLanguageFilterResolver = ComposableOption<
  DocumentLanguageFilterComponent[],
  DocumentLanguageFilterContext
>

/**
 * @hidden
 * @beta */
export declare interface DocumentMutationEvent {
  type: 'mutation'
  document: SanityDocument
  mutations: MutationPayload[]
  origin: 'local' | 'remote'
}

/** @internal */
export declare interface DocumentPairPermissionsOptions {
  client: SanityClient
  schema: Schema
  grantsStore: GrantsStore
  id: string
  type: string
  permission: DocumentPermission
}

/** @internal */
export declare type DocumentPermission =
  | 'delete'
  | 'discardDraft'
  | 'publish'
  | 'unpublish'
  | 'update'
  | 'duplicate'

/**
 * @hidden
 * @beta */
export declare interface DocumentPluginOptions {
  badges?: DocumentBadgeComponent[] | DocumentBadgesResolver
  actions?: DocumentActionComponent[] | DocumentActionsResolver
  /**
   * @hidden
   * @beta */
  productionUrl?: AsyncComposableOption<string | undefined, ResolveProductionUrlContext>
  /**
   * @hidden
   * @beta */
  unstable_languageFilter?: DocumentLanguageFilterResolver
  /**
   * @hidden
   * @beta */
  newDocumentOptions?: NewDocumentOptionsResolver
}

/** @internal */
export declare interface DocumentPresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
}

/** @internal */
export declare function DocumentPreviewPresence(props: DocumentPreviewPresenceProps): JSX.Element

/** @internal */
export declare interface DocumentPreviewPresenceProps {
  presence: Omit<DocumentPresence, 'path'>[]
}

/**
 * @hidden
 * @beta */
export declare interface DocumentPreviewStore {
  observePaths: ObservePathsFn
  observeForPreview: ObserveForPreviewFn
  observeDocumentTypeFromId: (id: string, apiConfig?: ApiConfig) => Observable<string | undefined>
  /**
   *
   * @hidden
   * @beta
   */
  unstable_observeDocumentPairAvailability: (
    id: string
  ) => Observable<DraftsModelDocumentAvailability>
  unstable_observePathsDocumentPair: <T extends SanityDocument = SanityDocument>(
    id: string,
    paths: PreviewPath[]
  ) => Observable<DraftsModelDocument<T>>
}

/** @internal */
export declare interface DocumentPreviewStoreOptions {
  client: SanityClient
}

/**
 * @hidden
 * @beta */
export declare interface DocumentRebaseEvent {
  type: 'rebase'
  document: SanityDocument
  remoteMutations: MutationPayload[]
  localMutations: MutationPayload[]
}

/**
 * @hidden
 * @beta */
export declare interface DocumentRemoteMutationEvent {
  type: 'remoteMutation'
  head: SanityDocument
  transactionId: string
  author: string
  timestamp: Date
  effects: {
    apply: unknown
    revert: unknown
  }
}

/**
 * @hidden
 * @beta */
export declare type DocumentRemoteMutationVersionEvent = Exclude<
  RemoteSnapshotVersionEvent,
  {
    type: 'snapshot'
  }
>

/**
 * @hidden
 * @beta */
export declare interface DocumentStore {
  /** @internal */
  checkoutPair: (idPair: IdPair) => Pair
  initialValue: (
    opts: InitialValueOptions,
    context: InitialValueResolverContext
  ) => Observable<InitialValueMsg>
  listenQuery: (
    query:
      | string
      | {
          fetch: string
          listen: string
        },
    params: QueryParams,
    options: ListenQueryOptions
  ) => Observable<any>
  resolveTypeForDocument: (id: string, specifiedType?: string) => Observable<string>
  pair: {
    consistencyStatus: (publishedId: string, type: string) => Observable<boolean>
    /** @internal */
    documentEvents: (publishedId: string, type: string) => Observable<DocumentVersionEvent>
    /** @internal */
    editOperations: (publishedId: string, type: string) => Observable<OperationsAPI>
    editState: (publishedId: string, type: string) => Observable<EditStateFor>
    operationEvents: (
      publishedId: string,
      type: string
    ) => Observable<OperationSuccess | OperationError>
    validation: (publishedId: string, type: string) => Observable<ValidationStatus>
  }
}

/** @internal */
export declare interface DocumentStoreOptions {
  getClient: (options: SourceClientOptions) => SanityClient
  documentPreviewStore: DocumentPreviewStore
  historyStore: HistoryStore
  schema: Schema
  initialValueTemplates: Template[]
}

/** @internal */
export declare interface DocumentTypeResolveState {
  isLoaded: boolean
  documentType: string | undefined
}

/**
 * @hidden
 * @beta */
export declare type DocumentValuePermission =
  | 'read'
  | 'create'
  | 'update'
  | 'history'
  | 'editHistory'

/** @internal */
export declare interface DocumentValuePermissionsOptions {
  grantsStore: GrantsStore
  document: Record<string, unknown>
  permission: DocumentValuePermission
}

/**
 * @hidden
 * @beta */
export declare interface DocumentVersion {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotVersionEvent>
  events: Observable<DocumentVersionEvent>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @hidden
 * @beta */
export declare type DocumentVersionEvent = WithVersion<ReconnectEvent | BufferedDocumentEvent>

/** @internal */
export declare interface DocumentVersionSnapshots {
  snapshots$: Observable<SanityDocument>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: any) => MutationPayload
  createIfNotExists: (document: any) => MutationPayload
  createOrReplace: (document: any) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/** @internal */
export declare type DraftId = Opaque<string, 'draftId'>

/** @internal */
export declare const DRAFTS_FOLDER = 'drafts'

/**
 * @hidden
 * @beta */
export declare interface DraftsModelDocument<T extends SanityDocumentLike = SanityDocumentLike> {
  id: string
  type: string | null
  draft: {
    availability: DocumentAvailability
    snapshot: T | undefined
  }
  published: {
    availability: DocumentAvailability
    snapshot: T | undefined
  }
}

/**
 * @hidden
 * @beta */
export declare interface DraftsModelDocumentAvailability {
  /**
   * document readability for the published document
   */
  published: DocumentAvailability
  /**
   * document readability for the draft document
   */
  draft: DocumentAvailability
}

/**
 * This error may happen for arrays of objects where one or more of the members are having duplicate keys
 *
 * @public
 */
export declare type DuplicateKeysError = {
  type: 'DUPLICATE_KEYS'
  schemaType: ArraySchemaType
  duplicates: [index: number, key: string][]
}

/** @internal */
export declare interface EditReferenceLinkComponentProps {
  documentId: string
  documentType: string
  parentRefPath: Path
  template?: TemplateOption
  children: React_2.ReactNode
}

/**
 * @internal
 */
export declare interface EditReferenceOptions {
  id: string
  type: string
  parentRefPath: Path
  template: TemplateOption
}

/** @internal */
export declare const editState: (
  arg1: {
    client: SanityClient
    schema: Schema
  },
  arg2: IdPair,
  arg3: string
) => Observable<EditStateFor>

/**
 * @hidden
 * @beta */
export declare interface EditStateFor {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState | null
  draft: SanityDocument | null
  published: SanityDocument | null
  liveEdit: boolean
  ready: boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface EmailComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function EmailInput(props: EmailInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type EmailInputProps = StringInputProps

/** @internal */
export declare function emitOperation(
  operationName: keyof OperationsAPI,
  idPair: IdPair,
  typeName: string,
  extraArgs: any[]
): void

/** @internal */
export declare const EMPTY_ARRAY: never[]

/** @internal */
export declare const EMPTY_OBJECT: Record<string, unknown>

/** @internal */
export declare function EnabledChangeConnectorRoot({
  children,
  className,
  isReviewChangesOpen,
  onOpenReviewChanges,
  onSetFocus,
  ...restProps
}: EnabledChangeConnectorRootProps): JSX.Element

/** @internal */
export declare interface EnabledChangeConnectorRootProps {
  children: React_2.ReactNode
  className?: string
  isReviewChangesOpen: boolean
  onOpenReviewChanges: () => void
  onSetFocus: (path: Path) => void
}

/**
 * @internal
 */
export declare function encodePath(formBuilderPath: Path): string

/** @internal */
export declare interface ErrorState {
  value: undefined
  error: Error
  isLoading: false
}

/** @internal */
export declare type ErrorStatus = {
  type: 'error'
  error: Error
  attemptNo: number
  isOffline: boolean
  retryAt: Date
}

/** @internal */
export declare const escapeField: (fieldName: string) => string

/** @internal */
export declare interface EvaluationParams {
  identity?: string
}

declare interface ExecuteArgs {
  operationName: keyof OperationsAPI
  idPair: IdPair
  typeName: string
  extraArgs: any[]
}

/** @internal */
export declare interface ExpandFieldSetOperation {
  type: 'expandFieldSet'
  path: Path
}

/** @internal */
export declare type ExpandOperation =
  | ExpandPathOperation
  | ExpandFieldSetOperation
  | SetActiveGroupOperation

/** @internal */
export declare interface ExpandPathOperation {
  type: 'expandPath'
  path: Path
}

/** @internal */
export declare const FallbackDiff: DiffComponent<Diff<unknown, Record<string, unknown>>>

/** @internal */
export declare function FieldChange(
  props: {
    change: FieldChangeNode
    readOnly?: boolean
    hidden?: boolean
  } & React_2.HTMLAttributes<HTMLDivElement>
): JSX.Element | null

/** @internal */
export declare interface FieldChangeNode {
  type: 'field'
  diff: Diff
  itemDiff?: ItemDiff
  parentDiff?: ObjectDiff | ArrayDiff
  key: string
  path: Path
  error?: FieldValueError
  titlePath: ChangeTitlePath
  schemaType: ObjectFieldType
  showHeader: boolean
  showIndex: boolean
  diffComponent?: DiffComponent
  parentSchema?: ArraySchemaType | ObjectSchemaType
  readOnly?: ConditionalProperty
  hidden?: ConditionalProperty
}

/** @public */
export declare interface FieldError {
  kind: 'error'
  key: string
  fieldName: string
  error:
    | IncompatibleTypeError
    | TypeAnnotationMismatchError
    | MissingKeysError
    | DuplicateKeysError
    | UndeclaredMembersError
    | MixedArrayError
}

/** @public */
export declare interface FieldMember<Node extends BaseFormNode = BaseFormNode> {
  kind: 'field'
  key: string
  name: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean
  /**
   * @internal
   * Whether this field is in the selected group
   */
  inSelectedGroup: boolean
  /**
   * @internal
   * Names of the field groups this field is part of
   */
  groups: string[]
  /**
   * @hidden
   * @beta */
  field: Node
}

/**
 * @hidden
 * @beta */
export declare type FieldName = string

/** @internal */
export declare const fieldNeedsEscape: (fieldName: string) => boolean

/** @internal */
export declare interface FieldOperationsAPI {
  patch: {
    execute: (patches: PatchOperations[]) => void
  }
}

/** @internal */
export declare const FieldPresence: typeof FieldPresenceWithoutOverlay

/** @internal */
export declare type FieldPresenceData = {
  element: HTMLElement
  presence: FormNodePresence[]
  maxAvatars: number
}

/** @internal */
export declare const FieldPresenceInner: React_2.NamedExoticComponent<FieldPresenceInnerProps>

/** @internal */
export declare interface FieldPresenceInnerProps {
  maxAvatars?: number
  presence: FormNodePresence[]
  stack?: boolean
  position?: AvatarPosition
  animateArrowFrom?: AvatarPosition
}

/** @internal */
export declare interface FieldPresenceProps {
  presence: FormNodePresence[]
  maxAvatars: number
}

/** @internal */
export declare function FieldPresenceWithoutOverlay(props: FieldPresenceProps): JSX.Element | null

/** @internal */
export declare function FieldPresenceWithOverlay(props: FieldPresenceProps): JSX.Element

/** @internal */
export declare type FieldPreviewComponent<T = any> = ComponentType<{
  color?: UserColor
  schemaType: T extends Array<any>
    ? ArraySchemaType
    : T extends boolean
    ? BooleanSchemaType
    : T extends string
    ? StringSchemaType
    : T extends number
    ? NumberSchemaType
    : T extends Reference
    ? ReferenceSchemaType
    : T extends object
    ? ObjectSchemaType
    : any
  value: T
}>

/**
 * @hidden
 * @beta */
export declare type FieldProps =
  | ObjectFieldProps
  | ObjectFieldProps<CrossDatasetReferenceValue>
  | ObjectFieldProps<FileValue>
  | ObjectFieldProps<GeopointValue>
  | ObjectFieldProps<ImageValue>
  | ObjectFieldProps<ReferenceValue>
  | ObjectFieldProps<SlugValue>
  | ArrayFieldProps
  | NumberFieldProps
  | BooleanFieldProps
  | StringFieldProps

/** @public */
export declare interface FieldSetMember {
  kind: 'fieldSet'
  key: string
  _inSelectedGroup: boolean
  groups: string[]
  /**
   * @hidden
   * @beta */
  fieldSet: FieldsetState
}

/**
 * @hidden
 * @beta */
export declare interface FieldsetState {
  path: Path
  name: string
  level: number
  title?: string
  description?: string
  hidden?: boolean
  collapsible?: boolean
  collapsed?: boolean
  columns?: number | number[]
  members: (FieldMember | FieldError)[]
}

/** @internal */
export declare interface FieldStatusProps {
  children?: React_2.ReactNode
  maxAvatars?: number
  position?: 'top' | 'bottom'
}

/** @internal */
export declare interface FieldValueError {
  message: string
  value: unknown
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FileComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<FileValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps<FileValue>>
  item?: ComponentType<ObjectItemProps<FileValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function FileInput(props: FileInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type FileInputProps = Omit<
  BaseFileInputProps,
  'assetSources' | 'directUploads' | 'observeAsset' | 'resolveUploader' | 'client'
>

/**
 *
 * @hidden
 * @beta
 */
export declare interface FileLike {
  type: string
  name?: string
}

/** @internal */
export declare function findIndex(array: unknown[], segment: PathSegment): number

/** @internal */
export declare type FIXME = any

/** @internal */
export declare type FIXME_SanityDocument = Record<string, unknown>

/**
 * @internal
 *
 * This function flattens the config tree into a list of configs in the order they should be applied.
 */
export declare const flattenConfig: (
  {plugins, ...currentConfig}: PluginOptions,
  path: string[]
) => {
  config: PluginOptions
  path: string[]
}[]

/**
 * @alpha
 */
export declare function FormBuilder(props: FormBuilderProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type FormBuilderArrayFunctionComponent = React_2.ComponentType<
  ArrayInputFunctionsProps<unknown, ArraySchemaType>
>

/** @internal */
export declare interface FormBuilderComponentResolverContext extends ConfigContext {
  schemaType: SchemaType
}

/**
 * @internal
 */
export declare const FormBuilderContext: Context<FormBuilderContextValue | null>

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormBuilderContextValue {
  /**
   * @deprecated INTERNAL USE ONLY
   * @internal
   */
  __internal: {
    components: {
      CustomMarkers: FormBuilderCustomMarkersComponent
      Markers: FormBuilderMarkersComponent
    }
    file: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    filterField: FormBuilderFilterFieldFn
    image: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    getDocument: () => SanityDocument | undefined
    patchChannel: PatchChannel
  }
  autoFocus?: boolean
  changesOpen?: boolean
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  focusPath: Path
  focused?: boolean
  groups: FormFieldGroup[]
  id: string
  members: ObjectMember[]
  readOnly?: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
  value:
    | {
        [field in string]: unknown
      }
    | undefined
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormBuilderCustomMarkersComponent = React_2.ComponentType<{
  markers: PortableTextMarker[]
}>

/**
 * @internal
 */
export declare interface FormBuilderFilterFieldFn {
  (type: ObjectSchemaType, field: ObjectField, selectedLanguageIds: string[]): boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormBuilderInputComponentMap = Record<
  string,
  {
    field?: React_2.ComponentType<FieldProps>
    item?: React_2.ComponentType<ItemProps>
    input?: React_2.ComponentType<InputProps>
    preview?: React_2.ComponentType<PreviewProps>
  }
>

/**
 *
 * @hidden
 * @beta
 */
export declare type FormBuilderMarkersComponent = React_2.ComponentType<{
  markers: PortableTextMarker[]
  renderCustomMarkers?: RenderCustomMarkers
  validation: FormNodeValidation[]
}>

/**
 * @alpha
 */
export declare interface FormBuilderProps
  extends Omit<ObjectFormNode, 'level' | 'path' | 'presence' | 'validation' | '_allMembers'> {
  /**
   * @internal Considered internal – do not use.
   */
  __internal_patchChannel: PatchChannel
  autoFocus?: boolean
  changesOpen?: boolean
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  focusPath: Path
  focused: boolean | undefined
  id: string
  onChange: (changeEvent: PatchEvent) => void
  onPathBlur: (path: Path) => void
  onPathFocus: (path: Path) => void
  onPathOpen: (path: Path) => void
  onFieldGroupSelect: (path: Path, groupName: string) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  presence: FormNodePresence[]
  readOnly?: boolean
  schemaType: ObjectSchemaType
  validation: ValidationMarker[]
  value:
    | {
        [field in string]: unknown
      }
    | undefined
}

/**
 * @internal
 */
export declare const FormCallbacksContext: React_2.Context<FormCallbacksValue | null>

/** @internal */
export declare const FormCallbacksProvider: React_2.NamedExoticComponent<
  FormCallbacksValue & {
    children: React_2.ReactNode
  }
>

/** @internal */
export declare interface FormCallbacksValue {
  transformPatches?: (patches: FormPatch[]) => FormPatch[]
  onChange: (patchEvent: PatchEvent) => void
  onPathFocus: (path: Path) => void
  onPathBlur: (path: Path) => void
  onPathOpen: (path: Path) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  onFieldGroupSelect: (path: Path, fieldGroupName: string) => void
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormDecPatch extends FormPatchBase {
  path: Path
  type: 'dec'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormDiffMatchPatch extends FormPatchBase {
  path: Path
  type: 'diffMatchPatch'
  origin?: FormPatchOrigin
  value: string
}

/** @internal */
export declare const FormField: React_2.NamedExoticComponent<
  FormFieldProps & Omit<React_2.HTMLProps<HTMLDivElement>, 'ref' | 'height' | 'as'>
>

/**
 * @hidden
 * @beta */
export declare interface FormFieldGroup {
  name: string
  selected?: boolean
  disabled?: boolean
  title?: string
  icon?: React_2.ComponentType
}

/** @internal */
export declare const FormFieldHeaderText: React_2.NamedExoticComponent<FormFieldHeaderTextProps>

/** @internal */
export declare interface FormFieldHeaderTextProps {
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
  description?: React_2.ReactNode
  /**
   * The unique ID used to target the actual input element
   */
  inputId?: string
  title?: React_2.ReactNode
}

/** @internal */
export declare const FormFieldPresenceContext: React_2.Context<FormNodePresence[]>

/** @internal */
export declare interface FormFieldProps {
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
  /**
   *
   * @hidden
   * @beta
   */
  __unstable_presence?: FormNodePresence[]
  children: React_2.ReactNode
  description?: React_2.ReactNode
  /**
   * The unique ID used to target the actual input element
   */
  inputId?: string
  /**
   * The nesting level of the form field
   */
  level?: number
  title?: React_2.ReactNode
}

/** @internal */
export declare const FormFieldSet: React_2.ForwardRefExoticComponent<
  FormFieldSetProps &
    Omit<React_2.HTMLProps<HTMLDivElement>, 'ref' | 'height' | 'as'> &
    React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface FormFieldSetProps {
  /**
   *
   * @hidden
   * @beta
   */
  __unstable_presence?: FormNodePresence[]
  children: React_2.ReactNode | (() => React_2.ReactNode)
  collapsed?: boolean
  collapsible?: boolean
  columns?: number | number[]
  description?: React_2.ReactNode
  /**
   * The nesting level of the form field set
   */
  level?: number
  onCollapse?: () => void
  onExpand?: () => void
  title?: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
}

/** @internal */
export declare function FormFieldStatus({
  children,
  maxAvatars,
  position,
}: FieldStatusProps): JSX.Element

/** @internal */
export declare type FormFieldValidation =
  | FormFieldValidationWarning
  | FormFieldValidationError
  | FormFieldValidationInfo

/** @internal */
export declare interface FormFieldValidationError {
  type: 'error'
  label: string
}

/** @internal */
export declare interface FormFieldValidationInfo {
  type: 'info'
  label: string
}

/** @internal */
export declare function FormFieldValidationStatus(
  props: FormFieldValidationStatusProps
): JSX.Element

/** @internal */
export declare interface FormFieldValidationStatusProps {
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
  /**
   *
   * @hidden
   * @beta
   */
  __unstable_showSummary?: boolean
  fontSize?: number | number
  placement?: Placement
}

/** @internal */
export declare interface FormFieldValidationWarning {
  type: 'warning'
  label: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormIncPatch extends FormPatchBase {
  path: Path
  type: 'inc'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/** @internal */
export declare const FormInput: React_2.NamedExoticComponent<
  (
    | ArrayOfObjectsInputProps<
        {
          _key: string
        },
        ArraySchemaType<unknown>
      >
    | ObjectInputProps<Record<string, any>, ObjectSchemaType>
  ) &
    (FormInputAbsolutePathArg | FormInputRelativePathArg) & {
      /**
       * Whether to include the field around the input. Defaults to false
       */
      includeField?: boolean | undefined
    }
>

/** @internal */
export declare type FormInputAbsolutePathArg = {
  absolutePath: Path
}

/** @internal */
export declare type FormInputRelativePathArg = {
  relativePath: Path
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormInsertPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'insert'
  position: FormInsertPatchPosition
  items: FormPatchJSONValue[]
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormInsertPatchPosition = 'before' | 'after'

/**
 * @hidden
 * @beta */
export declare interface FormNodePresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormPatch =
  | FormSetPatch
  | FormSetIfMissingPatch
  | FormUnsetPatch
  | FormInsertPatch
  | FormDiffMatchPatch

/**
 * @hidden
 * @beta */
export declare interface FormPatchBase {
  /**
   * A property used to identify this as a Sanity patch type, eg "set", "unset", "insert", etc.
   * This allows us to potentially introduce new patch types in the future without breaking
   * existing code. This is an internal property/implementation detail and should not be used by
   * consumers.
   *
   * @internal
   */
  patchType: symbol
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormPatchJSONValue =
  | number
  | string
  | boolean
  | {
      [key: string]: FormPatchJSONValue
    }
  | FormPatchJSONValue[]

/**
 *
 * @hidden
 * @beta
 */
export declare type FormPatchOrigin = 'remote' | 'local' | 'internal'

/**
 * Default wiring for `FormBuilderProvider` when used with Sanity
 *
 * @alpha This API might change.
 */
export declare function FormProvider(props: FormProviderProps): JSX.Element

/**
 * @alpha This API might change.
 */
export declare interface FormProviderProps {
  /**
   * @internal Considered internal, do not use.
   */
  __internal_patchChannel: PatchChannel
  autoFocus?: boolean
  changesOpen?: boolean
  children?: React_2.ReactNode
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  focusPath: Path
  focused: boolean | undefined
  groups: FormFieldGroup[]
  id: string
  members: ObjectMember[]
  onChange: (changeEvent: PatchEvent) => void
  onPathBlur: (path: Path) => void
  onPathFocus: (path: Path) => void
  onPathOpen: (path: Path) => void
  onFieldGroupSelect: (path: Path, groupName: string) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  presence: FormNodePresence[]
  readOnly?: boolean
  schemaType: ObjectSchemaType
  validation: ValidationMarker[]
  value:
    | {
        [field in string]: unknown
      }
    | undefined
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormSetIfMissingPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'setIfMissing'
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormSetPatch extends FormPatchBase {
  path: Path
  type: 'set'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/** @internal */
export declare type FormState<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType
> = ObjectFormNode<T, S>

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormUnsetPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'unset'
}

/**
 * @internal
 */
export declare function fromMutationPatches(
  origin: FormPatchOrigin,
  patches: MutationPatch[]
): FormPatch[]

/** @internal */
export declare const FromTo: React_2.ForwardRefExoticComponent<
  Omit<FromToProps, 'ref'> & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare function FromToArrow(
  props: {
    direction?: FromToArrowDirection
  } & TextProps &
    Omit<React_2.HTMLProps<HTMLDivElement>, 'children' | 'ref'>
): JSX.Element

/** @internal */
export declare type FromToArrowDirection = 'down' | 'right'

/** @internal */
export declare interface FromToIndex {
  hasMoved: boolean
  fromIndex?: number
  toIndex?: number
  annotation?: Annotation
}

/** @internal */
export declare type FromToProps = {
  align?: 'top' | 'center' | 'bottom'
  layout?: 'grid' | 'inline'
  from?: React_2.ReactNode
  to?: React_2.ReactNode
} & Omit<React_2.HTMLProps<HTMLDivElement>, 'children' | 'as' | 'height' | 'wrap'>

/**
 * @hidden
 * @beta */
export declare type GeneralPreviewLayoutKey = 'default' | 'media' | 'detail'

/**
 *
 * @hidden
 * @beta
 */
export declare interface GeopointComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<GeopointValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps<GeopointValue>>
  item?: ComponentType<ObjectItemProps<GeopointValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare function getAnnotationAtPath(
  diff: Diff,
  diffPath: string | Path
): Annotation | undefined

/** @internal */
export declare function getAnnotationColor(
  colorManager: UserColorManager,
  annotation?: Annotation | null
): UserColor

/** @internal */
export declare function getChangeVerb(diff: Diff): 'Added' | 'Removed' | 'Changed'

/**
 * Reduce a {@link Source} down to a {@link ConfigContext}, without memoization - use for non-react contexts
 *
 * @param source - Source to convert
 * @returns A config context containing only the defined properties of that interface
 * @internal
 */
export declare function getConfigContextFromSource(source: Source): ConfigContext

/** @internal */
export declare function getDiffAtPath(diff: Diff, diffPath: string | Path): Diff | undefined

/**
 * The observable version of `useDocumentPairPermissions`
 *
 * @see useDocumentPairPermissions
 *
 * @internal
 */
export declare function getDocumentPairPermissions({
  client,
  grantsStore,
  schema,
  id,
  permission,
  type,
}: DocumentPairPermissionsOptions): Observable<PermissionCheckResult>

/**
 * The observable version of `useDocumentValuePermissions`
 *
 * @see useDocumentValuePermissions
 *
 * @internal
 */
export declare function getDocumentValuePermissions({
  grantsStore,
  document,
  permission,
}: DocumentValuePermissionsOptions): Observable<PermissionCheckResult>

/** @internal */
export declare function getDraftId(id: string): DraftId

/**
 * This takes a form state and returns a list of operations required to open a node at a particular path
 * @param node - The base form node (i.e. the form state node for the _document_)
 * @param path - The path to open
 *
 * @internal
 */
export declare function getExpandOperations(node: BaseFormNode, path: Path): ExpandOperation[]

/** @internal */
export declare function GetHookCollectionState<T, K>(
  props: GetHookCollectionStateProps<T, K>
): JSX.Element

/** @internal */
export declare interface GetHookCollectionStateProps<T, K> {
  args: T
  children: (props: {states: K[]}) => React_2.ReactNode
  hooks: ActionHook<T, K>[]
  onReset?: () => void
}

/** @internal */
export declare function getIdPair(id: string): {
  draftId: DraftId
  publishedId: PublishedId
}

/**
 * @internal
 */
export declare function getInitialValueStream(
  schema: Schema,
  initialValueTemplates: Template[],
  documentPreviewStore: DocumentPreviewStore,
  opts: InitialValueOptions,
  context: InitialValueResolverContext
): Observable<InitialValueMsg>

/** @internal */
export declare function getItemKey(arrayItem: unknown): string | undefined

/** @internal */
export declare function getItemKeySegment(arrayItem: unknown): KeyedSegment | undefined

/** @internal */
export declare function getNamelessWorkspaceIdentifier(
  title: string | undefined,
  index: number
): string

/** @internal */
export declare function getPairListener(
  client: SanityClient,
  idPair: IdPair,
  options?: PairListenerOptions
): Observable<ListenerEvent>

/** @internal */
export declare function getPreviewPaths(preview: SchemaType['preview']): PreviewPath[] | undefined

/**
 * Obtain a document's published and draft state, along with loading status.
 *
 * @internal
 */
export declare function getPreviewStateObservable(
  documentPreviewStore: DocumentPreviewStore,
  schemaType: SchemaType,
  documentId: string,
  title: React_2.ReactNode
): Observable<PreviewState>

/**
 * Obtain document preview values used in <SanityPreview> and <SanityDefaultPreview> components.
 * Also displays fallback values if the document cannot be found.
 *
 * @internal
 */
export declare const getPreviewValueWithFallback: ({
  value,
  draft,
  published,
}: {
  value: SanityDocument
  draft?: PreviewValue | Partial<SanityDocument> | null | undefined
  published?: PreviewValue | Partial<SanityDocument> | null | undefined
}) =>
  | PreviewValue
  | {
      title: JSX.Element
      subtitle: JSX.Element
      media: () => JSX.Element
    }

/** @internal */
export declare function getProviderTitle(provider?: string): string | undefined

/** @internal */
export declare function getPublishedId(id: string): PublishedId

/**
 * Get the most specific defined title of a schema type
 * If not set directly on the given type, it will traverse up the tree until it
 * finds one, falling back to the _name_ of the type.
 *
 * @param type - The schema type to get the title of
 * @returns A title, alternatively the schema type _name_
 * @internal
 */
export declare function getSchemaTypeTitle(type: SchemaType): string

/**
 * The observable version of `useTemplatePermissions`
 *
 * @internal
 */
export declare function getTemplatePermissions({
  grantsStore,
  templateItems,
  templates,
  schema,
  context,
}: TemplatePermissionsOptions): Observable<
  Array<TemplatePermissionsResult<Record<string, unknown>>>
>

/** @internal */
export declare function getValueAtPath(rootValue: unknown, path: Path): unknown

/** @internal */
export declare function getValueError(
  value: unknown,
  schemaType: SchemaType
): FieldValueError | undefined

/**
 * Gets a printable identifer for the workspace - either the name, or the index
 * and any potential title set for it
 *
 * @param workspace - The workspace to get the indentifier for
 * @param index - The index at which the workspace appeared in the source array
 * @returns Printable string (eg `intranet`, or `at index 5 (titled "Intranet")`)
 * @internal
 */
export declare function getWorkspaceIdentifier({name, title}: WorkspaceLike, index: number): string

/** @internal */
export declare interface GlobalErrorChannel {
  subscribe: (subscriber: GlobalErrorSubscriber) => GlobalErrorUnsubscriber
}

/** @internal */
export declare function GlobalErrorHandler(): JSX.Element

/** @internal */
export declare interface GlobalErrorMessage {
  error: Error | null
  params: {
    colno: number
    lineno: number
    error: Error
    event: ErrorEvent | string
    source?: string
  }
}

/** @internal */
export declare type GlobalErrorSubscriber = (msg: GlobalErrorMessage) => void

/** @internal */
export declare type GlobalErrorUnsubscriber = () => void

/** @internal */
export declare type GlobalPresence = {
  user: User
  status: Status
  lastActiveAt: string
  locations: PresenceLocation[]
}

/** @internal */
export declare const globalScope: typeof globalThis & {
  __sanityErrorChannel?: GlobalErrorChannel | undefined
}

/** @internal */
export declare interface Grant {
  filter: string
  permissions: DocumentValuePermission[]
}

/**
 * @hidden
 * @beta */
export declare interface GrantsStore {
  /**
   * Returns an observable of `PermissionCheckResult`
   *
   * This API is returns an observable (vs a promise) so the consumer can reac
   * to incoming changes to the user permissions (e.g. for changing _debug_
   * roles).
   *
   * This API also accepts a `null` document in which it should return
   * `granted: true`
   */
  checkDocumentPermission(
    checkPermissionName: DocumentValuePermission,
    document: Partial<SanityDocument> | null
  ): Observable<PermissionCheckResult>
}

/** @internal */
export declare interface GrantsStoreOptions {
  client: SanityClient
  currentUser: CurrentUser | null
}

/** @internal */
export declare function GroupChange(
  props: {
    change: GroupChangeNode
    readOnly?: boolean
    hidden?: boolean
  } & React_2.HTMLAttributes<HTMLDivElement>
): React_2.ReactElement | null

/**
 * Schema
 */
/**
 * "Changes" (presentation-oriented grouping of diffs)
 *
 * @internal
 */
export declare interface GroupChangeNode {
  type: 'group'
  changes: ChangeNode[]
  key: string
  path: Path
  titlePath: ChangeTitlePath
  schemaType?: SchemaType
  readOnly?: ConditionalProperty
  hidden?: ConditionalProperty
  fieldsetName?: string
}

declare type GuardedOperation = Operation<any[], 'NOT_READY'>

/**
 * An example of how to sync focus path through document.location.hash
 *
 * @internal
 */
export declare function HashFocusManager(props: HashFocusManagerProps): any

/** @internal */
export declare type HashFocusManagerChildArgs = {
  onFocus: (path: Path) => void
  onBlur: () => void
  focusPath: Path
}

/** @internal */
export declare interface HashFocusManagerProps {
  focusPath: any | null
  onFocus: () => void
  onBlur: () => void
  children: (arg0: HashFocusManagerChildArgs) => any
}

/** @internal */
export declare type HexColor = string

/** @internal */
export declare interface HiddenField {
  kind: 'hidden'
  key: string
  name: string
  index: number
}

/**
 * @hidden
 * @beta */
export declare interface HistoryStore {
  getDocumentAtRevision: (
    documentId: string,
    revision: string
  ) => Promise<SanityDocument | undefined>
  getHistory: (
    documentIds: string[],
    options?: {
      time?: string
      revision?: string
    }
  ) => Promise<{
    documents: SanityDocument[]
  }>
  getTransactions: (documentIds: string[]) => Promise<TransactionLogEventWithMutations[]>
  restore: (id: string, targetId: string, rev: string) => Observable<SanityDocument>
  /** @internal */
  getTimelineController: (options: {
    client: SanityClient
    documentId: string
    documentType: string
  }) => TimelineController
}

/** @internal */
export declare interface HistoryStoreOptions {
  client: SanityClient
}

/** @internal */
export declare type Id = string

/** @internal */
export declare interface IdPair {
  draftId: string
  publishedId: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface ImageComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<ImageValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps<ImageValue>>
  item?: ComponentType<ObjectItemProps<ImageValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function ImageInput(props: ImageInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type ImageInputProps = Omit<
  BaseImageInputProps,
  | 'assetSources'
  | 'directUploads'
  | 'imageUrlBuilder'
  | 'observeAsset'
  | 'client'
  | 'resolveUploader'
>

/**
 * @hidden
 * @beta */
export declare type ImageUrlBuilder = ReturnType<typeof imageUrlBuilder>

/** @internal */
export declare const ImperativeToast: React_2.ForwardRefExoticComponent<
  React_2.RefAttributes<unknown>
>

/**
 * @hidden
 * @beta */
export declare function inc(amount?: number, path?: Path): FormIncPatch

/**
 * This error may happen if the member type is structurally incompatible with the defined schema type.
 * Some examples:
 *   - the schema type defines an array, but the actual value is an object (or vice versa)
 *   - the schema type defines a number, but the actual value is a string (or vice versa)
 *   - the schema type defines an object, but the actual value is a string (or vice versa)
 *
 * @public
 */
export declare type IncompatibleTypeError = {
  type: 'INCOMPATIBLE_TYPE'
  expectedSchemaType: SchemaType
  resolvedValueType: string
  value: unknown
}

/** @internal */
export declare interface InitialSnapshotEvent {
  type: 'snapshot'
  documentId: string
  document: SanityDocument | null
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueErrorMsg {
  type: 'error'
  error: Error
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueLoadingMsg {
  type: 'loading'
}

/**
 * @hidden
 * @beta */
export declare type InitialValueMsg =
  | InitialValueLoadingMsg
  | InitialValueSuccessMsg
  | InitialValueErrorMsg

/**
 * @hidden
 * @beta */
export declare interface InitialValueOptions {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, any>
}

/** @internal */
export declare interface InitialValueState {
  loading: boolean
  error: Error | null
  value: SanityDocumentLike
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueSuccessMsg {
  type: 'success'
  value: SanityDocumentLike | null
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueTemplateItem extends TemplateResponse {
  id: string
  type: 'initialValueTemplateItem'
  schemaType: string
}

/**
 * @hidden
 * @beta */
export declare function InlinePreview(props: InlinePreviewProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type InlinePreviewProps = Omit<PreviewProps<'inline'>, 'renderDefault'>

/**
 * @hidden
 * @beta */
export declare type InputProps =
  | ArrayOfObjectsInputProps
  | ArrayOfPrimitivesInputProps
  | BooleanInputProps
  | NumberInputProps
  | ObjectInputProps
  | ObjectInputProps<CrossDatasetReferenceValue>
  | ObjectInputProps<FileValue>
  | ObjectInputProps<GeopointValue>
  | ObjectInputProps<ImageValue>
  | ObjectInputProps<ReferenceValue>
  | ObjectInputProps<SlugValue>
  | PortableTextInputProps
  | StringInputProps

/**
 * @hidden
 * @beta */
export declare function insert(
  items: any[],
  position: FormInsertPatchPosition,
  path?: Path
): FormInsertPatch

/** @internal */
export declare interface InsertDiffPatch {
  op: 'insert'
  after: Path
  items: unknown[]
}

/** @internal */
export declare function InsufficientPermissionsMessage(
  props: InsufficientPermissionsMessageProps
): JSX.Element

/** @internal */
export declare interface InsufficientPermissionsMessageProps {
  title?: string
  operationLabel?: string
  currentUser?: CurrentUser | null
}

/**
 *
 * @hidden
 * @beta
 */
export declare function IntentButton(
  props: IntentLinkProps & ButtonProps & Omit<HTMLProps<HTMLButtonElement>, 'as' | 'href' | 'ref'>
): JSX.Element

/**
 * @public
 */
declare interface IntentLinkProps {
  /**
   * The name of the intent to link to.
   */
  intent: string

  /**
   * The parameters to include in the intent.
   * {@link IntentParameters}
   */
  params?: IntentParameters

  /**
   * Whether to replace the current URL in the browser history instead of adding a new entry.
   */
  replace?: boolean
}

/**
 * @public
 */
declare type IntentParameters =
  | Record<string, unknown>
  | [Record<string, unknown>, Record<string, unknown>]

declare interface IntermediaryError {
  type: 'error'
  args: ExecuteArgs
  error: any
}

declare interface IntermediarySuccess {
  type: 'success'
  args: ExecuteArgs
}

/**
 * This error may happen for arrays (of both objects and primitive values) if we encounter items that are not valid according to the schema definition
 *
 *
 * @hidden
 * @beta
 */
export declare type InvalidItemTypeError = {
  type: 'INVALID_ITEM_TYPE'
  validTypes: SchemaType[]
  resolvedValueType: string
  value: unknown
}

/** @internal */
export declare function isAddedItemDiff(item: ItemDiff): item is ItemDiff & {
  diff: Diff & {
    action: 'added'
  }
}

/** @internal */
export declare function isArray(value: unknown): value is unknown[]

/**
 * @hidden
 * @beta */
export declare function isArrayOfBlocksInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is ArrayOfObjectsInputProps

/**
 * @hidden
 * @beta */
export declare function isArrayOfObjectsInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is ArrayOfObjectsInputProps

/**
 * @hidden
 * @beta */
export declare function isArrayOfPrimitivesInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is ArrayOfPrimitivesInputProps

/**
 * @hidden
 * @beta */
export declare function isBooleanInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is BooleanInputProps

/** @internal */
export declare function isBuilder(template: unknown): template is Serializeable<Template>

/**
 * @internal
 */
export declare function _isCustomDocumentTypeDefinition(
  def: SchemaTypeDefinition
): def is SchemaTypeDefinition<'document'>

/** @internal */
export declare const isDev: boolean

/** @internal */
export declare function isDraft(document: SanityDocument): boolean

/** @internal */
export declare function isDraftId(id: string): id is DraftId

/** @internal */
export declare function isEmptyObject(item: unknown): boolean

/** @internal */
export declare type IsEqualFunction<Value> = (a: Value, b: Value) => boolean

/** @internal */
export declare function isFieldChange(change: ChangeNode): change is FieldChangeNode

/** @internal */
export declare function isGroupChange(change: ChangeNode): change is GroupChangeNode

/**
 * @internal
 */
export declare function isNonNullable<T>(value: T): value is NonNullable<T>

/**
 * @hidden
 * @beta */
export declare function isNumberInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is NumberInputProps

/**
 * @hidden
 * @beta */
export declare function isObjectInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is ObjectInputProps

/**
 * @hidden
 * @beta */
export declare function isObjectItemProps(
  item: ItemProps | Omit<ItemProps, 'renderDefault'>
): item is ObjectItemProps

/** @internal */
export declare const isProd: boolean

/** @internal */
export declare function isPublishedId(id: string): id is PublishedId

/**
 * @internal
 */
export declare function isRecord(value: unknown): value is Record<string, unknown>

/** @internal */
export declare function isRemovedItemDiff(item: ItemDiff): item is ItemDiff & {
  diff: Diff & {
    action: 'removed'
  }
}

/**
 * @internal
 */
export declare function _isSanityDocumentTypeDefinition(
  def: SchemaTypeDefinition
): def is SchemaTypeDefinition<'document'>

/** @internal */
export declare function isString(value: unknown): value is string

/**
 * @hidden
 * @beta */
export declare function isStringInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>
): inputProps is StringInputProps

/** @internal */
export declare function isTruthy<T>(value: T | false): value is T

/** @internal */
export declare function isUnchangedDiff(diff: Diff): diff is Diff & {
  action: 'unchanged'
}

/** @internal */
export declare type ItemDiff = ItemDiff_2<Annotation>

/** @public */
export declare type ItemProps =
  | ObjectItemProps
  | ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>
  | ObjectItemProps<FileValue & ObjectItem>
  | ObjectItemProps<GeopointValue & ObjectItem>
  | ObjectItemProps<ImageValue & ObjectItem>
  | ObjectItemProps<ReferenceValue & ObjectItem>
  | ObjectItemProps<SlugValue & ObjectItem>
  | PrimitiveItemProps

/** @internal */
export declare const joinPath: (pathArray: SearchPathSegment[]) => string

/**
 * @hidden
 * @beta */
export declare interface LayoutProps {
  renderDefault: (props: LayoutProps) => React_2.ReactElement
}

/**
 * This component should only be used by core Sanity packages.
 * @internal
 */
export declare function LegacyLayerProvider({
  children,
  zOffset: zOffsetKey,
}: {
  children: React_2.ReactNode
  zOffset: ZIndexContextValueKey
}): JSX.Element

/** @public */
export declare interface LegacyThemeProps {
  '--font-family-monospace': string
  '--font-family-base': string
  '--black': string
  '--white': string
  '--brand-primary': string
  '--component-bg': string
  '--component-text-color': string
  '--default-button-color': string
  '--default-button-primary-color': string
  '--default-button-success-color': string
  '--default-button-warning-color': string
  '--default-button-danger-color': string
  '--focus-color': string
  '--gray-base': string
  '--gray': string
  '--main-navigation-color': string
  '--main-navigation-color--inverted': string
  '--state-info-color': string
  '--state-success-color': string
  '--state-warning-color': string
  '--state-danger-color': string
  '--screen-medium-break': string
  '--screen-default-break': string
  '--screen-large-break': string
  '--screen-xlarge-break': string
}

/** @internal */
export declare type LegacyThemeTints = {
  [key in ColorTintKey]: string
}

/**
 * @hidden
 * @beta */
export declare function LinearProgress(props: {
  /** Percentage */
  value: number
}): JSX.Element

/** @internal */
export declare type ListenerEvent =
  | MutationEvent_2
  | ReconnectEvent
  | InitialSnapshotEvent
  | PendingMutationsEvent

/** @internal */
export declare function listenQuery(
  client: SanityClient,
  query:
    | string
    | {
        fetch: string
        listen: string
      },
  params?: ListenQueryParams,
  options?: ListenQueryOptions
): Observable<any>

/**
 * @hidden
 * @beta */
export declare interface ListenQueryOptions {
  tag?: string
  apiVersion?: string
  throttleTime?: number
  transitions?: ('update' | 'appear' | 'disappear')[]
}

/** @internal */
export declare type ListenQueryParams = Record<string, string | number | boolean | string[]>

/** @internal */
export declare type LoadableState<T> = LoadingState | LoadedState<T> | ErrorState

/** @internal */
export declare interface LoadedState<T> {
  value: T
  error: null
  isLoading: false
}

/** @internal */
export declare interface LoadingState {
  value: undefined
  error: null
  isLoading: true
}

/** @internal */
export declare type LoadingTuple<T> = [T, boolean]

/** @internal */
declare interface Location_2 {
  documentId: string
  path: Path
}
export {Location_2 as Location}

/** @internal */
export declare type LoginComponentProps = Omit<WorkspaceSummary, 'type' | '__internal'>

/**
 * @hidden
 * @beta */
export declare interface LogoProps {
  title: string
  renderDefault: (props: LogoProps) => React_2.ReactElement
}

/**
 * Given a pathname and a list of workspaces, returns either a workspace match,
 * a redirect, or not-found.
 *
 * @internal
 */
export declare function matchWorkspace({
  pathname,
  workspaces,
  basePathRegex,
}: MatchWorkspaceOptions): MatchWorkspaceResult

/** @internal */
export declare interface MatchWorkspaceOptions {
  workspaces: NormalizedWorkspace[]
  pathname: string
  basePathRegex: RegExp
}

/** @internal */
export declare type MatchWorkspaceResult =
  | {
      type: 'match'
      workspace: WorkspacesContextValue[number]
    }
  | {
      type: 'redirect'
      pathname: string
    }
  | {
      type: 'not-found'
    }

/**
 * @hidden
 * @beta */
export declare function MediaPreview(props: MediaPreviewProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type MediaPreviewProps = Omit<PreviewProps<'media'>, 'renderDefault'>

declare interface MediaProps {
  border?: boolean
  dimensions: PreviewMediaDimensions
  layout: PreviewLayoutKey
  media: PreviewProps['media']
  radius?: number
  responsive?: boolean
  styles?: {
    media?: string
    mediaString?: string
  }
}

/** @internal */
export declare const MemberField: React_2.NamedExoticComponent<MemberFieldProps>

/** @internal */
export declare function MemberFieldError(props: {member: FieldError}): JSX.Element

/** @internal */
export declare interface MemberFieldProps {
  member: FieldMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/** @internal */
export declare const MemberFieldSet: React_2.NamedExoticComponent<{
  member: FieldSetMember
  renderAnnotation?: RenderAnnotationCallback<BlockAnnotationProps> | undefined
  renderBlock?: RenderBlockCallback<BlockProps> | undefined
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback<BlockProps> | undefined
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}>

/** @internal */
export declare function MemberItemError(props: {member: ArrayItemError}): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare interface MemberItemProps {
  member: ArrayOfObjectsItemMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderInlineBlock?: RenderBlockCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderField: RenderFieldCallback
  renderInput: RenderInputCallback
  renderPreview: RenderPreviewCallback
}

/** @internal */
export declare function MetaInfo(props: MetaInfoProps): JSX.Element

/** @internal */
export declare interface MetaInfoProps {
  title: string
  action?: string
  icon?: React_2.ComponentType
  children?: React_2.ReactNode
  markRemoved?: boolean
}

/**
 * @hidden
 * @beta */
export declare interface MissingConfigFile {
  missingConfigFile: true
}

/**
 * This error may happen for arrays of objects where one or more of the members are missing a _key
 *
 * @public
 */
export declare type MissingKeysError = {
  type: 'MISSING_KEYS'
  schemaType: ArraySchemaType
  value: {
    _key?: string
  }[]
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
export declare type MixedArrayError = {
  type: 'MIXED_ARRAY'
  schemaType: ArraySchemaType
  value: unknown[]
}

/** @internal */
export declare interface MockAuthStoreOptions {
  currentUser: CurrentUser | null
  client: SanityClient
}

/** @internal */
declare interface MutationEvent_2 {
  type: 'mutation'
  documentId: string
  transactionId: string
  mutations: MutationPayload[]
  effects: {
    apply: unknown
    revert: unknown
  }
  transactionTotalEvents: number
  transactionCurrentEvent: number
  transition: 'update' | 'appear' | 'disappear'
}
export {MutationEvent_2 as MutationEvent}

/**
 * @internal
 */
export declare type MutationPatch = Record<string, any>

/**
 *
 * @hidden
 * @beta
 */
export declare interface MutationPatchMsg {
  type: 'mutation'
  patches: FormPatch[]
  snapshot: unknown
}

/**
 * @hidden
 * @beta */
export declare interface MutationPayload {
  create?: any
  createIfNotExists?: any
  createOrReplace?: any
  delete?: any
  patch?: any
}

/** @internal */
export declare const NavbarContext: React_2.Context<NavbarContextValue>

/** @internal */
export declare interface NavbarContextValue {
  onSearchFullscreenOpenChange: (open: boolean) => void
  searchFullscreenOpen: boolean
  searchFullscreenPortalEl: HTMLElement | null
}

/**
 * @hidden
 * @beta */
export declare interface NavbarProps {
  renderDefault: (props: NavbarProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta */
export declare type NewDocumentCreationContext =
  | {
      type: 'global'
      documentId?: undefined
      schemaType?: undefined
    }
  | {
      type: 'document'
      documentId: string
      schemaType: string
    }
  | {
      type: 'structure'
      documentId?: undefined
      schemaType: string
    }

/**
 * @hidden
 * @beta */
export declare interface NewDocumentOptionsContext extends ConfigContext {
  creationContext: NewDocumentCreationContext
}

/**
 * @hidden
 * @beta */
export declare type NewDocumentOptionsResolver = ComposableOption<
  TemplateResponse[],
  NewDocumentOptionsContext
>

/** @internal */
export declare function newDraftFrom(document: SanityDocument): SanityDocument

/** @internal */
export declare function NoChanges(): JSX.Element

/** @internal */
export declare function noop(): void

declare function NoopTracker({children}: {children: React_2.ReactNode}): JSX.Element

/** @internal */
declare type NormalizedWorkspace = {
  workspace: WorkspacesContextValue[number]
  name?: string | undefined
  basePath: string
  basePathRegex: RegExp
}

/** @internal */
export declare function normalizeIndexSegment(segment: string): PathSegment

/** @internal */
export declare function normalizeIndexTupleSegment(segment: string): IndexTuple

/** @internal */
export declare function normalizeKeySegment(segment: string): KeyedSegment

/** @internal */
export declare function normalizePathSegment(segment: string): PathSegment

/** @internal */
export declare type NullDiff = NullDiff_2<Annotation>

/**
 *
 * @hidden
 * @beta
 */
export declare interface NumberComponents {
  diff?: ComponentType<any>
  field?: ComponentType<NumberFieldProps>
  input?: ComponentType<NumberInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type NumberDiff = NumberDiff_2<Annotation>

/**
 * @hidden
 * @beta */
export declare interface NumberFieldProps extends BaseFieldProps {
  schemaType: NumberSchemaType
  value: number | undefined
  inputProps: NumberInputProps
}

/** @public */
export declare type NumberFormNode<S extends NumberSchemaType = NumberSchemaType> = BaseFormNode<
  number,
  S
>

/**
 *
 * @hidden
 * @beta
 */
export declare function NumberInput(props: NumberInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface NumberInputProps<S extends NumberSchemaType = NumberSchemaType>
  extends BaseInputProps,
    NumberFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/** @public */
export declare interface ObjectArrayFormNode<
  T extends ObjectItem = ObjectItem,
  S extends ObjectSchemaType = ObjectSchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  value: T
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  /** @internal */
  _allMembers: ObjectMember[]
  changesOpen?: boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface ObjectComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type ObjectDiff<T extends object = Record<string, any>> = ObjectDiff_2<Annotation, T>

/**
 * @hidden
 * @beta */
export declare interface ObjectFieldProps<T = Record<string, any>> extends BaseFieldProps {
  schemaType: ObjectSchemaType
  value:
    | {
        [field in string]: unknown
      }
    | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  inputProps: ObjectInputProps<T>
}

/** @public */
export declare interface ObjectFormNode<
  T = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType
> extends BaseFormNode<T, S> {
  focusPath: Path
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  /** @internal */
  _allMembers: (ObjectMember | HiddenField)[]
}

/**
 * @hidden
 * @beta */
export declare const ObjectInput: React_2.NamedExoticComponent<
  ObjectInputProps<Record<string, any>, ObjectSchemaType>
>

/** @internal */
export declare const ObjectInputMember: React_2.NamedExoticComponent<ObjectInputMemberProps>

/** @internal */
export declare interface ObjectInputMemberProps {
  member: ObjectMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/**
 * Convenience component for wrapping an object input
 * @internal
 */
export declare function ObjectInputMembers(props: ObjectMembersProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface ObjectInputProps<
  T = Record<string, any>,
  S extends ObjectSchemaType = ObjectSchemaType
> extends BaseInputProps,
    Omit<ObjectFormNode<T, S>, '_allMembers'> {
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onFieldCollapse: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldExpand: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetCollapse: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetExpand: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldGroupSelect: (groupName: string) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onFieldOpen: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldClose: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/** @public */
export declare type ObjectItem = {
  _type?: string
  _key: string
}

/** @public */
export declare interface ObjectItemProps<Item extends ObjectItem = ObjectItem>
  extends BaseItemProps<Item> {
  changed: boolean
  schemaType: ObjectSchemaType
  parentSchemaType: ArraySchemaType
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  value: Item
  /**
   * @hidden
   * @beta */
  inputProps: Omit<ObjectInputProps, 'renderDefault'>
}

/** @public */
export declare type ObjectMember = FieldMember | FieldSetMember | FieldError

/**
 * @deprecated Use ObjectInputMembers instead
 * @internal
 */
export declare const ObjectMembers: typeof ObjectInputMembers

/** @internal */
export declare interface ObjectMembersProps {
  members: ObjectMember[]
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderField: RenderFieldCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

declare type ObserveDocumentPairAvailability = (
  id: string
) => Observable<DraftsModelDocumentAvailability>

/** @internal */
export declare type ObserveDocumentTypeFromIdFn = (id: string) => Observable<string | undefined>

/**
 * @hidden
 * @beta */
export declare type ObserveForPreviewFn = (
  value: Previewable,
  type: PreviewableType,
  viewOptions?: PrepareViewOptions,
  apiConfig?: ApiConfig
) => Observable<PreparedSnapshot>

/**
 * @hidden
 * @beta */
export declare interface ObservePathsFn {
  (value: Previewable, paths: (string | PreviewPath)[], apiConfig?: ApiConfig): Observable<
    PreviewValue | SanityDocumentLike | Reference | string | null
  >
}

/** @internal */
export declare const onRetry: () => void

/** @internal */
export declare type Opaque<T, K> = T & {
  __opaqueId__: K
}

/** @internal */
export declare interface Operation<
  ExtraArgs extends any[] = [],
  ErrorStrings extends string = string
> {
  disabled: false | ErrorStrings | 'NOT_READY'
  execute(...extra: ExtraArgs): void
}

/** @internal */
export declare interface OperationArgs {
  historyStore: HistoryStore
  client: SanityClient
  schema: Schema
  typeName: string
  idPair: IdPair
  snapshots: {
    draft: null | SanityDocument
    published: null | SanityDocument
  }
  draft: DocumentVersionSnapshots
  published: DocumentVersionSnapshots
}

/**
 * @hidden
 * @beta */
export declare interface OperationError {
  type: 'error'
  /** @internal */
  op: keyof OperationsAPI
  id: string
  error: Error
}

/** @internal */
export declare const operationEvents: (arg1: {
  client: SanityClient
  historyStore: HistoryStore
  schema: Schema
}) => Observable<IntermediarySuccess | IntermediaryError>

/** @internal */
export declare interface OperationImpl<
  ExtraArgs extends any[] = [],
  DisabledReason extends string = string
> {
  disabled: (args: OperationArgs) => DisabledReason | 'NOT_READY' | false
  execute(args: OperationArgs, ...extra: ExtraArgs): void
}

/** @internal */
export declare interface OperationsAPI {
  commit: Operation | GuardedOperation
  delete: Operation<[], 'NOTHING_TO_DELETE' | 'NOT_READY'>
  del: Operation<[], 'NOTHING_TO_DELETE'> | GuardedOperation
  publish:
    | Operation<[], 'LIVE_EDIT_ENABLED' | 'ALREADY_PUBLISHED' | 'NO_CHANGES'>
    | GuardedOperation
  patch: Operation<[patches: Patch[], initialDocument?: Record<string, any>]> | GuardedOperation
  discardChanges: Operation<[], 'NO_CHANGES' | 'NOT_PUBLISHED'> | GuardedOperation
  unpublish: Operation<[], 'LIVE_EDIT_ENABLED' | 'NOT_PUBLISHED'> | GuardedOperation
  duplicate: Operation<[documentId: string], 'NOTHING_TO_DUPLICATE'> | GuardedOperation
  restore: Operation<[revision: string]> | GuardedOperation
}

/**
 * @hidden
 * @beta */
export declare interface OperationSuccess {
  type: 'success'
  /** @internal */
  op: keyof OperationsAPI
  id: string
}

declare type Operator<TOperators = string> = OperatorDivider | OperatorItem<TOperators>

/**
 * @alpha
 */
export declare interface OperatorButtonValueComponentProps<T> {
  value: T
}

declare interface OperatorDateDirectionValue {
  includeTime?: boolean
  date: string | null
}

declare interface OperatorDateEqualValue {
  includeTime?: boolean
  date: string | null
}

declare interface OperatorDateLastValue {
  unit: 'days' | 'months' | 'years'
  unitValue: number | null
}

declare interface OperatorDateRangeValue {
  dateMax: string | null
  dateMin: string | null
  includeTime?: boolean
}

/**
 * @internal
 */
export declare const operatorDefinitions: (
  | (SearchOperatorBuilder<'dateAfter', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateAfter'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateBefore', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateBefore'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateLast', OperatorDateLastValue> & {
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateLastValue>
      initialValue: {
        unit: string
        unitValue: number
      }
      type: 'dateLast'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
      label: string
    })
  | (SearchOperatorBuilder<'dateNotEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateNotEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateRange', OperatorDateRangeValue> & {
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateRangeValue>) => string | null
      initialValue: {
        includeTime: boolean
        dateMax: string
        dateMin: null
      }
      inputComponent: SearchOperatorInput<OperatorDateRangeValue>
      type: 'dateRange'
      buttonLabel: string
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeAfter', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateTimeAfter'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeBefore', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateTimeBefore'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateTimeEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeLast', OperatorDateLastValue> & {
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
      initialValue: {
        unit: string
        unitValue: number
      }
      inputComponent: SearchOperatorInput<OperatorDateLastValue>
      type: 'dateTimeLast'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeNotEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateTimeNotEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeRange', OperatorDateRangeValue> & {
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateRangeValue>) => string | null
      initialValue: {
        includeTime: boolean
        dateMax: string
        dateMin: null
      }
      inputComponent: SearchOperatorInput<OperatorDateRangeValue>
      type: 'dateTimeRange'
      buttonLabel: string
      label: string
    })
  | (SearchOperatorBuilder<'arrayCountEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountEqual'
    })
  | (SearchOperatorBuilder<'arrayCountGt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountGt'
    })
  | (SearchOperatorBuilder<'arrayCountGte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountGte'
    })
  | (SearchOperatorBuilder<'arrayCountLt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountLt'
    })
  | (SearchOperatorBuilder<'arrayCountLte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountLte'
    })
  | (SearchOperatorBuilder<'arrayCountNotEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountNotEqual'
    })
  | (SearchOperatorBuilder<'arrayCountRange', OperatorNumberRangeValue> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
      initialValue: null
      inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
      label: string
      type: 'arrayCountRange'
    })
  | (SearchOperatorBuilder<'arrayListIncludes', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'arrayListIncludes'
    })
  | (SearchOperatorBuilder<'arrayListNotIncludes', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'arrayListNotIncludes'
    })
  | (SearchOperatorBuilder<'arrayReferenceIncludes', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'arrayReferenceIncludes'
    })
  | (SearchOperatorBuilder<'arrayReferenceNotIncludes', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'arrayReferenceNotIncludes'
    })
  | (SearchOperatorBuilder<'assetFileEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
      label: string
      type: 'assetFileEqual'
    })
  | (SearchOperatorBuilder<'assetFileNotEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
      label: string
      type: 'assetFileNotEqual'
    })
  | (SearchOperatorBuilder<'assetImageEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
      label: string
      type: 'assetImageEqual'
    })
  | (SearchOperatorBuilder<'assetImageNotEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
      label: string
      type: 'assetImageNotEqual'
    })
  | (SearchOperatorBuilder<'booleanEqual', boolean> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<boolean>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<boolean>) => string | null
      initialValue: boolean
      inputComponent: SearchOperatorInput<boolean>
      label: string
      type: 'booleanEqual'
    })
  | (ValuelessSearchOperatorBuilder<'defined'> & {
      buttonLabel: string
      groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
      label: string
      type: 'defined'
    })
  | (ValuelessSearchOperatorBuilder<'notDefined'> & {
      buttonLabel: string
      groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
      label: string
      type: 'notDefined'
    })
  | (SearchOperatorBuilder<'numberEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberEqual'
    })
  | (SearchOperatorBuilder<'numberGt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberGt'
    })
  | (SearchOperatorBuilder<'numberGte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberGte'
    })
  | (SearchOperatorBuilder<'numberLt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberLt'
    })
  | (SearchOperatorBuilder<'numberLte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberLte'
    })
  | (SearchOperatorBuilder<'numberNotEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberNotEqual'
    })
  | (SearchOperatorBuilder<'numberRange', OperatorNumberRangeValue> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
      initialValue: null
      inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
      label: string
      type: 'numberRange'
    })
  | (SearchOperatorBuilder<'portableTextEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextEqual'
    })
  | (SearchOperatorBuilder<'portableTextMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextMatches'
    })
  | (SearchOperatorBuilder<'portableTextNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextNotEqual'
    })
  | (SearchOperatorBuilder<'portableTextNotMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextNotMatches'
    })
  | (SearchOperatorBuilder<'referenceEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'referenceEqual'
    })
  | (SearchOperatorBuilder<'referenceNotEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'referenceNotEqual'
    })
  | (SearchOperatorBuilder<'referencesAssetFile', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
      label: string
      type: 'referencesAssetFile'
    })
  | (SearchOperatorBuilder<'referencesAssetImage', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
      label: string
      type: 'referencesAssetImage'
    })
  | (SearchOperatorBuilder<'referencesDocument', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'referencesDocument'
    })
  | (SearchOperatorBuilder<'slugEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      /**
       * @internal
       */
      label: string
      type: 'slugEqual'
    })
  | (SearchOperatorBuilder<'slugMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'slugMatches'
    })
  | (SearchOperatorBuilder<'slugNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'slugNotEqual'
    })
  | (SearchOperatorBuilder<'slugNotMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'slugNotMatches'
    })
  | (SearchOperatorBuilder<'stringEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringEqual'
    })
  | (SearchOperatorBuilder<'stringListEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringListEqual'
    })
  | (SearchOperatorBuilder<'stringListNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringListNotEqual'
    })
  | (SearchOperatorBuilder<'stringMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringMatches'
    })
  | (SearchOperatorBuilder<'stringNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringNotEqual'
    })
  | (SearchOperatorBuilder<'stringNotMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringNotMatches'
    })
)[]

declare type OperatorDivider = {
  type: 'divider'
}

/**
 * @alpha
 */
export declare interface OperatorInputComponentProps<T> {
  fieldDefinition?: SearchFieldDefinition
  onChange: (value: T | null) => void
  value: T | null
}

declare type OperatorItem<TOperators = string> = {
  name: TOperators
  type: 'item'
}

declare interface OperatorNumberRangeValue {
  max: number | null
  min: number | null
}

/** @internal */
export declare function OverlayDisabled(props: PresenceOverlayProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface Pair {
  /** @internal */
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  published: DocumentVersion
  draft: DocumentVersion
}

/** @internal */
export declare interface PairListenerOptions {
  tag?: string
}

/**
 * @hidden
 * @beta */
export declare type ParsedTimeRef = Chunk | 'loading' | 'invalid'

/**
 * @hidden
 * @beta */
export declare type PartialContext<TContext extends ConfigContext> = Pick<
  TContext,
  Exclude<keyof TContext, keyof ConfigContext>
>

/** @internal */
export declare type PartialExcept<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>

declare type Patch = any

/**
 *
 * @hidden
 * @beta
 */
export declare type PatchArg = FormPatch | FormPatch[]

/**
 *
 * @hidden
 * @beta
 */
export declare interface PatchChannel {
  publish: (msg: PatchMsg) => void
  subscribe: (subscriber: PatchMsgSubscriber) => () => void
}

/**
 *
 * @hidden
 * @beta
 */
export declare class PatchEvent {
  static from(input: PatchArg | PatchEvent): PatchEvent
  patches: Array<FormPatch>
  constructor(patches: Array<FormPatch>)
  prepend(...patches: PatchArg[]): PatchEvent
  append(...patches: PatchArg[]): PatchEvent
  prefixAll(segment: PathSegment): PatchEvent
}

/**
 *
 * @hidden
 * @beta
 */
export declare type PatchMsg = MutationPatchMsg | RebasePatchMsg

/**
 *
 * @hidden
 * @beta
 */
export declare interface PatchMsgSubscriber {
  (msg: PatchMsg): void
}

declare type PatchTransformer = (patches: FormPatch[]) => FormPatch[]

/** @internal */
export declare function pathsAreEqual(pathA: Path, pathB: Path): boolean

/** @internal */
export declare function pathToString(path: Path): string

/** @internal */
export declare interface PendingMutationsEvent {
  type: 'pending'
  phase: 'begin' | 'end'
}

/**
 * @hidden
 * @beta */
export declare interface PermissionCheckResult {
  granted: boolean
  reason: string
}

/**
 * @hidden
 * @beta */
declare type Plugin_2<TOptions = void> = (options: TOptions) => PluginOptions
export {Plugin_2 as Plugin}

/**
 * @hidden
 * @beta */
export declare type PluginFactory<TOptions> = (options: TOptions) => PluginOptions

/**
 * @hidden
 * @beta */
export declare interface PluginOptions {
  name: string
  plugins?: PluginOptions[]
  schema?: SchemaPluginOptions
  document?: DocumentPluginOptions
  tools?: Tool[] | ComposableOption<Tool[], ConfigContext>
  form?: SanityFormConfig
  studio?: {
    components?: StudioComponentsPluginOptions
  }
}

/** @internal */
export declare function PopoverDialog(props: PopoverDialogProps): JSX.Element

declare interface PopoverDialogProps {
  children: React_2.ReactNode
  header?: React_2.ReactNode
  onClose: () => void
  referenceElement: PopoverProps['referenceElement']
  width: ResponsiveWidthProps['width']
  containerRef?: React_2.Dispatch<React_2.SetStateAction<HTMLDivElement | null>>
}

/** @internal */
export declare type PortableTextEditorElement = HTMLDivElement | HTMLSpanElement | null

/**
 * The root Portable Text Input component
 *
 * @hidden
 * @beta
 */
declare function PortableTextInput(props: PortableTextInputProps): JSX.Element
export {PortableTextInput as BlockEditor}
export {PortableTextInput}

/**
 * @hidden
 * @beta */
export declare interface PortableTextInputProps
  extends ArrayOfObjectsInputProps<PortableTextBlock, ArraySchemaType<PortableTextBlock>> {
  hotkeys?: HotkeyOptions
  markers?: PortableTextMarker[]
  onCopy?: OnCopyFn
  onPaste?: OnPasteFn
  renderBlockActions?: RenderBlockActionsCallback
  renderCustomMarkers?: RenderCustomMarkers
}

/**
 * A generic marker for attaching metadata to specific nodes of the Portable Text input.
 *
 *
 * @hidden
 * @beta
 */
export declare interface PortableTextMarker {
  type: string
  data?: unknown
  path: Path
}

/** @internal */
export declare interface PortableTextMemberItem {
  kind: 'annotation' | 'textBlock' | 'objectBlock' | 'inlineObject'
  key: string
  member: ArrayOfObjectsItemMember
  node: ObjectFormNode
  elementRef?: React_2.MutableRefObject<PortableTextEditorElement> | undefined
  input?: ReactNode
}

/**
 * @hidden
 * @beta */
export declare type PortableTextPreviewLayoutKey = 'block' | 'blockImage' | 'inline'

/** @internal */
export declare type Position = 'top' | 'bottom' | 'inside' | null

/** @internal */
export declare function prefixPath<
  T extends {
    path: Path
  }
>(patch: T, segment: PathSegment): T

/**
 * Takes in a config (created from the `defineConfig` function) and returns
 * an array of `WorkspaceSummary`. Note: this only partially resolves a config.
 *
 * For usage inside the Studio, it's preferred to pull the pre-resolved
 * workspaces and sources via `useWorkspace` or `useSource`. For usage outside
 * the Studio or for testing, use `resolveConfig`.
 *
 * @internal
 */
export declare function prepareConfig(
  config: Config | MissingConfigFile,
  options?: {
    basePath?: string
  }
): PreparedConfig

/** @internal */
export declare interface PreparedConfig {
  type: 'prepared-config'
  workspaces: WorkspaceSummary[]
}

/**
 * @hidden
 * @beta */
export declare interface PreparedSnapshot {
  type?: PreviewableType
  snapshot: PreviewValue | null | undefined
}

/** @internal */
export declare function prepareForPreview(
  rawValue: unknown,
  type: SchemaType,
  viewOptions?: PrepareViewOptions
): PreviewValue & {
  _createdAt?: string
  _updatedAt?: string
}

/** @internal */
export declare function prepareTemplates(
  schema: Schema,
  initialValueTemplates: Template[]
): Template[]

/** @internal */
export declare interface PresenceLocation {
  type: 'document'
  documentId: string
  lastActiveAt: string
  path: Path
}

/** @internal */
export declare const PresenceOverlay: typeof OverlayDisabled

/** @internal */
export declare interface PresenceOverlayProps {
  children: React_2.ReactNode
  margins?: [number, number, number, number]
}

/** @internal */
export declare function PresenceScope(props: PresenceScopeProps): JSX.Element

/** @internal */
export declare interface PresenceScopeProps {
  readOnly?: boolean
  path: Path
  children: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface PresenceStore {
  /**
   * @internal
   */
  documentPresence: (documentId: string) => Observable<DocumentPresence[]>
  /**
   * @internal
   */
  globalPresence$: Observable<GlobalPresence[]>
  /**
   * @internal
   */
  reportLocations: (locations: PresenceLocation[]) => Observable<void>
  /**
   * @internal
   */
  setLocation: (nextLocation: PresenceLocation[]) => void
  /**
   * @internal
   */
  debugPresenceParam$: Observable<string[]>
}

/** @internal */
export declare type PresentUser = {
  user: User
  status?: Status
  sessions?: Session[]
}

/**
 * @internal
 */
export declare function Preview(props: RenderPreviewCallbackProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare type Previewable = (
  | {
      _id: string
    }
  | {
      _type: string
    }
  | {
      _ref: string
      _dataset?: string
      _projectId?: string
    }
) & {
  /**
   * optional object used to attach meta data to the prepared result.
   * currently used to add a flag for the invalid preview error fallback and
   * insufficient permissions fallback
   * @internal
   */
  _internalMeta?: {
    type?: string
  }
}

/**
 * @hidden
 * @beta */
export declare interface PreviewableType {
  fields?: {
    name: string
    type: SchemaType
  }[]
  preview?: PreviewConfig
}

/** @internal */
export declare const PreviewCard: React_2.ForwardRefExoticComponent<
  Omit<CardProps & Omit<React_2.HTMLProps<HTMLDivElement>, 'height'>, 'ref'> &
    React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface PreviewCardContextValue {
  selected?: boolean
}

/**
 * @hidden
 * @beta */
export declare type PreviewComponent = ComponentType<PreviewProps>

/**
 * @hidden
 * @beta */
export declare type PreviewLayoutKey = GeneralPreviewLayoutKey | PortableTextPreviewLayoutKey

/**
 * This component is responsible for converting renderPreview() calls into an element.
 * It:
 * - subscribes to "prepared" preview value as long as the element is visible on screen
 * - resolves the configured preview component for the schema type
 * - prepares "preview"-props and passes this to the configured preview component
 * @internal
 * */
export declare function PreviewLoader(
  props: RenderPreviewCallbackProps & {
    component: ComponentType<Omit<PreviewProps, 'renderDefault'>>
  }
): ReactElement

/**
 * @hidden
 * @beta */
export declare type PreviewMediaDimensions = {
  aspect?: number
  dpr?: number
  fit?: ImageUrlFitMode
  height?: number
  width?: number
}

/**
 * TODO: unify with content path from `@sanity/types`
 *
 *
 * @hidden
 * @beta
 */
export declare type PreviewPath = FieldName[]

/**
 *
 * @hidden
 * @beta
 */
export declare interface PreviewProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  description?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  error?: Error | null
  fallbackTitle?: ReactNode
  imageUrl?: string
  isPlaceholder?: boolean
  layout?: TLayoutKey
  media?:
    | ReactNode
    | ComponentType<{
        dimensions: PreviewMediaDimensions
        layout: TLayoutKey
      }>
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  subtitle?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  title?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType?: SchemaType
  renderDefault: (props: PreviewProps) => React_2.ReactElement
}

declare interface PreviewState {
  isLoading?: boolean
  draft?: PreviewValue | Partial<SanityDocument> | null
  published?: PreviewValue | Partial<SanityDocument> | null
}

/** @internal */
export declare type PrimitiveFieldProps = NumberFieldProps | BooleanFieldProps | StringFieldProps

/**
 * @hidden
 * @beta */
export declare type PrimitiveFormNode = BooleanFormNode | NumberFormNode | StringFormNode

/**
 * @hidden
 * @beta */
export declare interface PrimitiveInputElementProps {
  value?: string
  id: string
  readOnly: boolean
  placeholder?: string
  onChange: FormEventHandler
  onFocus: FocusEventHandler
  onBlur: FocusEventHandler
  ref: React_2.MutableRefObject<any>
}

/**
 * @hidden
 * @beta */
export declare type PrimitiveInputProps = StringInputProps | BooleanInputProps | NumberInputProps

/** @public */
export declare interface PrimitiveItemProps extends BaseItemProps<string | number | boolean> {
  value: string | number | boolean
  schemaType: NumberSchemaType | BooleanSchemaType | StringSchemaType
  parentSchemaType: ArraySchemaType
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface PrimitiveMemberItemProps {
  member: ArrayOfPrimitivesItemMember
  renderItem: RenderArrayOfPrimitivesItemCallback
  renderInput: RenderInputCallback
}

declare type PrimitiveValue = string | number | boolean

/**
 * @hidden
 * @beta */
export declare interface ProjectData {
  id: string
  displayName: string
  studioHost: string | null
  isBlocked: boolean
  isDisabled: boolean
  isDisabledByUser: boolean
  metadata: {
    color: string
    externalStudioHost: string
  }
  maxRetentionDays: number
  activityFeedEnabled: boolean
  createdAt: string
  updatedAt: string
  organizationId: string
  members: {
    id: string
    createdAt: string
    updatedAt: string
    isCurrentUser: boolean
    isRobot: boolean
    role: string
  }[]
  features: string[]
  pendingInvites: number
}

/**
 * @hidden
 * @beta */
export declare interface ProjectDatasetData {
  name: string
  aclMode: 'public' | 'private'
  createdAt: string
  createdByUserId: string
  tags: {
    name: string
    title: string
  }[]
}

/**
 * @hidden
 * @beta */
export declare interface ProjectStore {
  get: () => Observable<ProjectData>
  getDatasets: () => Observable<ProjectDatasetData[]>
}

/** @internal */
export declare type PublishedId = Opaque<string, 'publishedId'>

/**
 * @hidden
 * @beta */
export declare type QueryParams = Record<string, string | number | boolean | string[]>

/** @internal */
export declare type ReactHook<TArgs, TResult> = (args: TArgs) => TResult

/**
 *
 * @hidden
 * @beta
 */
export declare interface RebasePatchMsg {
  type: 'rebase'
  patches: FormPatch[]
  snapshot: unknown
}

/**
 * @hidden
 * @beta */
export declare interface ReconnectEvent {
  type: 'reconnect'
}

/** @internal */
export declare interface Rect {
  height: number
  width: number
  top: number
  left: number
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface ReferenceComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<ReferenceValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ReferenceInputProps>
  item?: ComponentType<ObjectItemProps<ReferenceValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type ReferenceDiff = ObjectDiff<Reference>

/** @internal */
export declare type ReferenceFieldDefinition = TemplateFieldDefinition & TemplateReferenceTarget

/**
 *
 * @hidden
 * @beta
 */
export declare function ReferenceInput(props: ReferenceInputProps): JSX.Element

/**
 * @internal
 */
export declare interface ReferenceInputOptions {
  /**
   * Represents the highlighted path if ths current document has a related open
   * child (e.g. reference in place).
   */
  activePath?: {
    path: Path
    state: 'selected' | 'pressed' | 'none'
  }
  /**
   * A specialized `EditReferenceLinkComponent` component that takes in the needed props to open a
   * referenced document to the right
   */
  EditReferenceLinkComponent?: ComponentType<
    Omit<HTMLProps<'a'>, 'children'> & EditReferenceLinkComponentProps
  >
  initialValueTemplateItems?: TemplatePermissionsResult[]
  /**
   * Similar to `EditReferenceChildLink` expect without the wrapping component
   */
  onEditReference?: (options: EditReferenceOptions) => void
}

/**
 * @internal
 */
export declare function ReferenceInputOptionsProvider(
  props: ReferenceInputOptions & {
    children: React_2.ReactNode
  }
): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type ReferenceInputProps = ObjectInputProps<Reference, ReferenceSchemaType>

/** @internal */
export declare type RegionWithIntersectionDetails = {
  distanceTop: number
  distanceBottom: number
  position: 'top' | 'bottom' | 'inside'
  region: ReportedRegionWithRect<FieldPresenceData>
}

/**
 * @hidden
 * @beta */
export declare type RemoteSnapshotEvent = DocumentRemoteMutationEvent | SnapshotEvent

/** @internal */
export declare const remoteSnapshots: (
  arg1: SanityClient,
  arg2: IdPair,
  arg3: string
) => Observable<RemoteSnapshotVersionEvent>

/**
 * @hidden
 * @beta */
export declare type RemoteSnapshotVersionEvent = WithVersion<RemoteSnapshotEvent>

/** @internal */
export declare function removeDupes(documents: SanityDocument[]): SanityDocument[]

/** @internal */
export declare const removeMissingReferences: (
  doc: SanityDocument,
  existingIds: Record<string, boolean | undefined>
) => SanityDocument

/**
 * @hidden
 * @beta */
export declare type RenderAnnotationCallback<
  T extends BlockAnnotationProps = BlockAnnotationProps
> = (annotationProps: Omit<T, 'renderDefault'>) => ReactNode

/**
 * @hidden
 * @beta  */
export declare type RenderArrayOfObjectsItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
export declare type RenderArrayOfPrimitivesItemCallback = (
  itemProps: Omit<PrimitiveItemProps, 'renderDefault'>
) => ReactNode

/**
 *
 * @hidden
 * @beta
 */
export declare type RenderBlockActionsCallback = (props: RenderBlockActionsProps) => React.ReactNode

/**
 *
 * @hidden
 * @beta
 */
export declare interface RenderBlockActionsProps {
  block: PortableTextBlock
  value: PortableTextBlock[] | undefined
  set: (block: PortableTextBlock) => void
  unset: () => void
  insert: (block: PortableTextBlock | PortableTextBlock[]) => void
}

/**
 * @hidden
 * @beta */
export declare type RenderBlockCallback<T extends BlockProps = BlockProps> = (
  blockProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * Export `PortableTextMarker` so it can be used to build custom Portable Text markers.
 *
 *
 * @hidden
 * @beta
 */
export declare type RenderCustomMarkers = (markers: PortableTextMarker[]) => React_2.ReactNode

/**
 * @hidden
 * @beta */
export declare type RenderFieldCallback<T extends FieldProps = FieldProps> = (
  fieldProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
export declare type RenderInputCallback<T extends InputProps = InputProps> = (
  inputProps: Omit<T, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
export declare type RenderItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'> | Omit<PrimitiveItemProps, 'renderDefault'>
) => ReactNode

/**
 * @hidden
 * @beta */
export declare type RenderPreviewCallback = (props: RenderPreviewCallbackProps) => ReactNode

/**
 *
 * @hidden
 * @beta
 */
export declare interface RenderPreviewCallbackProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  error?: Error | null
  fallbackTitle?: ReactNode
  isPlaceholder?: boolean
  layout?: TLayoutKey
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  value: unknown
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType: SchemaType
  skipVisibilityCheck?: boolean
  style?: CSSProperties
}

/**
 * @internal
 * @deprecated Use `renderStudio(rootElement, config, {reactStrictMode: true})` instead
 */
export declare function renderStudio(
  rootElement: HTMLElement | null,
  config: Config,
  options: boolean
): () => void

/** @internal */
export declare function renderStudio(rootElement: HTMLElement | null, config: Config): () => void

/** @internal */
export declare function renderStudio(
  rootElement: HTMLElement | null,
  config: Config,
  options: RenderStudioOptions
): () => void

declare interface RenderStudioOptions {
  basePath?: string
  reactStrictMode?: boolean
}

/** @internal */
export declare type Reported<Value> = [string, Value]

/** @internal */
export declare type ReportedRegionWithRect<T> = T & {
  id: string
  rect: Rect
}

/** @internal */
export declare type ReporterHook<Payload> = (
  id: string | null,
  value: Payload | (() => Payload),
  isEqual?: (a: Payload, b: Payload) => boolean
) => void

/**
 * A subset of the History API is used, and explicitly declared so it's possible to write a custom
 * history implementation that can be used to integrate the router in a variety of parent routers.
 * @internal
 */
declare type RequiredHistory = Pick<History_2, 'listen' | 'location' | 'push' | 'replace'>

/** @internal */
export declare const resizeObserver: SharedResizeObserver

/**
 * Fully resolves a configuration including subscribing to all sources and
 * workspaces from a config. Returns an `Observable` that waits till all sources
 * emit once before emitting an array of fully resolved sources and workspaces.
 *
 * @internal
 */
export declare function resolveConfig(config: Config): Observable<Workspace[]>

/** @internal */
export declare function resolveDiffComponent<D extends Diff = any>(
  type: SchemaType,
  parentSchemaType?: ArraySchemaType | ObjectSchemaType
): DiffComponent<D> | DiffComponentOptions | undefined

/**
 *
 * @hidden
 * @beta
 */
export declare type ResolvedUploader = {
  uploader: Uploader
  type: SchemaType
}

/** @internal */
export declare function resolveInitialObjectValue<Params extends Record<string, unknown>>(
  type: ObjectSchemaType,
  params: Params,
  maxDepth: number,
  context: InitialValueResolverContext
): Promise<any>

/** @internal */
export declare function resolveInitialValue(
  schema: Schema,
  template: Template,
  params:
    | {
        [key: string]: any
      }
    | undefined,
  context: InitialValueResolverContext
): Promise<{
  [key: string]: any
}>

/**
 * Resolve initial value for the given schema type (recursively)
 *
 * @internal
 */
export declare function resolveInitialValueForType<Params extends Record<string, unknown>>(
  /**
   * This is the name of the document.
   */
  type: SchemaType,
  /**
   * Params is a sanity context object passed to every initial value function.
   */
  params: Params,
  /**
   * Maximum recursion depth (default 9).
   */
  maxDepth: number | undefined,
  context: InitialValueResolverContext
): Promise<any>

/**
 * @hidden
 * @beta */
export declare interface ResolveProductionUrlContext extends ConfigContext {
  document: SanityDocumentLike
}

/** @internal */
export declare interface ResourceCache {
  get<T = unknown>(options: {namespace: string; dependencies: (object | null)[]}): T | undefined
  set(options: {namespace: string; dependencies: (object | null)[]; value: unknown}): void
}

/** @internal */
export declare function ResourceCacheProvider({children}: ResourceCacheProviderProps): JSX.Element

/** @internal */
export declare interface ResourceCacheProviderProps {
  children: React_2.ReactNode
}

/** @internal */
export declare type RetryingStatus = {
  type: 'retrying'
}

/** @internal */
export declare const RevertChangesButton: React_2.ForwardRefExoticComponent<
  ButtonProps &
    Omit<React_2.HTMLProps<HTMLButtonElement>, 'ref'> &
    React_2.RefAttributes<HTMLButtonElement>
>

/**
 * @internal
 */
export declare const ReviewChangesContext: Context<ReviewChangesContextValue | null>

/**
 * @internal
 */
export declare interface ReviewChangesContextValue {
  changesOpen?: boolean
}

/**
 * @public
 */
declare interface Route {
  raw: string
  segments: RouteSegment[]
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
}

/**
 * @public
 */
declare type RouteChildren =
  | RouterNode[]
  | ((state: RouterState) => Router | RouterNode | RouterNode[] | undefined | false)

/**
 * @public
 */
declare interface Router extends RouterNode {
  _isRoute: boolean
  encode: (state: RouterState) => string
  decode: (path: string) => RouterState | null
  isNotFound: (path: string) => boolean
  getBasePath: () => string
  getRedirectBase: (pathname: string) => string | null
  isRoot: (path: string) => boolean
}

/**
 * The history context is either one of the implementations from the `history` package, or a custom one that only implements
 * the subset of the History API that is used by the router, documented in `RequiredHistory`.
 * @internal
 */
declare type RouterHistory = BrowserHistory | MemoryHistory | HashHistory | RequiredHistory

/**
 * @public
 */
declare interface RouterNode {
  route: Route
  scope?: string
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
  children: RouteChildren
}

/**
 * @public
 */
declare type RouterState = Record<string, unknown>

/**
 * @public
 */
declare interface RouteSegment {
  name: string
  type: 'dir' | 'param'
}

/**
 * @public
 */
declare interface RouteTransform<T> {
  toState: (value: string) => T
  toPath: (value: T) => string
}

/**
 * @hidden
 * @beta */
export declare type RovingFocusNavigationType = 'arrows' | 'tab'

/**
 * @hidden
 * @beta */
export declare interface RovingFocusProps {
  direction?: 'horizontal' | 'vertical'
  initialFocus?: 'first' | 'last'
  navigation?: RovingFocusNavigationType[]
  loop?: boolean
  pause?: boolean
  rootElement: HTMLElement | HTMLDivElement | null
}

/** @internal */
export declare const SANITY_PATCH_TYPE: unique symbol

/**
 * TODO: rename to `VERSION`
 *
 *
 * @hidden
 * @beta
 */
export declare const SANITY_VERSION: string

/**
 *
 * @hidden
 * @beta
 */
export declare interface SanityAuthConfig {
  mode?: 'append' | 'replace'
  redirectOnSingle?: boolean
  providers?: {
    name: string
    title: string
    url: string
    logo?: string
  }[]
}

export {SanityClient}

/**
 * Used in cases where no custom preview component is provided
 * @internal
 * */
export declare function SanityDefaultPreview(props: SanityDefaultPreviewProps): ReactElement

/** @internal */
export declare interface SanityDefaultPreviewProps extends Omit<PreviewProps, 'renderDefault'> {
  error?: Error | null
  icon?: ElementType | false
}

/**
 * @public
 */
export declare interface SanityFormConfig {
  /**
   * these have not been migrated over
   *
   *
   * @hidden
   * @beta
   */
  unstable?: {
    CustomMarkers?: FormBuilderCustomMarkersComponent
    Markers?: FormBuilderMarkersComponent
  }
  /**
   * @hidden
   * @beta */
  components?: {
    input?: ComponentType<InputProps>
    field?: ComponentType<FieldProps>
    item?: ComponentType<ItemProps>
    preview?: ComponentType<PreviewProps>
    block?: ComponentType<BlockProps>
    inlineBlock?: ComponentType<BlockProps>
    annotation?: ComponentType<BlockAnnotationProps>
  }
  file?: {
    /**
     * @hidden
     * @beta */
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
  /**
   * @hidden
   * @beta */
  image?: {
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
}

/** @internal */
export declare class SchemaError extends Error {
  schema: Schema
  constructor(schema: Schema)
}

/**
 * @hidden
 * @beta */
export declare interface SchemaPluginOptions {
  name?: string
  types?:
    | SchemaTypeDefinition[]
    | ComposableOption<
        SchemaTypeDefinition[],
        Omit<ConfigContext, 'schema' | 'currentUser' | 'getClient' | 'client'>
      >
  templates?: Template[] | TemplateResolver
}

/**
 * This provides a utility function for use within Sanity Studios to create scrollable containers
 * It also provides a way for components inside a scrollable container to track onScroll on their first parent scroll container
 * NOTE: this is used by different studio utilities to track positions of elements on screen
 * NOTE: It will call any given `onScroll` callback with a Native DOM Event, and not a React Synthetic event
 * NOTE: It will not make sure the element is actually scrollable, this still needs to be done with css as usual
 *
 * @internal
 */
export declare const ScrollContainer: React_2.ForwardRefExoticComponent<
  Omit<ScrollContainerProps<React_2.ElementType<any>>, 'ref'> &
    React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface ScrollContainerProps<T extends React_2.ElementType>
  extends Omit<React_2.HTMLProps<T>, 'as' | 'onScroll'> {
  as?: React_2.ElementType | keyof JSX.IntrinsicElements
  onScroll?: (event: Event) => () => void
}

/** @internal */
export declare interface ScrollContextValue {
  onScroll?: ScrollEventHandler
}

/** @internal */
export declare type ScrollEventHandler = (event: Event) => void

/** @internal */
export declare function ScrollMonitor({onScroll, children}: ScrollMonitorProps): JSX.Element

/** @internal */
export declare interface ScrollMonitorProps {
  onScroll: ScrollEventHandler
  children?: React_2.ReactNode
}

/**
 * @internal
 */
export declare interface SearchableType {
  name: string
  title?: string
  __experimental_search: ObjectSchemaType['__experimental_search']
}

/**
 * @internal
 */
export declare function SearchDialog({onClose, onOpen, open}: SearchDialogProps): JSX.Element

declare interface SearchDialogProps {
  onClose: () => void
  onOpen: () => void
  open: boolean
}

/**
 * @internal
 */
export declare function SearchField(): JSX.Element

/**
 * @internal
 */
declare interface SearchFieldDefinition {
  documentTypes: string[]
  fieldPath: string
  filterName: string
  id: string
  name: string
  title: string
  titlePath: string[]
  type: string
}

declare interface SearchFilterBaseDefinition<TOperators> {
  description?: string
  icon: ComponentType
  name: string
  operators: Operator<TOperators>[]
}

/**
 * @alpha
 */
export declare type SearchFilterDefinition<TOperators = string> =
  | SearchFilterFieldDefinition<TOperators>
  | SearchFilterPinnedDefinition<TOperators>

declare interface SearchFilterFieldDefinition<TOperators = string>
  extends SearchFilterBaseDefinition<TOperators> {
  fieldType: IntrinsicTypeName
  type: 'field'
}

declare interface SearchFilterPinnedDefinition<TOperators = string>
  extends SearchFilterBaseDefinition<TOperators> {
  fieldPath?: string
  group?: string
  title: string
  type: 'pinned'
}

/**
 * @alpha
 */
export declare interface SearchOperatorBase {
  buttonLabel?: string
  label: string
  icon?: ComponentType
  type: string
}

/**
 * @alpha
 */
export declare interface SearchOperatorBuilder<TType extends string, TValue>
  extends SearchOperatorBase {
  buttonValueComponent: SearchOperatorButtonValue<TValue>
  groqFilter: (params: SearchOperatorParams<TValue>) => string | null
  initialValue: TValue | null
  inputComponent: SearchOperatorInput<TValue>
  type: TType
}

/**
 * @alpha
 */
export declare type SearchOperatorButtonValue<TValue> = ComponentType<
  OperatorButtonValueComponentProps<TValue>
>

/** @internal */
declare interface SearchOperatorDefinition<TValue = any> extends SearchOperatorBase {
  buttonValueComponent?: SearchOperatorButtonValue<TValue>
  groqFilter: (params: SearchOperatorParams<TValue>) => string | null
  initialValue?: TValue
  inputComponent?: SearchOperatorInput<TValue>
  type: string
}

/**
 * @alpha
 */
export declare type SearchOperatorInput<TValue> = ComponentType<OperatorInputComponentProps<TValue>>

/**
 * @alpha
 */
export declare type SearchOperatorParams<TValue> = {
  fieldPath?: string
  value?: TValue
}

declare const searchOperators: {
  stringEqual: SearchOperatorBuilder<'stringEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringEqual'
  }
  stringListEqual: SearchOperatorBuilder<'stringListEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringListEqual'
  }
  stringListNotEqual: SearchOperatorBuilder<'stringListNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringListNotEqual'
  }
  stringMatches: SearchOperatorBuilder<'stringMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringMatches'
  }
  stringNotEqual: SearchOperatorBuilder<'stringNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringNotEqual'
  }
  stringNotMatches: SearchOperatorBuilder<'stringNotMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringNotMatches'
  }
  slugEqual: SearchOperatorBuilder<'slugEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    /**
     * @internal
     */
    label: string
    type: 'slugEqual'
  }
  slugMatches: SearchOperatorBuilder<'slugMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'slugMatches'
  }
  slugNotEqual: SearchOperatorBuilder<'slugNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'slugNotEqual'
  }
  slugNotMatches: SearchOperatorBuilder<'slugNotMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'slugNotMatches'
  }
  referenceEqual: SearchOperatorBuilder<'referenceEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'referenceEqual'
  }
  referenceNotEqual: SearchOperatorBuilder<'referenceNotEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'referenceNotEqual'
  }
  referencesAssetFile: SearchOperatorBuilder<'referencesAssetFile', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
    label: string
    type: 'referencesAssetFile'
  }
  referencesAssetImage: SearchOperatorBuilder<'referencesAssetImage', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
    label: string
    type: 'referencesAssetImage'
  }
  referencesDocument: SearchOperatorBuilder<'referencesDocument', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'referencesDocument'
  }
  portableTextEqual: SearchOperatorBuilder<'portableTextEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextEqual'
  }
  portableTextMatches: SearchOperatorBuilder<'portableTextMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextMatches'
  }
  portableTextNotEqual: SearchOperatorBuilder<'portableTextNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextNotEqual'
  }
  portableTextNotMatches: SearchOperatorBuilder<'portableTextNotMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextNotMatches'
  }
  numberEqual: SearchOperatorBuilder<'numberEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberEqual'
  }
  numberGt: SearchOperatorBuilder<'numberGt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberGt'
  }
  numberGte: SearchOperatorBuilder<'numberGte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberGte'
  }
  numberLt: SearchOperatorBuilder<'numberLt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberLt'
  }
  numberLte: SearchOperatorBuilder<'numberLte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberLte'
  }
  numberNotEqual: SearchOperatorBuilder<'numberNotEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberNotEqual'
  }
  numberRange: SearchOperatorBuilder<'numberRange', OperatorNumberRangeValue> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
    initialValue: null
    inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
    label: string
    type: 'numberRange'
  }
  defined: ValuelessSearchOperatorBuilder<'defined'> & {
    buttonLabel: string
    groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
    label: string
    type: 'defined'
  }
  notDefined: ValuelessSearchOperatorBuilder<'notDefined'> & {
    buttonLabel: string
    groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
    label: string
    type: 'notDefined'
  }
  dateAfter: SearchOperatorBuilder<'dateAfter', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateAfter'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateBefore: SearchOperatorBuilder<'dateBefore', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateBefore'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateEqual: SearchOperatorBuilder<'dateEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateLast: SearchOperatorBuilder<'dateLast', OperatorDateLastValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateLastValue>
    initialValue: {
      unit: string
      unitValue: number
    }
    type: 'dateLast'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
    label: string
  }
  dateNotEqual: SearchOperatorBuilder<'dateNotEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateNotEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateRange: SearchOperatorBuilder<'dateRange', OperatorDateRangeValue> & {
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateRangeValue>) => string | null
    initialValue: {
      includeTime: boolean
      dateMax: string
      dateMin: null
    }
    inputComponent: SearchOperatorInput<OperatorDateRangeValue>
    type: 'dateRange'
    buttonLabel: string
    label: string
  }
  dateTimeAfter: SearchOperatorBuilder<'dateTimeAfter', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateTimeAfter'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateTimeBefore: SearchOperatorBuilder<'dateTimeBefore', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateTimeBefore'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateTimeEqual: SearchOperatorBuilder<'dateTimeEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateTimeEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateTimeLast: SearchOperatorBuilder<'dateTimeLast', OperatorDateLastValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
    initialValue: {
      unit: string
      unitValue: number
    }
    inputComponent: SearchOperatorInput<OperatorDateLastValue>
    type: 'dateTimeLast'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
    label: string
  }
  dateTimeNotEqual: SearchOperatorBuilder<'dateTimeNotEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateTimeNotEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateTimeRange: SearchOperatorBuilder<'dateTimeRange', OperatorDateRangeValue> & {
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateRangeValue>) => string | null
    initialValue: {
      includeTime: boolean
      dateMax: string
      dateMin: null
    }
    inputComponent: SearchOperatorInput<OperatorDateRangeValue>
    type: 'dateTimeRange'
    buttonLabel: string
    label: string
  }
  booleanEqual: SearchOperatorBuilder<'booleanEqual', boolean> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<boolean>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<boolean>) => string | null
    initialValue: boolean
    inputComponent: SearchOperatorInput<boolean>
    label: string
    type: 'booleanEqual'
  }
  assetFileEqual: SearchOperatorBuilder<'assetFileEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
    label: string
    type: 'assetFileEqual'
  }
  assetFileNotEqual: SearchOperatorBuilder<'assetFileNotEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
    label: string
    type: 'assetFileNotEqual'
  }
  assetImageEqual: SearchOperatorBuilder<'assetImageEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
    label: string
    type: 'assetImageEqual'
  }
  assetImageNotEqual: SearchOperatorBuilder<'assetImageNotEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX.Element
    label: string
    type: 'assetImageNotEqual'
  }
  arrayCountEqual: SearchOperatorBuilder<'arrayCountEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountEqual'
  }
  arrayCountGt: SearchOperatorBuilder<'arrayCountGt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountGt'
  }
  arrayCountGte: SearchOperatorBuilder<'arrayCountGte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountGte'
  }
  arrayCountLt: SearchOperatorBuilder<'arrayCountLt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountLt'
  }
  arrayCountLte: SearchOperatorBuilder<'arrayCountLte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountLte'
  }
  arrayCountNotEqual: SearchOperatorBuilder<'arrayCountNotEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountNotEqual'
  }
  arrayCountRange: SearchOperatorBuilder<'arrayCountRange', OperatorNumberRangeValue> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
    initialValue: null
    inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
    label: string
    type: 'arrayCountRange'
  }
  arrayListIncludes: SearchOperatorBuilder<'arrayListIncludes', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'arrayListIncludes'
  }
  arrayListNotIncludes: SearchOperatorBuilder<'arrayListNotIncludes', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'arrayListNotIncludes'
  }
  arrayReferenceIncludes: SearchOperatorBuilder<'arrayReferenceIncludes', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'arrayReferenceIncludes'
  }
  arrayReferenceNotIncludes: SearchOperatorBuilder<'arrayReferenceNotIncludes', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'arrayReferenceNotIncludes'
  }
}

/**
 * @alpha
 */
export declare type SearchOperatorType = keyof DefaultOperators

/**
 * @internal
 */
export declare interface SearchOptions {
  __unstable_extendedProjection?: string
  comments?: string[]
  includeDrafts?: boolean
  limit?: number
  offset?: number
  skipSortByScore?: boolean
  sort?: SearchSort[]
}

declare interface SearchParams {
  __types: string[]
  __limit: number
  __offset: number
  [key: string]: unknown
}

/**
 * @internal
 */
declare interface SearchPath {
  weight: number
  path: string
  mapWith?: string
}

declare type SearchPathSegment = string | number | []

declare interface SearchQuery {
  query: string
  params: SearchParams
  options: Record<string, unknown>
  searchSpec: SearchSpec[]
  terms: string[]
}

/**
 * @internal
 */
export declare type SearchSort = {
  direction: SortDirection
  field: string
  mapWith?: string
}

/**
 * @internal
 */
declare interface SearchSpec {
  typeName: string
  paths?: SearchPath[]
}

/**
 * @internal
 */
export declare interface SearchTerms {
  filter?: string
  query: string
  types: SearchableType[]
}

/**
 *
 * @hidden
 * @beta
 */
export declare function SelectInput(props: StringInputProps): JSX.Element

/** @internal */
declare type Selection_2 = [Id, FieldName[]]
export {Selection_2 as Selection}

/**
 * @hidden
 * @beta */
export declare type SelectionState = 'inactive' | 'rev' | 'range' | 'loading' | 'invalid'

/** @internal */
export declare type Serializeable<T> = {
  serialize(): T
}

/** @internal */
export declare interface Session {
  sessionId: string
  userId: string
  lastActiveAt: string
  locations: PresenceLocation[]
}

/** @internal */
export declare const SESSION_ID: string

/**
 * @hidden
 * @beta */
export declare function set(value: any, path?: Path): FormSetPatch

/** @internal */
export declare interface SetActiveGroupOperation {
  type: 'setSelectedGroup'
  path: Path
  groupName: string
}

/** @internal */
export declare function setAtPath<T>(
  currentTree: StateTree<T> | undefined,
  path: Path,
  value: T
): StateTree<T>

/**
 * From sanity-diff-patch
 *
 * @internal
 */
export declare interface SetDiffPatch {
  op: 'set'
  path: Path
  value: unknown
}

/**
 * @hidden
 * @beta */
export declare function setIfMissing(value: any, path?: Path): FormSetIfMissingPatch

/** @internal */
export declare interface Settings {
  forKey: (key: string) => {
    listen: (defaultValue: unknown) => Observable<unknown>
    set: (value: string) => void
    del: () => void
  }
  listen: (key: string, defaultValue: unknown) => Observable<unknown>
  set: (key: string, value: unknown) => void
  del: (key: string) => void
  forNamespace: (sub: string) => Settings
}

/** @internal */
export declare interface SettingsStore {
  forNamespace: (ns: string) => Settings
}

/** @internal */
export declare interface SharedResizeObserver {
  observe: (
    element: Element,
    observer: Subscriber<ResizeObserverEntry_2>,
    options?: ResizeObserverOptions
  ) => () => void
}

/** @internal */
export declare class SimpleFocusManager extends React_2.Component<
  SimpleFocusManagerProps,
  SimpleFocusManagerState
> {
  state: {
    focusPath: never[]
  }
  handleFocus: (path: Path) => void
  handleBlur: () => void
  render(): any
}

/** @internal */
export declare interface SimpleFocusManagerProps {
  path: any | null
  onFocus: () => void
  onBlur: () => void
  children: (arg: any) => any
}

/** @internal */
export declare interface SimpleFocusManagerState {
  focusPath: Array<any>
}

/**
 * If a single workspace is used, not specifying a name or basePath is acceptable
 *
 *
 * @hidden
 * @beta
 */
export declare type SingleWorkspace = Omit<WorkspaceOptions, 'name' | 'basePath'> & {
  name?: string
  basePath?: string
}

/** @internal */
export declare type Size = 'xsmall' | 'small' | 'medium'

/**
 *
 * @hidden
 * @beta
 */
export declare interface SlugComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<SlugValue>>
  input?: ComponentType<ObjectInputProps<SlugValue>>
  item?: ComponentType<ObjectItemProps<SlugValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function SlugInput(props: SlugInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type SlugInputProps = ObjectInputProps<SlugValue, SlugSchemaType>

/**
 * @hidden
 * @beta */
export declare interface SnapshotEvent {
  type: 'snapshot'
  document: SanityDocument
}

/** @internal */
declare interface SnapshotPair {
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  draft: DocumentVersionSnapshots
  published: DocumentVersionSnapshots
}

/** @internal */
export declare const snapshotPair: (
  arg1: SanityClient,
  arg2: IdPair,
  arg3: string
) => Observable<SnapshotPair>

/**
 * @internal
 */
declare type SortDirection = 'asc' | 'desc'

/** @public */
export declare interface Source {
  type: 'source'
  name: string
  title: string
  projectId: string
  dataset: string
  schema: Schema
  templates: Template[]
  tools: Tool[]
  currentUser: CurrentUser | null
  authenticated: boolean
  /** @internal */
  auth: AuthStore
  getClient: (clientOptions: SourceClientOptions) => SanityClient
  document: {
    /**
     * @hidden
     * @beta */
    actions: (props: PartialContext<DocumentActionsContext>) => DocumentActionComponent[]
    /**
     * @hidden
     * @beta */
    badges: (props: PartialContext<DocumentActionsContext>) => DocumentBadgeComponent[]
    /**
     * @hidden
     * @beta */
    resolveProductionUrl: (
      context: PartialContext<ResolveProductionUrlContext>
    ) => Promise<string | undefined>
    /**
     * @hidden
     * @beta */
    resolveNewDocumentOptions: (context: NewDocumentCreationContext) => InitialValueTemplateItem[]
    /** @alpha */
    unstable_languageFilter: (
      props: PartialContext<DocumentLanguageFilterContext>
    ) => DocumentLanguageFilterComponent[]
  }
  form: {
    /**
     * @hidden
     * @beta */
    file: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    /**
     * @hidden
     * @beta */
    image: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    /**
     * @hidden
     * @beta */
    components?: {
      input?: ComponentType<Omit<InputProps, 'renderDefault'>>
      field?: ComponentType<Omit<FieldProps, 'renderDefault'>>
      item?: ComponentType<Omit<ItemProps, 'renderDefault'>>
      preview?: ComponentType<Omit<PreviewProps, 'renderDefault'>>
    }
    /**
     * these have not been migrated over and are not merged by the form builder
     *
     *
     * @hidden
     * @beta
     */
    unstable?: {
      CustomMarkers?: FormBuilderCustomMarkersComponent
      Markers?: FormBuilderMarkersComponent
    }
  }
  studio?: {
    /**
     * @hidden
     * @beta */
    components?: StudioComponents
  }
  /** @alpha */
  search: {
    filters: SearchFilterDefinition[]
    operators: SearchOperatorDefinition[]
  }
  /** @internal */
  __internal: {
    bifur: BifurClient
    staticInitialValueTemplateItems: InitialValueTemplateItem[]
    options: SourceOptions
  }
}

/** @public */
export declare interface SourceClientOptions {
  apiVersion: string
}

/**
 * @hidden
 * @beta */
export declare interface SourceOptions extends PluginOptions {
  title?: string
  /**
   * Project ID for this source
   */
  projectId: string
  /**
   * Dataset name for this source
   */
  dataset: string
  /**
   * API hostname used for requests. Generally used for custom CNAMEs, allowing businesses to use
   * their own domain for API requests. Must include protocol:
   * eg `https://sanityapi.mycompany.com`
   *
   * Note that (currently) the project ID will be prepended to the passed URL, so the above
   * example would end up as: `https://<projectId>.sanityapi.mycompany.com`
   */
  apiHost?: string
  /** @internal */
  auth?: AuthStore
  /**
   * @hidden
   * @beta */
  unstable_clientFactory?: (options: ClientConfig) => SanityClient
}

/** @internal */
export declare function SourceProvider({children, ...props}: SourceProviderProps): JSX.Element

/** @internal */
export declare type SourceProviderProps =
  | {
      source: Source
      children?: React_2.ReactNode
    }
  | {
      name: string
      children?: React_2.ReactNode
    }

/**
 *
 * @hidden
 * @beta
 */
export declare interface SpanComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps>
  input?: ComponentType<ObjectInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

declare interface State {
  disableTransition: boolean
}

declare interface State_2 {
  isLoading: boolean
  error?: Error
  value?: PreviewValue
}

/**
 * @hidden
 * @beta */
export declare interface StateTree<T> {
  value: T | undefined
  children?: {
    [key: string]: StateTree<T>
  }
}

/** @internal */
export declare type Status = 'online' | 'editing' | 'inactive'

/**
 *
 * @hidden
 * @beta
 */
export declare interface StringComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type StringDiff = StringDiff_2<Annotation>

/** @internal */
export declare type StringDiffSegment = StringSegmentChanged | StringSegmentUnchanged

/**
 * @hidden
 * @beta */
export declare interface StringFieldProps extends BaseFieldProps {
  schemaType: StringSchemaType
  value: string | undefined
  inputProps: StringInputProps
}

/** @public */
export declare type StringFormNode<S extends StringSchemaType = StringSchemaType> = BaseFormNode<
  string,
  S
>

/**
 *
 * @hidden
 * @beta
 */
export declare function StringInput(props: StringInputProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface StringInputProps<S extends StringSchemaType = StringSchemaType>
  extends BaseInputProps,
    StringFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/** @internal */
export declare type StringSegmentChanged = StringSegmentChanged_2<Annotation>

/** @internal */
export declare type StringSegmentUnchanged = StringSegmentUnchanged_2

/** @internal */
export declare function stringToPath(path: string): Path

/**
 * @hidden
 * @beta */
export declare function Studio(props: StudioProps): ReactElement

/**
 * @hidden
 * @beta */
export declare interface StudioComponents {
  layout: React_2.ComponentType<Omit<LayoutProps, 'renderDefault'>>
  logo: React_2.ComponentType<Omit<LogoProps, 'renderDefault'>>
  navbar: React_2.ComponentType<Omit<NavbarProps, 'renderDefault'>>
  toolMenu: React_2.ComponentType<Omit<ToolMenuProps, 'renderDefault'>>
}

/**
 * @hidden
 * @beta */
export declare interface StudioComponentsPluginOptions {
  layout?: React_2.ComponentType<LayoutProps>
  logo?: React_2.ComponentType<LogoProps>
  navbar?: React_2.ComponentType<NavbarProps>
  toolMenu?: React_2.ComponentType<ToolMenuProps>
}

/** @public */
export declare function StudioLayout(): JSX.Element

/**
 * @hidden
 * @beta */
export declare function StudioLogo(props: LogoProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare function StudioNavbar(): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface StudioProps {
  config: Config
  basePath?: string
  /**
   * Useful for scenarios where the Studio is embedded in another app,
   * and the surrounding app also implements light and dark color schemes.
   *
   * The callback is fired whenever the user selects a new color scheme in the "Appearance" menu in the top-right dropdown.
   * It also fires on first render with its initial value if you don't provide a `scheme` prop.
   *
   * If the user selects "System" in the "Appearance" menu, the callback will be fired with `"system"` as the scheme.
   * To resolve `"system"` to the same color scheme as the Studio use the `usePrefersDark` hook from `@sanity/ui`:
   *
   * ```tsx
   * import {usePrefersDark} from '@sanity/ui'
   * import {Studio} from 'sanity'
   *
   * export default function StudioPage() {
   *   const prefersDark = usePrefersDark()
   *   const [_scheme, setScheme] = useState('system')
   *   const prefersScheme = prefersDark ? 'dark' : 'light'
   *   const scheme = _scheme === 'system' ? prefersScheme : _scheme
   *
   *   return (
   *     <AppLayout scheme={scheme}>
   *       <Studio config={config} onSchemeChange={setScheme} />
   *     </AppLayout>
   *   )
   * }
   * ```
   *
   *
   * @hidden
   * @beta
   */
  onSchemeChange?: (nextScheme: StudioThemeColorSchemeKey) => void
  /**
   * By default the Studio handles the color scheme itself, but you can provide a color scheme to use.
   * If you only define `scheme` then the top-right "Appearance" dropdown menu will be hidden,
   * and the Studio will stay in sync with the `scheme` prop.
   *
   * You may setup two-way sync and re-enable the "Appearance" dropdown menu by also providing an `onSchemeChange` callback:
   * ```tsx
   * import {Studio} from 'sanity'
   * import {useSession} from 'your-app'
   *
   * export default function StudioPage() {
   *   const session = useSession()
   *   // Overrides the default scheme to be what's in the app user session
   *   const [_scheme, setScheme] = useState(session.scheme)
   *   const scheme = _scheme === 'system' ? session.scheme : _scheme
   *
   *   return (
   *     <AppLayout scheme={scheme}>
   *       <Studio config={config} scheme={scheme} onSchemeChange={setScheme} />
   *     </AppLayout>
   *   )
   * }
   * ```
   *
   *
   * @hidden
   * @beta
   */
  scheme?: StudioThemeColorSchemeKey
  /**
   * @hidden
   * @beta */
  unstable_history?: RouterHistory
  /**
   * @hidden
   * @beta */
  unstable_globalStyles?: boolean
  /**
   * @hidden
   * @beta */
  unstable_noAuthBoundary?: boolean
}

/**
 * @hidden
 * @beta */
export declare function StudioProvider({
  children,
  config,
  basePath,
  onSchemeChange,
  scheme,
  unstable_history: history,
  unstable_noAuthBoundary: noAuthBoundary,
}: StudioProviderProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface StudioProviderProps extends StudioProps {
  children: React_2.ReactNode
}

/** @public */
export declare interface StudioTheme extends RootTheme {
  /** @internal */
  __dark?: boolean
  /** @internal */
  __legacy?: boolean
}

/**
 * Used to specify light or dark mode, or to respect system settings (prefers-color-scheme media query) use 'system'
 * @public
 */
export declare type StudioThemeColorSchemeKey = ThemeColorSchemeKey | 'system'

/**
 * @hidden
 * @beta */
export declare function StudioToolMenu(props: ToolMenuProps): JSX.Element

/** @internal */
export declare const supportsTouch: boolean

/** @internal */
export declare interface SyncState {
  isSyncing: boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare function TagsArrayInput(props: TagsArrayInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type TagsArrayInputProps = ArrayOfPrimitivesInputProps<string>

/**
 *
 * @hidden
 * @beta
 */
export declare function TelephoneInput(props: TelephoneInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type TelephoneInputProps = StringInputProps

/** @public */
export declare interface Template<Params = any, Value = any> {
  id: string
  title: string
  description?: string
  schemaType: string
  icon?: SchemaType['icon']
  value: InitialValueProperty<Params, Value>
  parameters?: TemplateParameter[]
}

/** @public */
export declare type TemplateArrayFieldDefinition = TemplateFieldDefinition & {
  type: 'array'
  of: (TemplateReferenceTarget | TypeTarget)[]
}

/** @public */
export declare interface TemplateFieldDefinition {
  name: string
  type: string
  title?: string
  description?: string
  options?: {
    [key: string]: any
  }
}

/** @internal */
export declare interface TemplateOption {
  id: string
  params?: Record<string, string | number | boolean>
}

/** @public */
export declare type TemplateParameter = TemplateFieldDefinition | TemplateArrayFieldDefinition

/** @internal */
export declare interface TemplatePermissionsOptions {
  grantsStore: GrantsStore
  schema: Schema
  templates: Template[]
  templateItems: InitialValueTemplateItem[]
  context: InitialValueResolverContext
}

/** @internal */
export declare interface TemplatePermissionsResult<TInitialValue = Record<string, unknown>>
  extends PermissionCheckResult,
    InitialValueTemplateItem {
  granted: boolean
  reason: string
  resolvedInitialValue: TInitialValue
  subtitle?: string
  template: Template
}

/**
 * @hidden
 * @beta */
export declare function TemplatePreview(props: TemplatePreviewProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface TemplatePreviewProps {
  description?: React_2.ReactNode
  isPlaceholder?: boolean
  media?: MediaProps['media']
  mediaDimensions?: PreviewMediaDimensions
  subtitle?:
    | React_2.ElementType<{
        layout: 'default'
      }>
    | React_2.ReactNode
  title?:
    | React_2.ElementType<{
        layout: 'default'
      }>
    | React_2.ReactNode
}

/** @public */
export declare interface TemplateReferenceTarget {
  type: 'reference'
  to: TypeTarget | TypeTarget[]
}

/** @public */
export declare type TemplateResolver = ComposableOption<Template[], ConfigContext>

/**
 * @hidden
 * @beta */
export declare type TemplateResponse = {
  templateId: string
  title?: string
  subtitle?: string
  description?: string
  parameters?: {
    [key: string]: any
  }
  icon?: React.ElementType | React.ReactElement
  /**
   * @experimental
   */
  initialDocumentId?: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface TextComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function TextInput(props: TextInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type TextInputProps = StringInputProps<TextSchemaType>

/** @internal */
export declare const TextWithTone: React_2.ForwardRefExoticComponent<
  Omit<TextWithToneProps, 'ref'> & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface TextWithToneProps extends ComponentProps<typeof Text_2> {
  tone: ButtonTone
  dimmed?: boolean
}

/** @internal */
export declare interface TimeAgoOpts {
  minimal?: boolean
  agoSuffix?: boolean
}

/**
 * Timeline maintains information about the history of a document:
 * Grouping raw translog entries into sensible groups, replaying and
 * reconstructing different versions and abstract other details.
 *
 * Note that this class by itself is not capable of _fetching_ information,
 * but will only organize and structure the incoming translog entries.
 *
 *
 * @hidden
 * @beta
 */
export declare class Timeline {
  reachedEarliestEntry: boolean
  publishedId: string
  draftId: string
  private _transactions
  private _chunks
  private _possiblePendingTransactions
  private _recreateTransactionsFrom?
  private _trace?
  constructor(opts: TimelineOptions)
  get chunkCount(): number
  /** Maps over the chunk from newest to oldest. */
  mapChunks<T>(mapper: (chunk: Chunk, idx: number) => T): T[]
  reset(): void
  /**
   * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
   * come in correct order for their respective version, but has no ordering requirements
   * across draft/published.
   *
   * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
   * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
   * the mutation for the draft is out of order.
   */
  addRemoteMutation(entry: DocumentRemoteMutationVersionEvent): void
  addTranslogEntry(event: TransactionLogEventWithEffects): void
  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry(): void
  /**
   * updateChunks synchronizes the chunks to match the current state
   * of the transactions array. After calling this method you need
   * to invalidate all Chunks.
   */
  updateChunks(): void
  private _removeInvalidatedChunks
  private _addChunksFromTransactions
  private _invalidateTransactionFrom
  private _createInitialChunk
  /**
   * Resolves a time reference.
   *
   * Note that the chunk returned is only valid if the timeline stays constant.
   * Once the timeline is updated, you must re-parse all references.
   */
  parseTimeId(id: string): ParsedTimeRef
  findLastPublishedBefore(chunk: Chunk | null): ParsedTimeRef
  isLatestChunk(chunk: Chunk): boolean
  createTimeId(chunk: Chunk): string
  lastChunk(): Chunk
  transactionByIndex(idx: number): Transaction | null
  chunkByTransactionIndex(idx: number, startChunkIdx?: number): Chunk
  replayBackwardsBetween(firstIdx: number, lastIdx: number, doc: CombinedDocument): CombinedDocument
  replayBackwardsUntil(firstIdx: number, doc: CombinedDocument): CombinedDocument
  calculateDiff(
    initialDoc: CombinedDocument,
    finalDoc: CombinedDocument,
    firstIdx: number,
    lastIdx: number
  ): Diff_2<Annotation>
}

/**
 * The controller is responsible for fetching information
 * about a document and maintaining a Timeline.
 *
 *
 * @hidden
 * @beta
 */
export declare class TimelineController {
  timeline: Timeline
  client: SanityClient
  handler: TimelineControllerOptions['handler']
  version: number
  /**
   * The selection state represents the  different states of the current selection:
   * - inactive: No selection is active.
   * - rev: A selection is active for a single revision.
   * - range: A selection is active for a range and we have all the data needed to render it.
   * - loading: A selection is active, but we don't have the entries yet.
   * - invalid: The selection picked is invalid.
   */
  selectionState: SelectionState
  constructor(options: TimelineControllerOptions)
  private _aligner
  private _fetchMore
  private _fetchAtLeast
  private _isRunning
  private _isSuspended
  private _didErr
  private _since
  private _sinceTime
  private _rev
  private _revTime
  private _reconstruction?
  clearRange(): void
  setRange(since: string | null, rev: string | null): void
  setLoadMore(flag: boolean): void
  get sinceTime(): Chunk | null
  get revTime(): Chunk | null
  get realRevChunk(): Chunk
  /** Returns true when there's an older revision we want to render. */
  onOlderRevision(): boolean
  findRangeForNewRev(rev: Chunk): [string | null, string | null]
  findRangeForNewSince(since: Chunk): [string, string | null]
  setRevTime(rev: string | null): void
  setSinceTime(since: string | null): void
  sinceAttributes(): Record<string, unknown> | null
  displayed(): Record<string, unknown> | null
  setReconstruction(since: Chunk | null, rev: Chunk): void
  currentDiff(): Diff_2<Annotation> | null
  currentObjectDiff(): ObjectDiff_2<Annotation> | null
  handleRemoteMutation(ev: RemoteSnapshotVersionEvent): void
  start(): void
  resume(): void
  suspend(): void
  private tick
  private fetchMoreTransactions
  private markChange
}

/**
 * @hidden
 * @beta */
export declare type TimelineControllerOptions = {
  timeline: Timeline
  client: SanityClient
  documentId: string
  documentType: string
  handler?: (err: Error | null, controller: TimelineController) => void
}

/**
 * @hidden
 * @beta */
export declare interface TimelineOptions {
  publishedId: string
  enableTrace?: boolean
}

/** @internal */
export declare interface TimelineState {
  chunks: Chunk[]
  diff: ObjectDiff_2<Annotation, Record<string, any>> | null
  hasMoreChunks: boolean
  isLoading: boolean
  onOlderRevision: boolean
  realRevChunk: Chunk | null
  revTime: Chunk | null
  selectionState: SelectionState
  sinceAttributes: Record<string, unknown> | null
  sinceTime: Chunk | null
  timelineDisplayed: Record<string, unknown> | null
  timelineReady: boolean
}

/** @internal */
export declare interface TimelineStore {
  findRangeForRev: TimelineController['findRangeForNewRev']
  findRangeForSince: TimelineController['findRangeForNewSince']
  loadMore: () => void
  getSnapshot: () => TimelineState
  subscribe: (callback: () => void) => () => void
}

/** @internal */
export declare interface ToastParams {
  closable?: boolean
  description?: React_2.ReactNode
  duration?: number
  onClose?: () => void
  title?: React_2.ReactNode
  status?: 'error' | 'warning' | 'success' | 'info'
}

/**
 * @internal
 */
export declare function toMutationPatches(patches: FormPatch[]): MutationPatch[]

/**
 * @public
 */
export declare interface Tool<Options = any> {
  component: ComponentType<{
    tool: Tool<Options>
  }>
  icon?: ComponentType
  name: string
  options?: Options
  router?: Router
  title: string
  getIntentState?: (
    intent: string,
    params: Record<string, string>,
    routerState: RouterState | undefined,
    payload: unknown
  ) => unknown
  canHandleIntent?: (intent: string, params: Record<string, unknown>, payload: unknown) => boolean
}

/**
 * @hidden
 * @beta */
export declare const ToolLink: React_2.ForwardRefExoticComponent<
  Omit<ToolLinkProps & Omit<React_2.HTMLProps<HTMLAnchorElement>, 'name' | 'href'>, 'ref'> &
    React_2.RefAttributes<HTMLAnchorElement>
>

/**
 * @hidden
 * @beta */
export declare interface ToolLinkProps {
  children: React_2.ReactNode
  name: string
}

/**
 * @hidden
 * @beta */
export declare interface ToolMenuProps {
  activeToolName?: string
  closeSidebar: () => void
  context: 'sidebar' | 'topbar'
  isSidebarOpen: boolean
  tools: Tool[]
  renderDefault: (props: ToolMenuProps) => React_2.ReactElement
}

/** @internal */
export declare interface TrackedArea {
  element: HTMLElement
}

/** @internal */
export declare interface TrackedChange {
  element: HTMLElement
  path: Path
  isChanged: boolean
  hasFocus: boolean
  hasHover: boolean
  hasRevertHover: boolean
  zIndex: number
}

/** @internal */
export declare const Tracker:
  | (({children}: {children: ReactNode}) => JSX.Element)
  | ((props: {children: ReactNode}) => JSX.Element)

/** @internal */
export declare interface TrackerContext<Value> {
  add: (id: string, value: Value) => void
  update: (id: string, value: Value) => void
  remove: (id: string) => void
  read: () => Reported<Value>[]
  subscribe: (subscriber: Subscriber<Reported<Value>[]>) => () => void
}

/**
 * @hidden
 * @beta */
export declare interface Transaction {
  index: number
  id: string
  author: string
  timestamp: string
  draftEffect?: MendozaEffectPair
  publishedEffect?: MendozaEffectPair
}

declare interface TransactionSyncLockState {
  enabled: boolean
}

/**
 * @hidden
 * @beta */
export declare const TransformPatches: React_2.NamedExoticComponent<
  {
    transform: PatchTransformer
  } & {
    children: React_2.ReactNode
  }
>

/**
 * This error may happen if the _type of the value is different from the declared schema type
 * It represents a case where we encounter field value that is structurally compatible with the field's defined schema type
 * (e.g. they are both json objects), but the _type name is different from what the schema type expects
 *
 * Note on compatibility: The schema of a field may be defined as an object with fields (a, b, c), but the value is an object with (d, e, f)
 * These are still structurally compatible because (d, e, f) will be considered undeclared members
 *
 * @public
 */
export declare type TypeAnnotationMismatchError = {
  type: 'TYPE_ANNOTATION_MISMATCH'
  expectedSchemaType: SchemaType
  resolvedValueType: string
}

/** @internal */
export declare type TypeChangeDiff = TypeChangeDiff_2<Annotation>

/** @public */
export declare interface TypeTarget {
  type: string
}

/** @internal */
export declare const uncaughtErrorHandler: () => string

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
export declare type UndeclaredMembersError = {
  type: 'UNDECLARED_MEMBERS'
  schemaType: ArraySchemaType
}

/**
 * Universal array input that will introspect its schemaType and delegate to the right implementation
 * Useful as a fallback/last resort input for an array type
 *
 *
 * @hidden
 * @beta
 */
export declare function UniversalArrayInput(
  props: ArrayOfObjectsInputProps | ArrayOfPrimitivesInputProps
): JSX.Element

/**
 * @hidden
 * @beta */
export declare function unset(path?: Path): FormUnsetPatch

/** @internal */
export declare interface UnsetDiffPatch {
  op: 'unset'
  path: Path
}

/**
 * @internal
 * @deprecated FOR INTERNAL USE.
 */
export declare function unstable_useValuePreview(props: {
  enabled?: boolean
  ordering?: SortOrdering
  schemaType?: SchemaType
  value: unknown | undefined
}): State_2

/**
 *
 * @hidden
 * @beta
 */
export declare type Uploader<S extends SchemaType = SchemaType> = {
  type: string
  accepts: string
  upload: (
    client: SanityClient,
    file: File,
    type: S,
    options?: UploadOptions
  ) => Observable<UploadProgressEvent>
  priority: number
}

/**
 * @internal
 */
export declare type UploaderDef = {
  type: string
  accepts: string
  upload: (client: SanityClient, file: File, type: SchemaType) => Observable<UploadProgressEvent>
}

/**
 *
 * @hidden
 * @beta
 */
export declare type UploaderResolver<S extends SchemaType = SchemaType> = (
  type: S,
  file: FileLike
) => Uploader<S> | null

/**
 * @hidden
 * @beta */
export declare interface UploadEvent {
  file: File
  schemaType: SchemaType
  uploader: Uploader
}

/**
 *
 * @hidden
 * @beta
 */
export declare type UploadOptions = {
  metadata?: AssetMetadataType[]
  storeOriginalFilename?: boolean
  label?: string
  title?: string
  description?: string
  creditLine?: string
  source?: AssetSourceSpec
}

/**
 *
 * @hidden
 * @beta
 */
export declare type UploadProgressEvent = {
  type: 'uploadProgress'
  patches: FormPatch[] | null
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface UrlComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function UrlInput(props: UrlInputProps): JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type UrlInputProps = StringInputProps

/** @internal */
export declare function useActiveWorkspace(): ActiveWorkspaceMatcherContextValue

/** @internal */
export declare function useAnnotationColor(annotation?: Annotation | null): UserColor

/**
 * React hook that returns a configured Sanity client instance based on the given configuration.
 * Automatically uses the correct project and dataset based on the current active workspace.
 *
 * @public
 * @param clientOptions - Options for the client. Specifying
 *   {@link https://www.sanity.io/docs/api-versioning | apiVersion} is required in order to
 *   prevent breaking changes if studio changes the API version used in other places.
 * @returns A configured Sanity client instance
 * @remarks The client instance is automatically memoized based on API version
 * @example Instantiating a client
 * ```ts
 * function MyComponent() {
 *   const client = useClient({apiVersion: '2021-06-07'})
 *   // ... do something with client instance ...
 * }
 * ```
 */
export declare function useClient(clientOptions?: SourceClientOptions): SanityClient

/**
 * @deprecated Use `useColorSchemeValue` or `useColorSchemeSetValue` instead
 * @internal
 */
export declare function useColorScheme(): {
  scheme: ThemeColorSchemeKey
  setScheme: false | ((nextScheme: StudioThemeColorSchemeKey) => void)
}

/** @internal */
export declare function _useColorSchemeInternalValue(): StudioThemeColorSchemeKey

/**
 * @internal
 */
export declare function useColorSchemeOptions(
  setScheme: (nextScheme: StudioThemeColorSchemeKey) => void
): (
  | {
      title: string
      name: 'system'
      label: string
      selected: boolean
      onSelect: () => void
      icon: React_2.ForwardRefExoticComponent<
        Omit<React_2.SVGProps<SVGSVGElement>, 'ref'> & React_2.RefAttributes<SVGSVGElement>
      >
    }
  | {
      title: string
      name: 'dark'
      label: string
      selected: boolean
      onSelect: () => void
      icon: React_2.ForwardRefExoticComponent<
        Omit<React_2.SVGProps<SVGSVGElement>, 'ref'> & React_2.RefAttributes<SVGSVGElement>
      >
    }
  | {
      title: string
      name: 'light'
      label: string
      selected: boolean
      onSelect: () => void
      icon: React_2.ForwardRefExoticComponent<
        Omit<React_2.SVGProps<SVGSVGElement>, 'ref'> & React_2.RefAttributes<SVGSVGElement>
      >
    }
)[]

/** @alpha */
export declare function useColorSchemeSetValue():
  | false
  | ((nextScheme: StudioThemeColorSchemeKey) => void)

/** @alpha */
export declare function useColorSchemeValue(): ThemeColorSchemeKey

/**
 * Reduce a {@link Source} down to a {@link ConfigContext}, memoizing using `React.useMemo`
 *
 * @param source - Source to convert
 * @returns A config context containing only the defined properties of that interface
 * @internal
 */
export declare function useConfigContextFromSource(source: Source): ConfigContext

/** @internal */
export declare function useConnectionState(
  publishedDocId: string,
  docTypeName: string
): ConnectionState

/** @internal */
export declare function useConnectionStatusStore(): ConnectionStatusStore

/** @internal */
export declare function useCurrentUser(): CurrentUser | null

/**
 * React hook that returns the name of the current dataset
 *
 * @public
 * @returns The name of the current dataset
 * @example Using the `useDataset` hook
 * ```ts
 * function MyComponent() {
 *   const dataset = useDataset()
 *   // ... do something with the dataset name ...
 * }
 * ```
 */
export declare function useDataset(): string

/** @internal */
export declare function useDiffAnnotationColor(diff: Diff, path?: string | Path): UserColor

/** @internal */
export declare function useDocumentChange(): DocumentChangeContextInstance

/** @internal */
export declare function useDocumentOperation(
  publishedDocId: string,
  docTypeName: string
): OperationsAPI

/** @internal */
export declare function useDocumentOperationEvent(
  publishedDocId: string,
  docTypeName: string
): OperationSuccess | OperationError | undefined

/** @internal */
export declare function useDocumentPairPermissions({
  id,
  type,
  permission,
  client: overrideClient,
  schema: overrideSchema,
  grantsStore: overrideGrantsStore,
}: PartialExcept<DocumentPairPermissionsOptions, 'id' | 'type' | 'permission'>): ReturnType<
  typeof useDocumentPairPermissionsFromHookFactory
>

/**
 * Gets document pair permissions based on a document ID and a type.
 *
 * This permissions API is a high-level permissions API that is draft-model
 * aware. In order to determine whether or not the user has the given
 * permission, both the draft and published documents are pulled and run through
 * all of the user's grants. If any pre or post conditions fail a permissions
 * checks, the operations will not be granted.
 *
 * The operations this hook accepts are only relevant to document pairs. E.g.
 * `'create'` is not included as an operation because it's not possible to tell
 * if a document can be created by only using the initial ID and type because an
 * initial template value may not have a matching grant (e.g. locked-document
 * pattern `!locked`). In contrast, the operation `'duplicate'` is supported
 * because the draft value of the document can be live queried and checked for
 * matching grants.
 *
 * Note: for live-edit documents, non-applicable operations (e.g. publish) will
 * return as true.
 *
 * @see useDocumentValuePermissions
 *
 * @internal
 */
export declare const useDocumentPairPermissionsFromHookFactory: ReactHook<
  DocumentPairPermissionsOptions,
  LoadingTuple<PermissionCheckResult | undefined>
>

/** @internal */
export declare function useDocumentPresence(documentId: string): DocumentPresence[]

/**
 * @hidden
 * @beta */
export declare function useDocumentPreviewStore(): DocumentPreviewStore

/**
 * @hidden
 * @beta */
export declare function useDocumentStore(): DocumentStore

/** @internal */
export declare function useDocumentType(
  documentId: string,
  specifiedType?: string
): DocumentTypeResolveState

/** @internal */
export declare function useDocumentValuePermissions({
  document,
  permission,
  ...rest
}: PartialExcept<DocumentValuePermissionsOptions, 'permission' | 'document'>): ReturnType<
  typeof useDocumentValuePermissionsFromHookFactory
>

/**
 * Gets permissions based on the value of the document passed into the hook
 * (stateless).
 *
 * Note: this is a lower-level API (compared to `useDocumentPairPermissions`)
 * that is _not_ draft-model aware.
 *
 * As a consequence, the operations it accepts are also low-level. (e.g.
 * `'publish'` permissions can't be determined with this API). This is because
 * it's not possible to tell if a user can do high-level document pair
 * operations on document using only one document value.
 *
 * For example, in order to determine if a user can publish, the current value
 * of the published document needs to be pulled and checked against the user's
 * grants. If there are no matching grants, then it fails the pre-condition and
 * no operation is allowed regardless of the given document.
 *
 * @see useDocumentPairPermissions
 *
 * @internal
 */
export declare const useDocumentValuePermissionsFromHookFactory: ReactHook<
  DocumentValuePermissionsOptions,
  LoadingTuple<PermissionCheckResult | undefined>
>

/** @internal */
export declare function useDocumentValues<T = Record<string, unknown>>(
  documentId: string,
  paths: string[]
): LoadableState<T | undefined>

/** @internal */
export declare function useEditState(
  publishedDocId: string,
  docTypeName: string,
  priority?: 'default' | 'low'
): EditStateFor

/**
 *
 * @hidden
 * @beta
 */
export declare function useFormBuilder(): FormBuilderContextValue

/** @internal */
export declare function useFormCallbacks(): FormCallbacksValue

/** @internal */
export declare function useFormState<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType
>(
  schemaType: ObjectSchemaType,
  {
    comparisonValue,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    openPath,
    presence,
    validation,
    readOnly,
    changesOpen,
  }: {
    fieldGroupState?: StateTree<string> | undefined
    collapsedFieldSets?: StateTree<boolean> | undefined
    collapsedPaths?: StateTree<boolean> | undefined
    value: Partial<FIXME_SanityDocument>
    comparisonValue: Partial<FIXME_SanityDocument> | null
    openPath: Path
    focusPath: Path
    presence: FormNodePresence[]
    validation: ValidationMarker[]
    changesOpen?: boolean
    readOnly?: boolean
  }
): FormState<T, S> | null

/**
 * React hook that returns the value of the field specified by a path.
 * @public
 * @param path - An array notation with segments that are either strings representing field names, index integers for arrays with simple values, or objects with a _key for arrays containing objects
 * @example Using the `useFormValue` hook
 * ```ts
 * function MyComponent() {
 *    // get value of field 'name' in object 'author'
 *    const authorName = useFormValue(['author', 'name'])
 *    // get value of the second item in array 'tags' of type 'string'
 *    const secondTag = useFormValue(['tags', 1])
 *    // get value of the reference with the matching key in an array of references
 *    const specificBook = useFormValue([ 'bibliography', {_key: '<key>'} ])
 *   // ... do something with the form values ...
 * }
 * ```
 */
export declare function useFormValue(path: Path): unknown

/** @internal */
export declare function useGlobalPresence(): GlobalPresence[]

/**
 * @hidden
 * @beta */
export declare function useGrantsStore(): GrantsStore

/**
 * @hidden
 * @beta */
export declare function useHistoryStore(): HistoryStore

/**
 * @internal
 */
export declare function useInitialValue(props: {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, unknown>
}): InitialValueState

/**
 * @internal
 */
export declare function useInitialValueResolverContext(): InitialValueResolverContext

/** @internal */
export declare function useLoadable<T>(value$: Observable<T>): LoadableState<T | undefined>

/** @internal */
export declare function useLoadable<T>(value$: Observable<T>, initialValue: T): LoadableState<T>

/** @internal */
export declare function useMiddlewareComponents<T extends {}>(props: {
  pick: (plugin: PluginOptions) => ComponentType<T>
  defaultComponent: ComponentType<T>
}): ComponentType<T>

/** @internal */
export declare function useOnScroll(callback: Subscriber<Event>): void

/**
 * @hidden
 * @beta */
export declare function usePresenceStore(): PresenceStore

/** @internal */
export declare function usePreviewCard(): PreviewCardContextValue

/** @internal */
export declare function useProject(): {
  value: ProjectData | null
}

/** @internal */
export declare function useProjectDatasets(): {
  value: ProjectDatasetData[] | null
}

/**
 * React hook that returns the current project id
 *
 * @public
 * @returns The current project id
 * @example Using the `useProjectId` hook
 * ```ts
 * function MyComponent() {
 *   const projectId = useProjectId()
 *   // ... do something with the project id ...
 * }
 * ```
 */
export declare function useProjectId(): string

/**
 * @hidden
 * @beta */
export declare function useProjectStore(): ProjectStore

/**
 * @hidden
 * @beta */
export declare function UserAvatar(props: UserAvatarProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface UserAvatarProps {
  animateArrowFrom?: AvatarPosition
  position?: AvatarPosition
  size?: AvatarSize
  status?: AvatarStatus
  tone?: 'navbar'
  user: User | string
  withTooltip?: boolean
}

/** @internal */
export declare interface UserColor {
  name: ColorHueKey
  background: HexColor
  border: HexColor
  text: HexColor
  tints: ColorTints
}

/** @internal */
export declare type UserColorHue = string

/** @internal */
export declare interface UserColorManager {
  get: (userId: UserId | null) => UserColor
  listen: (userId: UserId) => Observable<UserColor>
}

/** @internal */
export declare interface UserColorManagerOptions {
  anonymousColor?: UserColor
  userStore?: {
    me: Observable<{
      id: string
    } | null>
  }
  colors?: Record<UserColorHue, UserColor>
  currentUserColor?: UserColorHue
  scheme: ThemeColorSchemeKey
}

/** @internal */
export declare function UserColorManagerProvider({
  children,
  manager: managerFromProps,
}: UserColorManagerProviderProps): React_2.ReactElement

/** @internal */
export declare interface UserColorManagerProviderProps {
  children: React_2.ReactNode
  manager?: UserColorManager
}

/**
 * @internal
 */
export declare function useReferenceInputOptions(): ReferenceInputOptions

/** @internal */
export declare const useReportedValues:
  | (() => Reported<TrackedChange | TrackedArea>[])
  | (() => Reported<TrackedChange | TrackedArea>[])

/** @internal */
export declare const useReporter:
  | ((
      id: string | null,
      value: TrackedChange | TrackedArea | (() => TrackedChange | TrackedArea)
    ) => void)
  | ReporterHook<TrackedChange | TrackedArea>

/** @internal */
export declare function useResolveInitialValueForType<Params extends Record<string, unknown>>(): (
  /**
   * This is the name of the document.
   */
  type: SchemaType,
  /**
   * Params is a sanity context object passed to every initial value function.
   */
  params: Params
) => Promise<any>

/** @internal */
export declare function useResourceCache(): ResourceCache

/**
 * @internal
 */
export declare function useReviewChanges(): ReviewChangesContextValue

/**
 * Checks whether or not the given user has the role with the given ID
 *
 * @param user - The user to check (currently only the current user is supported)
 * @param roleId - The ID of the role to check for
 * @returns True if the user has the role, false otherwise
 * @example
 * Fetch the current user and check if they have the role "administrator":
 * ```
 * import {userHasRole, useCurrentUser} from 'sanity'
 *
 * export function MyComponent() {
 *   const user = useCurrentUser()
 *   const hasAdminRole = userHasRole(user, 'administrator')
 *   return <div>Is administrator: {hasAdminRole ? 'Yes' : 'No'}</div>
 * }
 * ```
 * @public
 */
export declare function userHasRole(user: CurrentUser, roleId: string): boolean

/** @internal */
export declare type UserId = string

/**
 * This hook handles focus with the keyboard arrows.
 *
 * @see {@link https://a11y-solutions.stevenwoodson.com/solutions/focus/roving-focus/ | Roving focus definition}
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const [rootElement, setRootElement] = setRootElement(null)
 *
 *   useRovingFocus({
 *     rootElement: rootElement,
 *   })
 *
 *   return (
 *     <div ref={setRootElement}>
 *       <button>Button</button>
 *       <button>Button</button>
 *       <button>Button</button>
 *     </div>
 *   )
 * }
 * ```
 *
 *
 * @hidden
 * @beta
 */
export declare function useRovingFocus(props: RovingFocusProps): undefined

/** @internal */
export declare interface UserSessionPair {
  user: User
  session: Session
}

/**
 * @hidden
 * @beta */
export declare interface UserStore {
  getUser(userId: string): Promise<User | null>
  getUsers(userIds: string[]): Promise<User[]>
}

/** @internal */
export declare interface UserStoreOptions {
  client: SanityClient
  currentUser: CurrentUser | null
}

/**
 * React hook that returns the schema registry for the current project
 *
 * @public
 * @returns The schema registry for the current project
 * @example Using the `useSchema` hook
 * ```ts
 * function MyComponent() {
 *   const schema = useSchema()
 *   // ... do something with the schema ...
 * }
 * ```
 */
export declare function useSchema(): Schema

/** @internal */
export declare function useSettingsStore(): SettingsStore

/**
 * @internal
 * @deprecated INTERNAL USE ONLY
 */
export declare function useSource(): Source

/** @internal */
export declare function useSyncState(publishedDocId: string, documentType: string): SyncState

/** @internal */
export declare function useTemplatePermissions({
  templateItems,
  ...rest
}: PartialExcept<TemplatePermissionsOptions, 'templateItems'>): ReturnType<
  typeof useTemplatePermissionsFromHookFactory
>

/**
 * Takes in an array of initial template values and returns an object of
 * `TemplatePermissionsResult` keyed by the IDs of the initial template values
 * given.
 *
 * The `TemplatePermissionsResult` is an object that contains a `granted`
 * boolean per key and can be used to determine if a user has the ability to
 * create documents using the given initial value template items.
 *
 * For each initial template value item, the corresponding template is found and
 * resolved against the parameters in each the initial template value item. The
 * resolved value is then run through the document-value permissions. If there
 * are any matching grants for the resolved initial template value, the
 * `TemplatePermissionsResult` will include `granted: true`.
 *
 * @internal
 */
export declare const useTemplatePermissionsFromHookFactory: ReactHook<
  TemplatePermissionsOptions,
  LoadingTuple<TemplatePermissionsResult<Record<string, unknown>>[] | undefined>
>

/**
 *
 * @hidden
 * @beta
 */
export declare function useTemplates(): Template[]

/**
 * @internal
 *
 * @example
 * ```tsx
 * // First create a callback using React’s `useCallback` hook
 * const myCallback = useCallback(() => {
 *   // this is not throttled
 * }, [])
 *
 * // Then make a throttled version using the `useThrottledCallback` hook
 * const myThrottledCallback = useThrottledCallback(myCallback, 100)
 *
 * // Call the throttled callback
 * <Button onClick={myThrottledCallback} />
 * ```
 */
export declare function useThrottledCallback(
  callback: (...args: any[]) => any,
  wait: number,
  options: ThrottleSettings
): (...args: any[]) => any

/** @internal */
export declare function useTimeAgo(time: Date | string, {minimal, agoSuffix}?: TimeAgoOpts): string

declare interface UseTimelineControllerOpts {
  documentId: string
  documentType: string
  onError?: (err: Error) => void
  rev?: string
  since?: string
}

/**
 * Custom hook which wraps around `useSyncExternalStore`.
 * Accepts a selector function which can be used to opt-in to specific timelineStore updates.
 *
 * @internal
 */
export declare function useTimelineSelector<ReturnValue>(
  timelineStore: TimelineStore,
  selector: (timelineState: TimelineState) => ReturnValue
): ReturnValue

/**
 * Creates a store which handles the creation of a document Timeline,
 * TimelineController and also fetches pre-requisite document snapshots.
 *
 * `TimelineStore` exposes select TimelineController methods used to query
 * ranges and fetch more transactions. It can also be used with
 * `useSyncExternalStore` to subscribe to selected state changes.
 *
 * @internal
 * */
export declare function useTimelineStore({
  documentId,
  documentType,
  onError,
  rev,
  since,
}: UseTimelineControllerOpts): TimelineStore

/**
 *
 * @hidden
 * @beta
 */
export declare function useTools(): Tool[]

/**
 * This React hook should be considered an escape hatch – to make sure that a value is the same
 * on every render. SHOULD NOT BE USED IN MOST CASES.
 * @deprecated please use `useMemo` and `useCallback` strategies instead to make deps stable, this hook runs comparisons on every single render and while each comparison can be fast, it quickly adds up
 *
 * @internal
 */
export declare function useUnique<ValueType>(value: ValueType): ValueType

/** @internal */
export declare function useUser(userId: string): LoadingTuple<User | null | undefined>

/** @internal */
export declare function useUserColor(userId: string | null): UserColor

/** @internal */
export declare function useUserColorManager(): UserColorManager

/**
 * @hidden
 * @beta */
export declare function useUserStore(): UserStore

/** @internal */
export declare function useValidationStatus(
  publishedDocId: string,
  docTypeName: string
): ValidationStatus

/**
 * @internal
 */
export declare function useVirtualizerScrollInstance(): VirtualizerScrollInstance

/**
 * @hidden
 * @beta */
export declare function useWorkspace(): Workspace

/** @internal */
export declare function useWorkspaces(): WorkspaceSummary[]

/**
 * TODO: Rename to `useZOffsets`
 *
 * @internal
 */
export declare function useZIndex(): ZIndexContextValue

/**
 * Validates the base paths of every workspace
 * Only exported for testing purposes
 *
 * @param workspaces - An array of workspaces
 * @internal
 */
export declare function validateBasePaths(workspaces: WorkspaceLike[]): void

/**
 * Validates the workspace names of every workspace
 * Only exported for testing purposes
 *
 * @param workspaces - An array of workspaces
 * @internal
 */
export declare function validateNames(workspaces: WorkspaceLike[]): void

/** @internal */
export declare interface ValidateWorkspaceOptions {
  workspaces: WorkspaceLike[]
}

/**
 * Validates workspace configuration, throwing if:
 *
 * - Workspaces do not all have base paths and names (if multiple given)
 * - Base paths or names are invalid
 * - Base paths or names are not unique
 *
 * @internal
 */
export declare function validateWorkspaces({workspaces}: ValidateWorkspaceOptions): void

/** @internal */
export declare const validation: (
  arg1: {
    client: SanityClient
    getClient: (options: SourceClientOptions) => SanityClient
    observeDocumentPairAvailability: ObserveDocumentPairAvailability
    schema: Schema
  },
  arg2: IdPair,
  arg3: string
) => Observable<ValidationStatus>

/** @internal */
export declare function ValidationList(props: ValidationListProps): JSX.Element | null

/** @internal */
export declare interface ValidationListProps {
  documentType?: ObjectSchemaType
  kind?: 'simple'
  validation: ValidationMarker[]
  onFocus?: (path: Path) => void
  onClose?: () => void
  truncate?: boolean
}

/**
 * @hidden
 * @beta */
export declare interface ValidationStatus {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

/** @internal */
export declare function ValueError({error}: {error: FieldValueError}): JSX.Element

/**
 * @alpha
 */
export declare interface ValuelessSearchOperatorBuilder<TType extends string>
  extends SearchOperatorBase {
  buttonValueComponent?: never
  groqFilter: (params: ValuelessSearchOperatorParams) => string | null
  initialValue?: never
  inputComponent?: never
  type: TType
}

/**
 * @alpha
 */
export declare type ValuelessSearchOperatorParams = {
  fieldPath?: string
}

/**
 * @internal
 */
export declare interface VirtualizerScrollInstance {
  scrollElement: HTMLElement | null
}

/**
 * This is used to store the reference to the scroll element for virtualizer
 * @internal
 */
export declare const VirtualizerScrollInstanceContext: Context<VirtualizerScrollInstance | null>

/**
 *
 * @internal
 */
export declare function VirtualizerScrollInstanceProvider(
  props: VirtualizerScrollInstanceProviderProps
): JSX.Element

/**
 * @internal
 */
declare interface VirtualizerScrollInstanceProviderProps extends VirtualizerScrollInstance {
  children: React_2.ReactNode
}

/**
 * Visit all diffs in tree, until visitor returns false
 *
 * @param diff - Diff to visit
 * @param visitor - Visitor function, return false to stop from going deeper
 *
 * @internal
 */
export declare function visitDiff(
  diff: Diff | StringDiffSegment,
  visitor: DiffVisitor,
  path?: Path
): void

/**
 * @internal
 */
export declare interface WeightedSearchOptions {
  filter?: string
  params?: Record<string, unknown>
  tag?: string
  unique?: boolean
}

/** @internal */
export declare interface WelcomeEvent {
  type: 'welcome'
}

/**
 * @internal
 * @deprecated - Will be removed in 4.0.0, use the `useReferringDocuments(<documentId>)` hook instead
 */
export declare function WithReferringDocuments({
  children,
  id,
}: {
  children: (props: {isLoading: boolean; referringDocuments: SanityDocument[]}) => ReactElement
  /**
   * @deprecated - no longer required
   */
  documentStore?: DocumentStore
  id: string
}): ReactElement<any, string | JSXElementConstructor<any>>

/**
 * @hidden
 * @beta */
export declare type WithVersion<T> = T & {
  version: 'published' | 'draft'
}

/** @public */
export declare interface Workspace extends Omit<Source, 'type'> {
  type: 'workspace'
  basePath: string
  subtitle?: string
  icon: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  unstable_sources: Source[]
}

/** @internal */
export declare interface WorkspaceLike {
  name?: string
  title?: string
  basePath?: string
}

/**
 * @hidden
 * @beta */
export declare interface WorkspaceOptions extends SourceOptions {
  basePath: string
  subtitle?: string
  logo?: ComponentType
  icon?: ComponentType
  /**
   * @hidden
   * @beta */
  theme?: StudioTheme
  /**
   * @hidden
   * @beta */
  unstable_sources?: SourceOptions[]
}

/** @internal */
export declare function WorkspaceProvider({
  children,
  workspace,
}: WorkspaceProviderProps): JSX.Element

/** @internal */
export declare interface WorkspaceProviderProps {
  workspace: Workspace
  children?: React_2.ReactChild
}

/** @internal */
export declare const WorkspacesContext: Context<WorkspacesContextValue | null>

/** @internal */
export declare type WorkspacesContextValue = WorkspaceSummary[]

/** @internal */
export declare function WorkspacesProvider({
  config,
  children,
  basePath,
}: WorkspacesProviderProps): JSX.Element

/** @internal */
export declare interface WorkspacesProviderProps {
  config: Config
  children: React_2.ReactNode
  basePath?: string
}

/** @internal */
export declare interface WorkspaceSummary {
  type: 'workspace-summary'
  name: string
  title: string
  icon: React_2.ReactNode
  subtitle?: string
  basePath: string
  auth: AuthStore
  projectId: string
  dataset: string
  theme: StudioTheme
  schema: Schema
  /**
   * @internal
   * @deprecated not actually deprecated but don't use or you'll be fired
   */
  __internal: {
    sources: Array<{
      name: string
      projectId: string
      dataset: string
      title: string
      auth: AuthStore
      schema: Schema
      source: Observable<Source>
    }>
  }
}

/**
 * TODO: Rename to `ZOffsetsContextValue`
 *
 * @internal
 */
export declare interface ZIndexContextValue {
  /** Used by: Navbar */
  navbar: number | number[]
  navbarPopover: number | number[]
  navbarDialog: number | number[]
  /** Used by: DefaultPane, DocumentPane */
  pane: number | number[]
  paneHeader: number | number[]
  paneFooter: number | number[]
  paneResizer: number | number[]
  /** Used by: EditItemFoldOut, Spinner, ConnectorsOverlay, tippy.css, BaseDateTimeInput */
  portal: number | number[]
  /** Used by: Tooltip */
  popover: number | number[]
  /** Used by: `@sanity/google-maps-input` */
  modal: number | number[]
  /** TODO this path does not seem to be correct - fix?  */
  /** Used by: `movingItem` in packages/sanity/src/styles/layout/helpers.css */
  movingItem: number | number[]
  /** Used for shadow behind the navbar search, and behind sidemenu */
  drawershade: number | number[]
  /** Used by: Snackbar */
  drawer: number | number[]
  /** Used for UI that sits on top of the entire application */
  fullscreen: number | number[]
  /** Used for toasts */
  toast: number | number[]
  dropdown: number | number[]
  navbarFixed: number | number[]
  fullscreenEdit: number | number[]
  popoverBackground: number | number[]
  tooltip: number | number[]
  modalBackground: number | number[]
  spinner: number | number[]
}

/** @internal */
export declare type ZIndexContextValueKey = keyof ZIndexContextValue

/**
 * TODO: Rename to `ZOffsetsProvider`
 *
 * @internal
 */
export declare function ZIndexProvider({
  children,
}: {
  children?: React_2.ReactNode
}): React_2.ReactElement

export * from '@sanity/types'

export {}

declare module '@sanity/types' {
  interface ArrayDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ArrayOfObjectsComponents | ArrayOfPrimitivesComponents
  }
  interface BlockDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: {
      block?: ComponentType<BlockProps>
    }
  }
  interface BlockDecoratorDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    component?: ComponentType<BlockDecoratorProps>
  }
  interface BlockStyleDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    component?: ComponentType<BlockStyleProps>
  }
  interface BlockListDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    component?: ComponentType<BlockListItemProps>
  }
  interface BlockAnnotationDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: {
      annotation?: ComponentType<BlockAnnotationProps>
    }
  }
  interface BooleanDefinition {
    components?: BooleanComponents
  }
  interface DateDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: DateComponents
  }
  interface DatetimeDefinition {
    components?: DatetimeComponents
  }
  interface DocumentDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: DocumentComponents
  }
  interface FileDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: FileComponents
  }
  interface GeopointDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: GeopointComponents
  }
  interface ImageDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ImageComponents
  }
  interface NumberDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: NumberComponents
  }
  interface ObjectDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ObjectComponents
  }
  interface ReferenceDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ReferenceComponents
  }
  interface CrossDatasetReferenceDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: CrossDatasetReferenceComponents
  }
  interface SlugDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: SlugComponents
  }
  interface SpanDefinition {
    components?: SpanComponents
  }
  interface StringDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: StringComponents
  }
  interface TextDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: TextComponents
  }
  interface UrlDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: UrlComponents
  }
  interface EmailDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: EmailComponents
  }
}
//# sourceMappingURL=definitionExtensions.d.ts.map
