"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonorepoDefaultSettings = exports.MissingBuildTarget = exports.MissingBuildPipeline = void 0;
const path_1 = require("path");
const monorepo_managers_1 = require("./monorepo-managers");
const package_managers_1 = require("../package-managers/package-managers");
const detect_framework_1 = require("../detect-framework");
const json5_1 = __importDefault(require("json5"));
const semver_1 = __importDefault(require("semver"));
class MissingBuildPipeline extends Error {
    constructor() {
        super('Missing required `build` pipeline in turbo.json or package.json Turbo configuration.');
    }
}
exports.MissingBuildPipeline = MissingBuildPipeline;
class MissingBuildTarget extends Error {
    constructor() {
        super('Missing required `build` target in either nx.json, project.json, or package.json Nx configuration.');
    }
}
exports.MissingBuildTarget = MissingBuildTarget;
function supportsRootCommand(turboSemVer) {
    if (!turboSemVer) {
        return false;
    }
    if (!semver_1.default.validRange(turboSemVer)) {
        return false;
    }
    return !semver_1.default.intersects(turboSemVer, '<1.8.0');
}
async function getMonorepoDefaultSettings(projectName, projectPath, relativeToRoot, detectorFilesystem) {
    const [monorepoManager, packageManager] = await Promise.all([
        (0, detect_framework_1.detectFramework)({
            fs: detectorFilesystem,
            frameworkList: monorepo_managers_1.monorepoManagers,
        }),
        (0, detect_framework_1.detectFramework)({
            fs: detectorFilesystem,
            frameworkList: package_managers_1.packageManagers,
        }),
    ]);
    if (monorepoManager === 'turbo') {
        const [turboJSONBuf, packageJSONBuf] = await Promise.all([
            detectorFilesystem.readFile('turbo.json').catch(() => null),
            detectorFilesystem.readFile('package.json').catch(() => null),
        ]);
        let hasBuildPipeline = false;
        let turboSemVer = null;
        if (turboJSONBuf !== null) {
            const turboJSON = json5_1.default.parse(turboJSONBuf.toString('utf-8'));
            if (turboJSON?.pipeline?.build) {
                hasBuildPipeline = true;
            }
        }
        if (packageJSONBuf !== null) {
            const packageJSON = JSON.parse(packageJSONBuf.toString('utf-8'));
            if (packageJSON?.turbo?.pipeline?.build) {
                hasBuildPipeline = true;
            }
            turboSemVer =
                packageJSON?.dependencies?.turbo ||
                    packageJSON?.devDependencies?.turbo ||
                    null;
        }
        if (!hasBuildPipeline) {
            throw new MissingBuildPipeline();
        }
        if (projectPath === '/') {
            return {
                monorepoManager: 'turbo',
                buildCommand: 'turbo run build',
                installCommand: packageManager ? `${packageManager} install` : null,
                commandForIgnoringBuildStep: 'npx turbo-ignore',
            };
        }
        let buildCommand = null;
        if (projectPath) {
            if (supportsRootCommand(turboSemVer)) {
                buildCommand = `turbo run build`;
            }
            else {
                // We don't know for sure if the local `turbo` supports inference.
                buildCommand = `cd ${relativeToRoot} && turbo run build --filter={${projectPath}}...`;
            }
        }
        return {
            monorepoManager: 'turbo',
            buildCommand,
            installCommand: packageManager === 'npm'
                ? `${packageManager} install --prefix=${relativeToRoot}`
                : packageManager
                    ? `${packageManager} install`
                    : null,
            commandForIgnoringBuildStep: 'npx turbo-ignore',
        };
    }
    else if (monorepoManager === 'nx') {
        // No ENOENT handling required here since conditional wouldn't be `true` unless `nx.json` was found.
        const nxJSONBuf = await detectorFilesystem.readFile('nx.json');
        const nxJSON = json5_1.default.parse(nxJSONBuf.toString('utf-8'));
        if (!nxJSON?.targetDefaults?.build) {
            const [projectJSONBuf, packageJSONBuf] = await Promise.all([
                detectorFilesystem
                    .readFile((0, path_1.join)(projectPath, 'project.json'))
                    .catch(() => null),
                detectorFilesystem
                    .readFile((0, path_1.join)(projectPath, 'package.json'))
                    .catch(() => null),
            ]);
            let hasBuildTarget = false;
            if (projectJSONBuf) {
                const projectJSON = json5_1.default.parse(projectJSONBuf.toString('utf-8'));
                if (projectJSON?.targets?.build) {
                    hasBuildTarget = true;
                }
            }
            if (packageJSONBuf) {
                const packageJSON = json5_1.default.parse(packageJSONBuf.toString('utf-8'));
                if (packageJSON?.nx) {
                    if (packageJSON.nx.targets?.build) {
                        hasBuildTarget = true;
                    }
                }
            }
            if (!hasBuildTarget) {
                throw new MissingBuildTarget();
            }
        }
        if (projectPath === '/') {
            return {
                monorepoManager: 'nx',
                buildCommand: 'npx nx build',
                installCommand: packageManager ? `${packageManager} install` : null,
            };
        }
        return {
            monorepoManager: 'nx',
            buildCommand: projectName
                ? `cd ${relativeToRoot} && npx nx build ${projectName}`
                : null,
            installCommand: packageManager === 'npm'
                ? `${packageManager} install --prefix=${relativeToRoot}`
                : packageManager
                    ? `${packageManager} install`
                    : null,
        };
    }
    // TODO (@Ethan-Arrowood) - Revisit rush support when we can test it better
    /* else if (monorepoManager === 'rush') {
      setCommand(
        'buildCommand',
        `node ${relativeToRoot}/common/scripts/install-run-rush.js build --to ${projectName}`
      );
      setCommand(
        'installCommand',
        `node ${relativeToRoot}/common/scripts/install-run-rush.js install`
      );
    } */
    return null;
}
exports.getMonorepoDefaultSettings = getMonorepoDefaultSettings;
//# sourceMappingURL=get-monorepo-default-settings.js.map