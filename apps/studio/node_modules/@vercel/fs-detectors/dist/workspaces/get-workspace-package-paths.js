"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkspacePackagePaths = void 0;
const path_1 = __importDefault(require("path"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const glob_1 = __importDefault(require("glob"));
const json5_1 = __importDefault(require("json5"));
const get_glob_fs_1 = require("./get-glob-fs");
const posixPath = path_1.default.posix;
async function getWorkspacePackagePaths({ fs, workspace, }) {
    const { type, rootPath } = workspace;
    const workspaceFs = fs.chdir(rootPath);
    let results = [];
    switch (type) {
        case 'yarn':
        case 'npm':
            results = await getPackageJsonWorkspacePackagePaths({ fs: workspaceFs });
            break;
        case 'pnpm':
            results = await getPnpmWorkspacePackagePaths({ fs: workspaceFs });
            break;
        case 'nx':
            results = await getNxWorkspacePackagePaths({ fs: workspaceFs });
            break;
        case 'rush':
            results = await getRushWorkspacePackagePaths({ fs: workspaceFs });
            break;
        default:
            throw new Error(`Unknown workspace implementation: ${type}`);
    }
    return results.map(packagePath => {
        return posixPath.join(rootPath, posixPath.dirname(packagePath));
    });
}
exports.getWorkspacePackagePaths = getWorkspacePackagePaths;
const isWin = process.platform === 'win32';
const normalizePath = (p) => (isWin ? p.replace(/\\/g, '/') : p);
async function getPackagePaths(packages, fs) {
    return (await Promise.all(packages.map(packageGlob => new Promise((resolve, reject) => {
        (0, glob_1.default)(normalizePath(posixPath.join(packageGlob, 'package.json')), {
            cwd: '/',
            fs: (0, get_glob_fs_1.getGlobFs)(fs),
        }, (err, matches) => {
            if (err)
                reject(err);
            else
                resolve(matches);
        });
    })))).flat();
}
async function getPackageJsonWorkspacePackagePaths({ fs, }) {
    const packageJsonAsBuffer = await fs.readFile('package.json');
    const { workspaces } = JSON.parse(packageJsonAsBuffer.toString());
    let packages = [];
    if (Array.isArray(workspaces)) {
        packages = workspaces;
    }
    else {
        packages = workspaces?.packages ?? [];
    }
    return getPackagePaths(packages, fs);
}
async function getNxWorkspacePackagePaths({ fs, }) {
    const nxWorkspaceJsonAsBuffer = await fs.readFile('workspace.json');
    const { projects } = JSON.parse(nxWorkspaceJsonAsBuffer.toString());
    const packages = Object.values(projects);
    return getPackagePaths(packages, fs);
}
async function getPnpmWorkspacePackagePaths({ fs, }) {
    const pnpmWorkspaceAsBuffer = await fs.readFile('pnpm-workspace.yaml');
    const { packages = [] } = js_yaml_1.default.load(pnpmWorkspaceAsBuffer.toString());
    return getPackagePaths(packages, fs);
}
async function getRushWorkspacePackagePaths({ fs, }) {
    const rushWorkspaceAsBuffer = await fs.readFile('rush.json');
    const { projects = [] } = json5_1.default.parse(rushWorkspaceAsBuffer.toString());
    if (Array.isArray(projects)) {
        const packages = projects
            .filter(proj => proj.projectFolder)
            .map(project => project.projectFolder);
        return getPackagePaths(packages, fs);
    }
    else {
        return [];
    }
}
//# sourceMappingURL=get-workspace-package-paths.js.map