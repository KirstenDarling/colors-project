"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectFrameworkVersion = exports.detectFrameworkRecord = exports.detectFramework = void 0;
const child_process_1 = require("child_process");
async function matches(fs, framework) {
    const { detectors } = framework;
    if (!detectors) {
        return;
    }
    const { every, some } = detectors;
    if (every !== undefined && !Array.isArray(every)) {
        return;
    }
    if (some !== undefined && !Array.isArray(some)) {
        return;
    }
    const check = async ({ path, matchContent, matchPackage, }) => {
        if (matchPackage && matchContent) {
            throw new Error(`Cannot specify "matchPackage" and "matchContent" in the same detector for "${framework.slug}"`);
        }
        if (matchPackage && path) {
            throw new Error(`Cannot specify "matchPackage" and "path" in the same detector for "${framework.slug}" because "path" is assumed to be "package.json".`);
        }
        if (!path && !matchPackage) {
            throw new Error(`Must specify either "path" or "matchPackage" in detector for "${framework.slug}".`);
        }
        if (!path) {
            path = 'package.json';
        }
        if (matchPackage) {
            matchContent = `"(dev)?(d|D)ependencies":\\s*{[^}]*"${matchPackage}":\\s*"(.+?)"[^}]*}`;
        }
        if ((await fs.hasPath(path)) === false) {
            return;
        }
        if (matchContent) {
            if ((await fs.isFile(path)) === false) {
                return;
            }
            const regex = new RegExp(matchContent, 'm');
            const content = await fs.readFile(path);
            const match = content.toString().match(regex);
            if (!match) {
                return;
            }
            if (matchPackage && match[3]) {
                return {
                    framework,
                    detectedVersion: match[3],
                };
            }
        }
        return {
            framework,
        };
    };
    const result = [];
    if (every) {
        const everyResult = await Promise.all(every.map(item => check(item)));
        result.push(...everyResult);
    }
    if (some) {
        let someResult;
        for (const item of some) {
            const itemResult = await check(item);
            if (itemResult) {
                someResult = itemResult;
                break;
            }
        }
        result.push(someResult);
    }
    if (!result.every(res => !!res)) {
        return;
    }
    const detectedVersion = result.find(r => typeof r === 'object' && r.detectedVersion)?.detectedVersion;
    return {
        framework,
        detectedVersion,
    };
}
// TODO: Deprecate and replace with `detectFrameworkRecord`
async function detectFramework({ fs, frameworkList, }) {
    const result = await Promise.all(frameworkList.map(async (frameworkMatch) => {
        if (await matches(fs, frameworkMatch)) {
            return frameworkMatch.slug;
        }
        return null;
    }));
    return result.find(res => res !== null) ?? null;
}
exports.detectFramework = detectFramework;
// Note: Does not currently support a `frameworkList` of monorepo managers
async function detectFrameworkRecord({ fs, frameworkList, }) {
    const result = await Promise.all(frameworkList.map(async (frameworkMatch) => {
        const matchResult = await matches(fs, frameworkMatch);
        if (matchResult) {
            return {
                ...frameworkMatch,
                detectedVersion: matchResult?.detectedVersion,
            };
        }
        return null;
    }));
    const frameworkRecord = result.find(res => res !== null) ?? null;
    return frameworkRecord;
}
exports.detectFrameworkRecord = detectFrameworkRecord;
function detectFrameworkVersion(frameworkRecord) {
    const allDetectors = [
        ...(frameworkRecord.detectors?.every || []),
        ...(frameworkRecord.detectors?.some || []),
    ];
    const firstMatchPackage = allDetectors.find(d => d.matchPackage);
    if (!firstMatchPackage?.matchPackage) {
        return;
    }
    return lookupInstalledVersion(process.execPath, firstMatchPackage.matchPackage);
}
exports.detectFrameworkVersion = detectFrameworkVersion;
function lookupInstalledVersion(cwd, packageName) {
    try {
        const script = `require('${packageName}/package.json').version`;
        return (0, child_process_1.spawnSync)(cwd, ['-p', script], {
            encoding: 'utf-8',
        }).stdout.trim();
    }
    catch (error) {
        console.debug(`Error looking up version of installed package "${packageName}": ${error}`);
    }
    return;
}
//# sourceMappingURL=detect-framework.js.map