{"version":3,"file":"1.js","sources":["../src/values/Path.ts","../src/values/StreamValue.ts","../src/values/dateHelpers.ts","../src/values/utils.ts","../src/evaluator/equality.ts","../src/evaluator/matching.ts","../src/evaluator/ordering.ts","../src/evaluator/operators.ts","../src/evaluator/scope.ts","../src/evaluator/evaluate.ts","../src/evaluator/constantEvaluate.ts","../src/evaluator/pt.ts","../src/evaluator/scoring.ts","../src/evaluator/functions.ts","../src/markProcessor.ts","../src/rawParser.js","../src/traversal.ts","../src/parser.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n","import {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i')\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n","import {getType, GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {gatherText, matchAnalyzePattern, matchText, matchTokenize, Pattern, Token} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  match: async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import {Value} from '../values'\nimport {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data._ref\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data._id) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {}\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n    },\n    null\n  )\n  return evaluate(tree, scope)\n}\n","import {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n","import {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj._type !== 'string') return null\n  const children = obj.children\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, Token} from './matching'\nimport {Scope} from './scope'\nimport {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport {Executor} from './types'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n_global.anywhere = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global.anywhere.arity = 1\n\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global.count.arity = 1\n\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global.dateTime.arity = 1\n\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global.defined.arity = 1\n\n// eslint-disable-next-line require-await\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity)\n}\n_global.identity.arity = 0\n\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global.length.arity = 1\n\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global.path.arity = 1\n\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global.string.arity = 1\n\n_global.references = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global.references.arity = (c) => c >= 1\n\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global.round.arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global.now.arity = 0\n\n// eslint-disable-next-line require-await\n_global.boost = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global.boost.arity = 2\n\nconst string: FunctionSet = {}\n\nstring.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring.lower.arity = 1\n\nstring.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring.upper.arity = 1\n\nstring.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring.split.arity = 2\n\n_global.lower = string.lower\n_global.upper = string.upper\n\nstring.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring.startsWith.arity = 2\n\nconst array: FunctionSet = {}\n\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray.join.arity = 2\n\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray.compact.arity = 1\n\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray.unique.arity = 1\n\nconst pt: FunctionSet = {}\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt.text.arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions.order = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions.order.arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data._score === 'number' ? value.data._score : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions.score.arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta.changedAny = () => {\n  throw new Error('not implemented')\n}\ndelta.changedAny.arity = 1\ndelta.changedAny.mode = 'delta'\n\ndelta.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndelta.changedOnly.arity = 1\ndelta.changedOnly.mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff.changedAny = () => {\n  throw new Error('not implemented')\n}\ndiff.changedAny.arity = 3\n\ndiff.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndiff.changedOnly.arity = 3\n\nconst math: FunctionSet = {}\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.min.arity = 1\n\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.max.arity = 1\n\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath.sum.arity = 1\n\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath.avg.arity = 1\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n}\n","import {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {Mark, MarkProcessor, MarkVisitor} from './markProcessor'\nimport {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc(p) {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc(p) {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right\n      )\n  },\n\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param(p) {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n"],"names":["escapeRegExp","string","replace","pathRegExp","pattern","re","part","split","push","RegExp","concat","join","Path","constructor","patternRe","matches","str","test","toJSON","StreamValue","generator","type","ticker","isDone","data","isArray","get","result","value","Symbol","asyncIterator","i","length","_nextTick","currentResolver","setupTicker","Promise","resolve","tick","fetch","RFC3339_REGEX","parseRFC3339","Date","formatRFC3339","d","year","addLeadingZero","getUTCFullYear","month","getUTCMonth","day","getUTCDate","hour","getUTCHours","minute","getUTCMinutes","second","getUTCSeconds","fractionalSecond","millis","getMilliseconds","num","targetLength","toString","StaticValue","Array","element","fromJS","Error","NULL_VALUE","TRUE_VALUE","FALSE_VALUE","DateTime","date","parseToValue","equals","other","getTime","add","secs","copy","setTime","difference","compareTo","fromNumber","Number","isFinite","fromString","fromDateTime","dt","fromPath","path","isIterator","obj","next","val","getType","isEqual","a","b","CHARS","CHARS_WITH_WILDCARD","EDGE_CHARS","MAX_TERM_LENGTH","matchText","tokens","patterns","every","matchTokenize","text","match","matchAnalyzePattern","termsRe","matchPatternRegex","map","some","token","terms","term","slice","gatherText","cb","success","TYPE_ORDER","datetime","number","boolean","partialCompare","aType","bType","totalCompare","aTypeOrder","bTypeOrder","operators","eq","left","right","neq","gt","gte","lt","lte","in","inop","didSucceed","matched","plus","minus","numericOperator","Math","pow","impl","Scope","params","source","context","parent","isHidden","createNested","createHidden","evaluate","node","scope","execute","arguments","undefined","func","EXECUTORS","promiselessApply","then","This","_","Selector","Everything","Parameter","_ref","name","Context","_ref2","key","Parent","_ref3","n","current","OpCall","op","_ref4","leftValue","rightValue","Select","_ref5","alternatives","fallback","alt","altCond","condition","InRange","base","isInclusive","_ref6","leftCmp","rightCmp","Filter","_ref7","expr","baseValue","elem","newScope","exprValue","Projection","_ref8","FuncCall","args","_ref9","PipeFuncCall","_ref10","AccessAttribute","_ref11","hasOwnProperty","AccessElement","_ref12","index","finalIndex","Slice","_ref13","array","leftIdx","rightIdx","Deref","_ref14","id","doc","_id","Value","_ref15","Group","_ref16","Object","_ref17","attributes","attr","attrType","cond","assign","_ref18","elements","isSplat","v","Tuple","Or","_ref19","And","_ref20","Not","_ref21","Neg","_ref22","Pos","_ref23","Asc","Desc","ArrayCoerce","_ref24","Map","_ref25","FlatMap","_ref26","innerValue","inner","evaluateQuery","tree","options","root","dataset","timestamp","identity","sanity","after","before","canConstantEvaluate","DUMMY_SCOPE","tryConstantEvaluate","constantEvaluate","portableTextContent","blockText","texts","arrayText","block","_type","children","child","BM25k","evaluateScore","evaluateMatchScore","innerScore","boost","leftScore","rightScore","res","score","freq","reduce","c","hasReference","pathSet","has","values","countUTF8","count","code","charCodeAt","_global","anywhere","arity","coalesce","arg","dateTime","defined","references","Set","size","scopeValue","round","prec","precValue","isInteger","toFixed","now","toISOString","lower","toLowerCase","upper","toUpperCase","sep","from","startsWith","prefix","arr","buf","needSep","compact","unique","added","iter","pt","projectId","pipeFunctions","order","mappers","directions","mapper","direction","aux","idx","tuple","sort","aTuple","bTuple","unknown","scored","valueScore","_score","newObject","delta","operation","hasBefore","hasAfter","changedAny","mode","changedOnly","diff","math","min","max","sum","avg","namespaces","global","MarkProcessor","marks","parseOptions","allowBoost","hasMark","pos","getMark","shift","process","visitor","mark","call","processString","processStringEnd","prev","curr","position","len","WS","NUM","IDENT","PREC_PAIR","PREC_OR","PREC_AND","PREC_COMP","PREC_ORDER","PREC_ADD","PREC_SUB","PREC_MUL","PREC_DIV","PREC_MOD","PREC_POW","PREC_POS","PREC_NOT","PREC_NEG","parse","skipWS","parseExpr","failPosition","level","startPos","rhs","parseObject","parseString","identLen","parseRegex","numLen","fracLen","expLen","parseFuncCall","lhsLevel","trav","loop","innerPos","parseTraversal","unshift","nextToken","nextPos","identPos","ident","parseRegexStr","isGroup","rangePos","identStart","nameLen","lastPos","pairPos","indexOf","m","exec","flatMap","traverseArray","build","traversePlain","traverseElement","traverseProjection","ESCAPE_SEQUENCE","f","r","t","expandHex","charCode","parseInt","String","fromCharCode","GroqQueryError","EXPR_BUILDER","group","p","everything","this","dblparent","traverse","traversalList","TRAVERSE_BUILDER","traversal","this_attr","neg","sub","mul","div","mod","comp","in_range","char","integer","strValue","float","sci","object","OBJECT_BUILDER","members","func_call","namespace","argumentShouldBeSelector","SELECTOR_BUILDER","funcs","validateArity","pipecall","oldAllowBoost","markName","pair","and","or","not","asc","desc","param","object_expr","extractPropertyKey","object_pair","object_splat","object_splat_this","square_bracket","projection","attr_access","deref","wrap","array_postfix","functionName","argCount","functionsRequiringSelectors","includes","GroqSyntaxError","input","rawParse","processor"],"mappings":"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"}